
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model BackgroundMigration
 * 
 */
export type BackgroundMigration = $Result.DefaultSelection<Prisma.$BackgroundMigrationPayload>
/**
 * Model LlmApiKeys
 * 
 */
export type LlmApiKeys = $Result.DefaultSelection<Prisma.$LlmApiKeysPayload>
/**
 * Model OrganizationMembership
 * 
 */
export type OrganizationMembership = $Result.DefaultSelection<Prisma.$OrganizationMembershipPayload>
/**
 * Model ProjectMembership
 * 
 */
export type ProjectMembership = $Result.DefaultSelection<Prisma.$ProjectMembershipPayload>
/**
 * Model MembershipInvitation
 * 
 */
export type MembershipInvitation = $Result.DefaultSelection<Prisma.$MembershipInvitationPayload>
/**
 * Model TraceSession
 * 
 */
export type TraceSession = $Result.DefaultSelection<Prisma.$TraceSessionPayload>
/**
 * Model Trace
 * 
 */
export type Trace = $Result.DefaultSelection<Prisma.$TracePayload>
/**
 * Model Observation
 * 
 */
export type Observation = $Result.DefaultSelection<Prisma.$ObservationPayload>
/**
 * Model Score
 * 
 */
export type Score = $Result.DefaultSelection<Prisma.$ScorePayload>
/**
 * Model ScoreConfig
 * 
 */
export type ScoreConfig = $Result.DefaultSelection<Prisma.$ScoreConfigPayload>
/**
 * Model AnnotationQueue
 * 
 */
export type AnnotationQueue = $Result.DefaultSelection<Prisma.$AnnotationQueuePayload>
/**
 * Model AnnotationQueueItem
 * 
 */
export type AnnotationQueueItem = $Result.DefaultSelection<Prisma.$AnnotationQueueItemPayload>
/**
 * Model CronJobs
 * 
 */
export type CronJobs = $Result.DefaultSelection<Prisma.$CronJobsPayload>
/**
 * Model Dataset
 * 
 */
export type Dataset = $Result.DefaultSelection<Prisma.$DatasetPayload>
/**
 * Model DatasetItem
 * 
 */
export type DatasetItem = $Result.DefaultSelection<Prisma.$DatasetItemPayload>
/**
 * Model DatasetRuns
 * 
 */
export type DatasetRuns = $Result.DefaultSelection<Prisma.$DatasetRunsPayload>
/**
 * Model DatasetRunItems
 * 
 */
export type DatasetRunItems = $Result.DefaultSelection<Prisma.$DatasetRunItemsPayload>
/**
 * Model Events
 * 
 */
export type Events = $Result.DefaultSelection<Prisma.$EventsPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Prompt
 * 
 */
export type Prompt = $Result.DefaultSelection<Prisma.$PromptPayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model Price
 * 
 */
export type Price = $Result.DefaultSelection<Prisma.$PricePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model EvalTemplate
 * 
 */
export type EvalTemplate = $Result.DefaultSelection<Prisma.$EvalTemplatePayload>
/**
 * Model JobConfiguration
 * 
 */
export type JobConfiguration = $Result.DefaultSelection<Prisma.$JobConfigurationPayload>
/**
 * Model JobExecution
 * 
 */
export type JobExecution = $Result.DefaultSelection<Prisma.$JobExecutionPayload>
/**
 * Model SsoConfig
 * 
 */
export type SsoConfig = $Result.DefaultSelection<Prisma.$SsoConfigPayload>
/**
 * Model PosthogIntegration
 * 
 */
export type PosthogIntegration = $Result.DefaultSelection<Prisma.$PosthogIntegrationPayload>
/**
 * Model BatchExport
 * 
 */
export type BatchExport = $Result.DefaultSelection<Prisma.$BatchExportPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model TraceMedia
 * 
 */
export type TraceMedia = $Result.DefaultSelection<Prisma.$TraceMediaPayload>
/**
 * Model ObservationMedia
 * 
 */
export type ObservationMedia = $Result.DefaultSelection<Prisma.$ObservationMediaPayload>
/**
 * Model TraceView
 * 
 */
export type TraceView = $Result.DefaultSelection<Prisma.$TraceViewPayload>
/**
 * Model ObservationView
 * 
 */
export type ObservationView = $Result.DefaultSelection<Prisma.$ObservationViewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER',
  NONE: 'NONE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ObservationType: {
  SPAN: 'SPAN',
  EVENT: 'EVENT',
  GENERATION: 'GENERATION'
};

export type ObservationType = (typeof ObservationType)[keyof typeof ObservationType]


export const ObservationLevel: {
  DEBUG: 'DEBUG',
  DEFAULT: 'DEFAULT',
  WARNING: 'WARNING',
  ERROR: 'ERROR'
};

export type ObservationLevel = (typeof ObservationLevel)[keyof typeof ObservationLevel]


export const ScoreSource: {
  ANNOTATION: 'ANNOTATION',
  API: 'API',
  EVAL: 'EVAL'
};

export type ScoreSource = (typeof ScoreSource)[keyof typeof ScoreSource]


export const ScoreDataType: {
  CATEGORICAL: 'CATEGORICAL',
  NUMERIC: 'NUMERIC',
  BOOLEAN: 'BOOLEAN'
};

export type ScoreDataType = (typeof ScoreDataType)[keyof typeof ScoreDataType]


export const AnnotationQueueObjectType: {
  TRACE: 'TRACE',
  OBSERVATION: 'OBSERVATION'
};

export type AnnotationQueueObjectType = (typeof AnnotationQueueObjectType)[keyof typeof AnnotationQueueObjectType]


export const AnnotationQueueStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type AnnotationQueueStatus = (typeof AnnotationQueueStatus)[keyof typeof AnnotationQueueStatus]


export const DatasetStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type DatasetStatus = (typeof DatasetStatus)[keyof typeof DatasetStatus]


export const CommentObjectType: {
  TRACE: 'TRACE',
  OBSERVATION: 'OBSERVATION',
  SESSION: 'SESSION',
  PROMPT: 'PROMPT'
};

export type CommentObjectType = (typeof CommentObjectType)[keyof typeof CommentObjectType]


export const JobType: {
  EVAL: 'EVAL'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const JobConfigState: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type JobConfigState = (typeof JobConfigState)[keyof typeof JobConfigState]


export const JobExecutionStatus: {
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED'
};

export type JobExecutionStatus = (typeof JobExecutionStatus)[keyof typeof JobExecutionStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ObservationType = $Enums.ObservationType

export const ObservationType: typeof $Enums.ObservationType

export type ObservationLevel = $Enums.ObservationLevel

export const ObservationLevel: typeof $Enums.ObservationLevel

export type ScoreSource = $Enums.ScoreSource

export const ScoreSource: typeof $Enums.ScoreSource

export type ScoreDataType = $Enums.ScoreDataType

export const ScoreDataType: typeof $Enums.ScoreDataType

export type AnnotationQueueObjectType = $Enums.AnnotationQueueObjectType

export const AnnotationQueueObjectType: typeof $Enums.AnnotationQueueObjectType

export type AnnotationQueueStatus = $Enums.AnnotationQueueStatus

export const AnnotationQueueStatus: typeof $Enums.AnnotationQueueStatus

export type DatasetStatus = $Enums.DatasetStatus

export const DatasetStatus: typeof $Enums.DatasetStatus

export type CommentObjectType = $Enums.CommentObjectType

export const CommentObjectType: typeof $Enums.CommentObjectType

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

export type JobConfigState = $Enums.JobConfigState

export const JobConfigState: typeof $Enums.JobConfigState

export type JobExecutionStatus = $Enums.JobExecutionStatus

export const JobExecutionStatus: typeof $Enums.JobExecutionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  /**
   * Gives access to the client metrics in json or prometheus format.
   * 
   * @example
   * ```
   * const metrics = await prisma.$metrics.json()
   * // or
   * const metrics = await prisma.$metrics.prometheus()
   * ```
   */
  readonly $metrics: runtime.MetricsClient
  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.backgroundMigration`: Exposes CRUD operations for the **BackgroundMigration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackgroundMigrations
    * const backgroundMigrations = await prisma.backgroundMigration.findMany()
    * ```
    */
  get backgroundMigration(): Prisma.BackgroundMigrationDelegate<ExtArgs>;

  /**
   * `prisma.llmApiKeys`: Exposes CRUD operations for the **LlmApiKeys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LlmApiKeys
    * const llmApiKeys = await prisma.llmApiKeys.findMany()
    * ```
    */
  get llmApiKeys(): Prisma.LlmApiKeysDelegate<ExtArgs>;

  /**
   * `prisma.organizationMembership`: Exposes CRUD operations for the **OrganizationMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMemberships
    * const organizationMemberships = await prisma.organizationMembership.findMany()
    * ```
    */
  get organizationMembership(): Prisma.OrganizationMembershipDelegate<ExtArgs>;

  /**
   * `prisma.projectMembership`: Exposes CRUD operations for the **ProjectMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMemberships
    * const projectMemberships = await prisma.projectMembership.findMany()
    * ```
    */
  get projectMembership(): Prisma.ProjectMembershipDelegate<ExtArgs>;

  /**
   * `prisma.membershipInvitation`: Exposes CRUD operations for the **MembershipInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipInvitations
    * const membershipInvitations = await prisma.membershipInvitation.findMany()
    * ```
    */
  get membershipInvitation(): Prisma.MembershipInvitationDelegate<ExtArgs>;

  /**
   * `prisma.traceSession`: Exposes CRUD operations for the **TraceSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraceSessions
    * const traceSessions = await prisma.traceSession.findMany()
    * ```
    */
  get traceSession(): Prisma.TraceSessionDelegate<ExtArgs>;

  /**
   * `prisma.trace`: Exposes CRUD operations for the **Trace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Traces
    * const traces = await prisma.trace.findMany()
    * ```
    */
  get trace(): Prisma.TraceDelegate<ExtArgs>;

  /**
   * `prisma.observation`: Exposes CRUD operations for the **Observation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Observations
    * const observations = await prisma.observation.findMany()
    * ```
    */
  get observation(): Prisma.ObservationDelegate<ExtArgs>;

  /**
   * `prisma.score`: Exposes CRUD operations for the **Score** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scores
    * const scores = await prisma.score.findMany()
    * ```
    */
  get score(): Prisma.ScoreDelegate<ExtArgs>;

  /**
   * `prisma.scoreConfig`: Exposes CRUD operations for the **ScoreConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScoreConfigs
    * const scoreConfigs = await prisma.scoreConfig.findMany()
    * ```
    */
  get scoreConfig(): Prisma.ScoreConfigDelegate<ExtArgs>;

  /**
   * `prisma.annotationQueue`: Exposes CRUD operations for the **AnnotationQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnnotationQueues
    * const annotationQueues = await prisma.annotationQueue.findMany()
    * ```
    */
  get annotationQueue(): Prisma.AnnotationQueueDelegate<ExtArgs>;

  /**
   * `prisma.annotationQueueItem`: Exposes CRUD operations for the **AnnotationQueueItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnnotationQueueItems
    * const annotationQueueItems = await prisma.annotationQueueItem.findMany()
    * ```
    */
  get annotationQueueItem(): Prisma.AnnotationQueueItemDelegate<ExtArgs>;

  /**
   * `prisma.cronJobs`: Exposes CRUD operations for the **CronJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CronJobs
    * const cronJobs = await prisma.cronJobs.findMany()
    * ```
    */
  get cronJobs(): Prisma.CronJobsDelegate<ExtArgs>;

  /**
   * `prisma.dataset`: Exposes CRUD operations for the **Dataset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datasets
    * const datasets = await prisma.dataset.findMany()
    * ```
    */
  get dataset(): Prisma.DatasetDelegate<ExtArgs>;

  /**
   * `prisma.datasetItem`: Exposes CRUD operations for the **DatasetItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatasetItems
    * const datasetItems = await prisma.datasetItem.findMany()
    * ```
    */
  get datasetItem(): Prisma.DatasetItemDelegate<ExtArgs>;

  /**
   * `prisma.datasetRuns`: Exposes CRUD operations for the **DatasetRuns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatasetRuns
    * const datasetRuns = await prisma.datasetRuns.findMany()
    * ```
    */
  get datasetRuns(): Prisma.DatasetRunsDelegate<ExtArgs>;

  /**
   * `prisma.datasetRunItems`: Exposes CRUD operations for the **DatasetRunItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatasetRunItems
    * const datasetRunItems = await prisma.datasetRunItems.findMany()
    * ```
    */
  get datasetRunItems(): Prisma.DatasetRunItemsDelegate<ExtArgs>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.prompt`: Exposes CRUD operations for the **Prompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prompts
    * const prompts = await prisma.prompt.findMany()
    * ```
    */
  get prompt(): Prisma.PromptDelegate<ExtArgs>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.evalTemplate`: Exposes CRUD operations for the **EvalTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvalTemplates
    * const evalTemplates = await prisma.evalTemplate.findMany()
    * ```
    */
  get evalTemplate(): Prisma.EvalTemplateDelegate<ExtArgs>;

  /**
   * `prisma.jobConfiguration`: Exposes CRUD operations for the **JobConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobConfigurations
    * const jobConfigurations = await prisma.jobConfiguration.findMany()
    * ```
    */
  get jobConfiguration(): Prisma.JobConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.jobExecution`: Exposes CRUD operations for the **JobExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobExecutions
    * const jobExecutions = await prisma.jobExecution.findMany()
    * ```
    */
  get jobExecution(): Prisma.JobExecutionDelegate<ExtArgs>;

  /**
   * `prisma.ssoConfig`: Exposes CRUD operations for the **SsoConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SsoConfigs
    * const ssoConfigs = await prisma.ssoConfig.findMany()
    * ```
    */
  get ssoConfig(): Prisma.SsoConfigDelegate<ExtArgs>;

  /**
   * `prisma.posthogIntegration`: Exposes CRUD operations for the **PosthogIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosthogIntegrations
    * const posthogIntegrations = await prisma.posthogIntegration.findMany()
    * ```
    */
  get posthogIntegration(): Prisma.PosthogIntegrationDelegate<ExtArgs>;

  /**
   * `prisma.batchExport`: Exposes CRUD operations for the **BatchExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchExports
    * const batchExports = await prisma.batchExport.findMany()
    * ```
    */
  get batchExport(): Prisma.BatchExportDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.traceMedia`: Exposes CRUD operations for the **TraceMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraceMedias
    * const traceMedias = await prisma.traceMedia.findMany()
    * ```
    */
  get traceMedia(): Prisma.TraceMediaDelegate<ExtArgs>;

  /**
   * `prisma.observationMedia`: Exposes CRUD operations for the **ObservationMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObservationMedias
    * const observationMedias = await prisma.observationMedia.findMany()
    * ```
    */
  get observationMedia(): Prisma.ObservationMediaDelegate<ExtArgs>;

  /**
   * `prisma.traceView`: Exposes CRUD operations for the **TraceView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraceViews
    * const traceViews = await prisma.traceView.findMany()
    * ```
    */
  get traceView(): Prisma.TraceViewDelegate<ExtArgs>;

  /**
   * `prisma.observationView`: Exposes CRUD operations for the **ObservationView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObservationViews
    * const observationViews = await prisma.observationView.findMany()
    * ```
    */
  get observationView(): Prisma.ObservationViewDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Organization: 'Organization',
    Project: 'Project',
    ApiKey: 'ApiKey',
    BackgroundMigration: 'BackgroundMigration',
    LlmApiKeys: 'LlmApiKeys',
    OrganizationMembership: 'OrganizationMembership',
    ProjectMembership: 'ProjectMembership',
    MembershipInvitation: 'MembershipInvitation',
    TraceSession: 'TraceSession',
    Trace: 'Trace',
    Observation: 'Observation',
    Score: 'Score',
    ScoreConfig: 'ScoreConfig',
    AnnotationQueue: 'AnnotationQueue',
    AnnotationQueueItem: 'AnnotationQueueItem',
    CronJobs: 'CronJobs',
    Dataset: 'Dataset',
    DatasetItem: 'DatasetItem',
    DatasetRuns: 'DatasetRuns',
    DatasetRunItems: 'DatasetRunItems',
    Events: 'Events',
    Comment: 'Comment',
    Prompt: 'Prompt',
    Model: 'Model',
    Price: 'Price',
    AuditLog: 'AuditLog',
    EvalTemplate: 'EvalTemplate',
    JobConfiguration: 'JobConfiguration',
    JobExecution: 'JobExecution',
    SsoConfig: 'SsoConfig',
    PosthogIntegration: 'PosthogIntegration',
    BatchExport: 'BatchExport',
    Media: 'Media',
    TraceMedia: 'TraceMedia',
    ObservationMedia: 'ObservationMedia',
    TraceView: 'TraceView',
    ObservationView: 'ObservationView'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "account" | "session" | "user" | "verificationToken" | "organization" | "project" | "apiKey" | "backgroundMigration" | "llmApiKeys" | "organizationMembership" | "projectMembership" | "membershipInvitation" | "traceSession" | "trace" | "observation" | "score" | "scoreConfig" | "annotationQueue" | "annotationQueueItem" | "cronJobs" | "dataset" | "datasetItem" | "datasetRuns" | "datasetRunItems" | "events" | "comment" | "prompt" | "model" | "price" | "auditLog" | "evalTemplate" | "jobConfiguration" | "jobExecution" | "ssoConfig" | "posthogIntegration" | "batchExport" | "media" | "traceMedia" | "observationMedia" | "traceView" | "observationView"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      BackgroundMigration: {
        payload: Prisma.$BackgroundMigrationPayload<ExtArgs>
        fields: Prisma.BackgroundMigrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackgroundMigrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackgroundMigrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>
          }
          findFirst: {
            args: Prisma.BackgroundMigrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackgroundMigrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>
          }
          findMany: {
            args: Prisma.BackgroundMigrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>[]
          }
          create: {
            args: Prisma.BackgroundMigrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>
          }
          createMany: {
            args: Prisma.BackgroundMigrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackgroundMigrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>[]
          }
          delete: {
            args: Prisma.BackgroundMigrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>
          }
          update: {
            args: Prisma.BackgroundMigrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>
          }
          deleteMany: {
            args: Prisma.BackgroundMigrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackgroundMigrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BackgroundMigrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundMigrationPayload>
          }
          aggregate: {
            args: Prisma.BackgroundMigrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackgroundMigration>
          }
          groupBy: {
            args: Prisma.BackgroundMigrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackgroundMigrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackgroundMigrationCountArgs<ExtArgs>
            result: $Utils.Optional<BackgroundMigrationCountAggregateOutputType> | number
          }
        }
      }
      LlmApiKeys: {
        payload: Prisma.$LlmApiKeysPayload<ExtArgs>
        fields: Prisma.LlmApiKeysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LlmApiKeysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LlmApiKeysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>
          }
          findFirst: {
            args: Prisma.LlmApiKeysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LlmApiKeysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>
          }
          findMany: {
            args: Prisma.LlmApiKeysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>[]
          }
          create: {
            args: Prisma.LlmApiKeysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>
          }
          createMany: {
            args: Prisma.LlmApiKeysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LlmApiKeysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>[]
          }
          delete: {
            args: Prisma.LlmApiKeysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>
          }
          update: {
            args: Prisma.LlmApiKeysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>
          }
          deleteMany: {
            args: Prisma.LlmApiKeysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LlmApiKeysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LlmApiKeysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmApiKeysPayload>
          }
          aggregate: {
            args: Prisma.LlmApiKeysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLlmApiKeys>
          }
          groupBy: {
            args: Prisma.LlmApiKeysGroupByArgs<ExtArgs>
            result: $Utils.Optional<LlmApiKeysGroupByOutputType>[]
          }
          count: {
            args: Prisma.LlmApiKeysCountArgs<ExtArgs>
            result: $Utils.Optional<LlmApiKeysCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMembership: {
        payload: Prisma.$OrganizationMembershipPayload<ExtArgs>
        fields: Prisma.OrganizationMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          findMany: {
            args: Prisma.OrganizationMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>[]
          }
          create: {
            args: Prisma.OrganizationMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          createMany: {
            args: Prisma.OrganizationMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          update: {
            args: Prisma.OrganizationMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMembership>
          }
          groupBy: {
            args: Prisma.OrganizationMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMembershipCountAggregateOutputType> | number
          }
        }
      }
      ProjectMembership: {
        payload: Prisma.$ProjectMembershipPayload<ExtArgs>
        fields: Prisma.ProjectMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>
          }
          findFirst: {
            args: Prisma.ProjectMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>
          }
          findMany: {
            args: Prisma.ProjectMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>[]
          }
          create: {
            args: Prisma.ProjectMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>
          }
          createMany: {
            args: Prisma.ProjectMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>[]
          }
          delete: {
            args: Prisma.ProjectMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>
          }
          update: {
            args: Prisma.ProjectMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMembershipPayload>
          }
          aggregate: {
            args: Prisma.ProjectMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMembership>
          }
          groupBy: {
            args: Prisma.ProjectMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMembershipCountAggregateOutputType> | number
          }
        }
      }
      MembershipInvitation: {
        payload: Prisma.$MembershipInvitationPayload<ExtArgs>
        fields: Prisma.MembershipInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>
          }
          findFirst: {
            args: Prisma.MembershipInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>
          }
          findMany: {
            args: Prisma.MembershipInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>[]
          }
          create: {
            args: Prisma.MembershipInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>
          }
          createMany: {
            args: Prisma.MembershipInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>[]
          }
          delete: {
            args: Prisma.MembershipInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>
          }
          update: {
            args: Prisma.MembershipInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>
          }
          deleteMany: {
            args: Prisma.MembershipInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MembershipInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipInvitationPayload>
          }
          aggregate: {
            args: Prisma.MembershipInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipInvitation>
          }
          groupBy: {
            args: Prisma.MembershipInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipInvitationCountAggregateOutputType> | number
          }
        }
      }
      TraceSession: {
        payload: Prisma.$TraceSessionPayload<ExtArgs>
        fields: Prisma.TraceSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraceSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraceSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>
          }
          findFirst: {
            args: Prisma.TraceSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraceSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>
          }
          findMany: {
            args: Prisma.TraceSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>[]
          }
          create: {
            args: Prisma.TraceSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>
          }
          createMany: {
            args: Prisma.TraceSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraceSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>[]
          }
          delete: {
            args: Prisma.TraceSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>
          }
          update: {
            args: Prisma.TraceSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>
          }
          deleteMany: {
            args: Prisma.TraceSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraceSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraceSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceSessionPayload>
          }
          aggregate: {
            args: Prisma.TraceSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraceSession>
          }
          groupBy: {
            args: Prisma.TraceSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraceSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraceSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TraceSessionCountAggregateOutputType> | number
          }
        }
      }
      Trace: {
        payload: Prisma.$TracePayload<ExtArgs>
        fields: Prisma.TraceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>
          }
          findFirst: {
            args: Prisma.TraceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>
          }
          findMany: {
            args: Prisma.TraceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>[]
          }
          create: {
            args: Prisma.TraceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>
          }
          createMany: {
            args: Prisma.TraceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>[]
          }
          delete: {
            args: Prisma.TraceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>
          }
          update: {
            args: Prisma.TraceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>
          }
          deleteMany: {
            args: Prisma.TraceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TracePayload>
          }
          aggregate: {
            args: Prisma.TraceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrace>
          }
          groupBy: {
            args: Prisma.TraceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraceCountArgs<ExtArgs>
            result: $Utils.Optional<TraceCountAggregateOutputType> | number
          }
        }
      }
      Observation: {
        payload: Prisma.$ObservationPayload<ExtArgs>
        fields: Prisma.ObservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findFirst: {
            args: Prisma.ObservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findMany: {
            args: Prisma.ObservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          create: {
            args: Prisma.ObservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          createMany: {
            args: Prisma.ObservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          delete: {
            args: Prisma.ObservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          update: {
            args: Prisma.ObservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          deleteMany: {
            args: Prisma.ObservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          aggregate: {
            args: Prisma.ObservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservation>
          }
          groupBy: {
            args: Prisma.ObservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationCountAggregateOutputType> | number
          }
        }
      }
      Score: {
        payload: Prisma.$ScorePayload<ExtArgs>
        fields: Prisma.ScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          findFirst: {
            args: Prisma.ScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          findMany: {
            args: Prisma.ScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[]
          }
          create: {
            args: Prisma.ScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          createMany: {
            args: Prisma.ScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[]
          }
          delete: {
            args: Prisma.ScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          update: {
            args: Prisma.ScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          deleteMany: {
            args: Prisma.ScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          aggregate: {
            args: Prisma.ScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScore>
          }
          groupBy: {
            args: Prisma.ScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoreCountArgs<ExtArgs>
            result: $Utils.Optional<ScoreCountAggregateOutputType> | number
          }
        }
      }
      ScoreConfig: {
        payload: Prisma.$ScoreConfigPayload<ExtArgs>
        fields: Prisma.ScoreConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoreConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoreConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>
          }
          findFirst: {
            args: Prisma.ScoreConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoreConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>
          }
          findMany: {
            args: Prisma.ScoreConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>[]
          }
          create: {
            args: Prisma.ScoreConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>
          }
          createMany: {
            args: Prisma.ScoreConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScoreConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>[]
          }
          delete: {
            args: Prisma.ScoreConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>
          }
          update: {
            args: Prisma.ScoreConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>
          }
          deleteMany: {
            args: Prisma.ScoreConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoreConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScoreConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoreConfigPayload>
          }
          aggregate: {
            args: Prisma.ScoreConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScoreConfig>
          }
          groupBy: {
            args: Prisma.ScoreConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoreConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoreConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ScoreConfigCountAggregateOutputType> | number
          }
        }
      }
      AnnotationQueue: {
        payload: Prisma.$AnnotationQueuePayload<ExtArgs>
        fields: Prisma.AnnotationQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnotationQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnotationQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>
          }
          findFirst: {
            args: Prisma.AnnotationQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnotationQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>
          }
          findMany: {
            args: Prisma.AnnotationQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>[]
          }
          create: {
            args: Prisma.AnnotationQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>
          }
          createMany: {
            args: Prisma.AnnotationQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnotationQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>[]
          }
          delete: {
            args: Prisma.AnnotationQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>
          }
          update: {
            args: Prisma.AnnotationQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>
          }
          deleteMany: {
            args: Prisma.AnnotationQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnotationQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnotationQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueuePayload>
          }
          aggregate: {
            args: Prisma.AnnotationQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnotationQueue>
          }
          groupBy: {
            args: Prisma.AnnotationQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnotationQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnotationQueueCountArgs<ExtArgs>
            result: $Utils.Optional<AnnotationQueueCountAggregateOutputType> | number
          }
        }
      }
      AnnotationQueueItem: {
        payload: Prisma.$AnnotationQueueItemPayload<ExtArgs>
        fields: Prisma.AnnotationQueueItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnotationQueueItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnotationQueueItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>
          }
          findFirst: {
            args: Prisma.AnnotationQueueItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnotationQueueItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>
          }
          findMany: {
            args: Prisma.AnnotationQueueItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>[]
          }
          create: {
            args: Prisma.AnnotationQueueItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>
          }
          createMany: {
            args: Prisma.AnnotationQueueItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnotationQueueItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>[]
          }
          delete: {
            args: Prisma.AnnotationQueueItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>
          }
          update: {
            args: Prisma.AnnotationQueueItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>
          }
          deleteMany: {
            args: Prisma.AnnotationQueueItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnotationQueueItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnotationQueueItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationQueueItemPayload>
          }
          aggregate: {
            args: Prisma.AnnotationQueueItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnotationQueueItem>
          }
          groupBy: {
            args: Prisma.AnnotationQueueItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnotationQueueItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnotationQueueItemCountArgs<ExtArgs>
            result: $Utils.Optional<AnnotationQueueItemCountAggregateOutputType> | number
          }
        }
      }
      CronJobs: {
        payload: Prisma.$CronJobsPayload<ExtArgs>
        fields: Prisma.CronJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CronJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CronJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>
          }
          findFirst: {
            args: Prisma.CronJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CronJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>
          }
          findMany: {
            args: Prisma.CronJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>[]
          }
          create: {
            args: Prisma.CronJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>
          }
          createMany: {
            args: Prisma.CronJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CronJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>[]
          }
          delete: {
            args: Prisma.CronJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>
          }
          update: {
            args: Prisma.CronJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>
          }
          deleteMany: {
            args: Prisma.CronJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CronJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CronJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobsPayload>
          }
          aggregate: {
            args: Prisma.CronJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCronJobs>
          }
          groupBy: {
            args: Prisma.CronJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CronJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CronJobsCountArgs<ExtArgs>
            result: $Utils.Optional<CronJobsCountAggregateOutputType> | number
          }
        }
      }
      Dataset: {
        payload: Prisma.$DatasetPayload<ExtArgs>
        fields: Prisma.DatasetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          findFirst: {
            args: Prisma.DatasetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          findMany: {
            args: Prisma.DatasetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          create: {
            args: Prisma.DatasetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          createMany: {
            args: Prisma.DatasetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          delete: {
            args: Prisma.DatasetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          update: {
            args: Prisma.DatasetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          deleteMany: {
            args: Prisma.DatasetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          aggregate: {
            args: Prisma.DatasetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataset>
          }
          groupBy: {
            args: Prisma.DatasetGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetCountAggregateOutputType> | number
          }
        }
      }
      DatasetItem: {
        payload: Prisma.$DatasetItemPayload<ExtArgs>
        fields: Prisma.DatasetItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>
          }
          findFirst: {
            args: Prisma.DatasetItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>
          }
          findMany: {
            args: Prisma.DatasetItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>[]
          }
          create: {
            args: Prisma.DatasetItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>
          }
          createMany: {
            args: Prisma.DatasetItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>[]
          }
          delete: {
            args: Prisma.DatasetItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>
          }
          update: {
            args: Prisma.DatasetItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>
          }
          deleteMany: {
            args: Prisma.DatasetItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetItemPayload>
          }
          aggregate: {
            args: Prisma.DatasetItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatasetItem>
          }
          groupBy: {
            args: Prisma.DatasetItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetItemCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetItemCountAggregateOutputType> | number
          }
        }
      }
      DatasetRuns: {
        payload: Prisma.$DatasetRunsPayload<ExtArgs>
        fields: Prisma.DatasetRunsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetRunsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetRunsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>
          }
          findFirst: {
            args: Prisma.DatasetRunsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetRunsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>
          }
          findMany: {
            args: Prisma.DatasetRunsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>[]
          }
          create: {
            args: Prisma.DatasetRunsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>
          }
          createMany: {
            args: Prisma.DatasetRunsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetRunsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>[]
          }
          delete: {
            args: Prisma.DatasetRunsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>
          }
          update: {
            args: Prisma.DatasetRunsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>
          }
          deleteMany: {
            args: Prisma.DatasetRunsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetRunsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetRunsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunsPayload>
          }
          aggregate: {
            args: Prisma.DatasetRunsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatasetRuns>
          }
          groupBy: {
            args: Prisma.DatasetRunsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetRunsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetRunsCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetRunsCountAggregateOutputType> | number
          }
        }
      }
      DatasetRunItems: {
        payload: Prisma.$DatasetRunItemsPayload<ExtArgs>
        fields: Prisma.DatasetRunItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetRunItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetRunItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>
          }
          findFirst: {
            args: Prisma.DatasetRunItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetRunItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>
          }
          findMany: {
            args: Prisma.DatasetRunItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>[]
          }
          create: {
            args: Prisma.DatasetRunItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>
          }
          createMany: {
            args: Prisma.DatasetRunItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetRunItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>[]
          }
          delete: {
            args: Prisma.DatasetRunItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>
          }
          update: {
            args: Prisma.DatasetRunItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>
          }
          deleteMany: {
            args: Prisma.DatasetRunItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetRunItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetRunItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetRunItemsPayload>
          }
          aggregate: {
            args: Prisma.DatasetRunItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatasetRunItems>
          }
          groupBy: {
            args: Prisma.DatasetRunItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetRunItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetRunItemsCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetRunItemsCountAggregateOutputType> | number
          }
        }
      }
      Events: {
        payload: Prisma.$EventsPayload<ExtArgs>
        fields: Prisma.EventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findFirst: {
            args: Prisma.EventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findMany: {
            args: Prisma.EventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          create: {
            args: Prisma.EventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          createMany: {
            args: Prisma.EventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          delete: {
            args: Prisma.EventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          update: {
            args: Prisma.EventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          deleteMany: {
            args: Prisma.EventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Prompt: {
        payload: Prisma.$PromptPayload<ExtArgs>
        fields: Prisma.PromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findFirst: {
            args: Prisma.PromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findMany: {
            args: Prisma.PromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          create: {
            args: Prisma.PromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          createMany: {
            args: Prisma.PromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          delete: {
            args: Prisma.PromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          update: {
            args: Prisma.PromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          deleteMany: {
            args: Prisma.PromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          aggregate: {
            args: Prisma.PromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrompt>
          }
          groupBy: {
            args: Prisma.PromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptCountArgs<ExtArgs>
            result: $Utils.Optional<PromptCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      Price: {
        payload: Prisma.$PricePayload<ExtArgs>
        fields: Prisma.PriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          findFirst: {
            args: Prisma.PriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          findMany: {
            args: Prisma.PriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>[]
          }
          create: {
            args: Prisma.PriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          createMany: {
            args: Prisma.PriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>[]
          }
          delete: {
            args: Prisma.PriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          update: {
            args: Prisma.PriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          deleteMany: {
            args: Prisma.PriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          aggregate: {
            args: Prisma.PriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrice>
          }
          groupBy: {
            args: Prisma.PriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceCountArgs<ExtArgs>
            result: $Utils.Optional<PriceCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      EvalTemplate: {
        payload: Prisma.$EvalTemplatePayload<ExtArgs>
        fields: Prisma.EvalTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvalTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvalTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>
          }
          findFirst: {
            args: Prisma.EvalTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvalTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>
          }
          findMany: {
            args: Prisma.EvalTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>[]
          }
          create: {
            args: Prisma.EvalTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>
          }
          createMany: {
            args: Prisma.EvalTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvalTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>[]
          }
          delete: {
            args: Prisma.EvalTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>
          }
          update: {
            args: Prisma.EvalTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EvalTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvalTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvalTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvalTemplatePayload>
          }
          aggregate: {
            args: Prisma.EvalTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvalTemplate>
          }
          groupBy: {
            args: Prisma.EvalTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvalTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvalTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EvalTemplateCountAggregateOutputType> | number
          }
        }
      }
      JobConfiguration: {
        payload: Prisma.$JobConfigurationPayload<ExtArgs>
        fields: Prisma.JobConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>
          }
          findFirst: {
            args: Prisma.JobConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>
          }
          findMany: {
            args: Prisma.JobConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>[]
          }
          create: {
            args: Prisma.JobConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>
          }
          createMany: {
            args: Prisma.JobConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>[]
          }
          delete: {
            args: Prisma.JobConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>
          }
          update: {
            args: Prisma.JobConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.JobConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobConfigurationPayload>
          }
          aggregate: {
            args: Prisma.JobConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobConfiguration>
          }
          groupBy: {
            args: Prisma.JobConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<JobConfigurationCountAggregateOutputType> | number
          }
        }
      }
      JobExecution: {
        payload: Prisma.$JobExecutionPayload<ExtArgs>
        fields: Prisma.JobExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>
          }
          findFirst: {
            args: Prisma.JobExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>
          }
          findMany: {
            args: Prisma.JobExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>[]
          }
          create: {
            args: Prisma.JobExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>
          }
          createMany: {
            args: Prisma.JobExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>[]
          }
          delete: {
            args: Prisma.JobExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>
          }
          update: {
            args: Prisma.JobExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>
          }
          deleteMany: {
            args: Prisma.JobExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobExecutionPayload>
          }
          aggregate: {
            args: Prisma.JobExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobExecution>
          }
          groupBy: {
            args: Prisma.JobExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<JobExecutionCountAggregateOutputType> | number
          }
        }
      }
      SsoConfig: {
        payload: Prisma.$SsoConfigPayload<ExtArgs>
        fields: Prisma.SsoConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SsoConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SsoConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>
          }
          findFirst: {
            args: Prisma.SsoConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SsoConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>
          }
          findMany: {
            args: Prisma.SsoConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>[]
          }
          create: {
            args: Prisma.SsoConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>
          }
          createMany: {
            args: Prisma.SsoConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SsoConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>[]
          }
          delete: {
            args: Prisma.SsoConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>
          }
          update: {
            args: Prisma.SsoConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>
          }
          deleteMany: {
            args: Prisma.SsoConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SsoConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SsoConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigPayload>
          }
          aggregate: {
            args: Prisma.SsoConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSsoConfig>
          }
          groupBy: {
            args: Prisma.SsoConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SsoConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SsoConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SsoConfigCountAggregateOutputType> | number
          }
        }
      }
      PosthogIntegration: {
        payload: Prisma.$PosthogIntegrationPayload<ExtArgs>
        fields: Prisma.PosthogIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosthogIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosthogIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>
          }
          findFirst: {
            args: Prisma.PosthogIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosthogIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>
          }
          findMany: {
            args: Prisma.PosthogIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>[]
          }
          create: {
            args: Prisma.PosthogIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>
          }
          createMany: {
            args: Prisma.PosthogIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosthogIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>[]
          }
          delete: {
            args: Prisma.PosthogIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>
          }
          update: {
            args: Prisma.PosthogIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.PosthogIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosthogIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PosthogIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosthogIntegrationPayload>
          }
          aggregate: {
            args: Prisma.PosthogIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosthogIntegration>
          }
          groupBy: {
            args: Prisma.PosthogIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosthogIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosthogIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<PosthogIntegrationCountAggregateOutputType> | number
          }
        }
      }
      BatchExport: {
        payload: Prisma.$BatchExportPayload<ExtArgs>
        fields: Prisma.BatchExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>
          }
          findFirst: {
            args: Prisma.BatchExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>
          }
          findMany: {
            args: Prisma.BatchExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>[]
          }
          create: {
            args: Prisma.BatchExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>
          }
          createMany: {
            args: Prisma.BatchExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>[]
          }
          delete: {
            args: Prisma.BatchExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>
          }
          update: {
            args: Prisma.BatchExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>
          }
          deleteMany: {
            args: Prisma.BatchExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatchExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchExportPayload>
          }
          aggregate: {
            args: Prisma.BatchExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchExport>
          }
          groupBy: {
            args: Prisma.BatchExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchExportCountArgs<ExtArgs>
            result: $Utils.Optional<BatchExportCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      TraceMedia: {
        payload: Prisma.$TraceMediaPayload<ExtArgs>
        fields: Prisma.TraceMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraceMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraceMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>
          }
          findFirst: {
            args: Prisma.TraceMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraceMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>
          }
          findMany: {
            args: Prisma.TraceMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>[]
          }
          create: {
            args: Prisma.TraceMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>
          }
          createMany: {
            args: Prisma.TraceMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraceMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>[]
          }
          delete: {
            args: Prisma.TraceMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>
          }
          update: {
            args: Prisma.TraceMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>
          }
          deleteMany: {
            args: Prisma.TraceMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraceMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraceMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceMediaPayload>
          }
          aggregate: {
            args: Prisma.TraceMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraceMedia>
          }
          groupBy: {
            args: Prisma.TraceMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraceMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraceMediaCountArgs<ExtArgs>
            result: $Utils.Optional<TraceMediaCountAggregateOutputType> | number
          }
        }
      }
      ObservationMedia: {
        payload: Prisma.$ObservationMediaPayload<ExtArgs>
        fields: Prisma.ObservationMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>
          }
          findFirst: {
            args: Prisma.ObservationMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>
          }
          findMany: {
            args: Prisma.ObservationMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>[]
          }
          create: {
            args: Prisma.ObservationMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>
          }
          createMany: {
            args: Prisma.ObservationMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObservationMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>[]
          }
          delete: {
            args: Prisma.ObservationMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>
          }
          update: {
            args: Prisma.ObservationMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>
          }
          deleteMany: {
            args: Prisma.ObservationMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObservationMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationMediaPayload>
          }
          aggregate: {
            args: Prisma.ObservationMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservationMedia>
          }
          groupBy: {
            args: Prisma.ObservationMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationMediaCountAggregateOutputType> | number
          }
        }
      }
      TraceView: {
        payload: Prisma.$TraceViewPayload<ExtArgs>
        fields: Prisma.TraceViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraceViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraceViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>
          }
          findFirst: {
            args: Prisma.TraceViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraceViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>
          }
          findMany: {
            args: Prisma.TraceViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>[]
          }
          create: {
            args: Prisma.TraceViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>
          }
          createMany: {
            args: Prisma.TraceViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraceViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>[]
          }
          delete: {
            args: Prisma.TraceViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>
          }
          update: {
            args: Prisma.TraceViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>
          }
          deleteMany: {
            args: Prisma.TraceViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraceViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraceViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceViewPayload>
          }
          aggregate: {
            args: Prisma.TraceViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraceView>
          }
          groupBy: {
            args: Prisma.TraceViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraceViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraceViewCountArgs<ExtArgs>
            result: $Utils.Optional<TraceViewCountAggregateOutputType> | number
          }
        }
      }
      ObservationView: {
        payload: Prisma.$ObservationViewPayload<ExtArgs>
        fields: Prisma.ObservationViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>
          }
          findFirst: {
            args: Prisma.ObservationViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>
          }
          findMany: {
            args: Prisma.ObservationViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>[]
          }
          create: {
            args: Prisma.ObservationViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>
          }
          createMany: {
            args: Prisma.ObservationViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObservationViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>[]
          }
          delete: {
            args: Prisma.ObservationViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>
          }
          update: {
            args: Prisma.ObservationViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>
          }
          deleteMany: {
            args: Prisma.ObservationViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObservationViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationViewPayload>
          }
          aggregate: {
            args: Prisma.ObservationViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservationView>
          }
          groupBy: {
            args: Prisma.ObservationViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationViewCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationViewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    organizationMemberships: number
    projectMemberships: number
    invitations: number
    annotatedLockedItem: number
    annotatedCompletedItem: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    organizationMemberships?: boolean | UserCountOutputTypeCountOrganizationMembershipsArgs
    projectMemberships?: boolean | UserCountOutputTypeCountProjectMembershipsArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
    annotatedLockedItem?: boolean | UserCountOutputTypeCountAnnotatedLockedItemArgs
    annotatedCompletedItem?: boolean | UserCountOutputTypeCountAnnotatedCompletedItemArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnotatedLockedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnotatedCompletedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueItemWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    organizationMemberships: number
    projects: number
    MembershipInvitation: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationMemberships?: boolean | OrganizationCountOutputTypeCountOrganizationMembershipsArgs
    projects?: boolean | OrganizationCountOutputTypeCountProjectsArgs
    MembershipInvitation?: boolean | OrganizationCountOutputTypeCountMembershipInvitationArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrganizationMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMembershipWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembershipInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipInvitationWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    projectMembers: number
    traces: number
    observations: number
    apiKeys: number
    dataset: number
    RawEvents: number
    invitations: number
    sessions: number
    Prompt: number
    Model: number
    EvalTemplate: number
    JobConfiguration: number
    JobExecution: number
    LlmApiKeys: number
    PosthogIntegration: number
    Score: number
    scoreConfig: number
    BatchExport: number
    comment: number
    annotationQueue: number
    annotationQueueItem: number
    TraceMedia: number
    Media: number
    ObservationMedia: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectMembers?: boolean | ProjectCountOutputTypeCountProjectMembersArgs
    traces?: boolean | ProjectCountOutputTypeCountTracesArgs
    observations?: boolean | ProjectCountOutputTypeCountObservationsArgs
    apiKeys?: boolean | ProjectCountOutputTypeCountApiKeysArgs
    dataset?: boolean | ProjectCountOutputTypeCountDatasetArgs
    RawEvents?: boolean | ProjectCountOutputTypeCountRawEventsArgs
    invitations?: boolean | ProjectCountOutputTypeCountInvitationsArgs
    sessions?: boolean | ProjectCountOutputTypeCountSessionsArgs
    Prompt?: boolean | ProjectCountOutputTypeCountPromptArgs
    Model?: boolean | ProjectCountOutputTypeCountModelArgs
    EvalTemplate?: boolean | ProjectCountOutputTypeCountEvalTemplateArgs
    JobConfiguration?: boolean | ProjectCountOutputTypeCountJobConfigurationArgs
    JobExecution?: boolean | ProjectCountOutputTypeCountJobExecutionArgs
    LlmApiKeys?: boolean | ProjectCountOutputTypeCountLlmApiKeysArgs
    PosthogIntegration?: boolean | ProjectCountOutputTypeCountPosthogIntegrationArgs
    Score?: boolean | ProjectCountOutputTypeCountScoreArgs
    scoreConfig?: boolean | ProjectCountOutputTypeCountScoreConfigArgs
    BatchExport?: boolean | ProjectCountOutputTypeCountBatchExportArgs
    comment?: boolean | ProjectCountOutputTypeCountCommentArgs
    annotationQueue?: boolean | ProjectCountOutputTypeCountAnnotationQueueArgs
    annotationQueueItem?: boolean | ProjectCountOutputTypeCountAnnotationQueueItemArgs
    TraceMedia?: boolean | ProjectCountOutputTypeCountTraceMediaArgs
    Media?: boolean | ProjectCountOutputTypeCountMediaArgs
    ObservationMedia?: boolean | ProjectCountOutputTypeCountObservationMediaArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMembershipWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountObservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDatasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRawEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipInvitationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceSessionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEvalTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvalTemplateWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountJobConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobConfigurationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountJobExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobExecutionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLlmApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmApiKeysWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPosthogIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosthogIntegrationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountScoreConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreConfigWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBatchExportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchExportWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAnnotationQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAnnotationQueueItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueItemWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTraceMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceMediaWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountObservationMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationMediaWhereInput
  }


  /**
   * Count Type OrganizationMembershipCountOutputType
   */

  export type OrganizationMembershipCountOutputType = {
    ProjectMemberships: number
  }

  export type OrganizationMembershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProjectMemberships?: boolean | OrganizationMembershipCountOutputTypeCountProjectMembershipsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationMembershipCountOutputType without action
   */
  export type OrganizationMembershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembershipCountOutputType
     */
    select?: OrganizationMembershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationMembershipCountOutputType without action
   */
  export type OrganizationMembershipCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMembershipWhereInput
  }


  /**
   * Count Type TraceSessionCountOutputType
   */

  export type TraceSessionCountOutputType = {
    traces: number
  }

  export type TraceSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traces?: boolean | TraceSessionCountOutputTypeCountTracesArgs
  }

  // Custom InputTypes
  /**
   * TraceSessionCountOutputType without action
   */
  export type TraceSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSessionCountOutputType
     */
    select?: TraceSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TraceSessionCountOutputType without action
   */
  export type TraceSessionCountOutputTypeCountTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceWhereInput
  }


  /**
   * Count Type ScoreConfigCountOutputType
   */

  export type ScoreConfigCountOutputType = {
    score: number
  }

  export type ScoreConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    score?: boolean | ScoreConfigCountOutputTypeCountScoreArgs
  }

  // Custom InputTypes
  /**
   * ScoreConfigCountOutputType without action
   */
  export type ScoreConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfigCountOutputType
     */
    select?: ScoreConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScoreConfigCountOutputType without action
   */
  export type ScoreConfigCountOutputTypeCountScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
  }


  /**
   * Count Type AnnotationQueueCountOutputType
   */

  export type AnnotationQueueCountOutputType = {
    annotationQueueItem: number
  }

  export type AnnotationQueueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    annotationQueueItem?: boolean | AnnotationQueueCountOutputTypeCountAnnotationQueueItemArgs
  }

  // Custom InputTypes
  /**
   * AnnotationQueueCountOutputType without action
   */
  export type AnnotationQueueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueCountOutputType
     */
    select?: AnnotationQueueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnnotationQueueCountOutputType without action
   */
  export type AnnotationQueueCountOutputTypeCountAnnotationQueueItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueItemWhereInput
  }


  /**
   * Count Type DatasetCountOutputType
   */

  export type DatasetCountOutputType = {
    datasetItems: number
    datasetRuns: number
  }

  export type DatasetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasetItems?: boolean | DatasetCountOutputTypeCountDatasetItemsArgs
    datasetRuns?: boolean | DatasetCountOutputTypeCountDatasetRunsArgs
  }

  // Custom InputTypes
  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetCountOutputType
     */
    select?: DatasetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountDatasetItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetItemWhereInput
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountDatasetRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetRunsWhereInput
  }


  /**
   * Count Type DatasetItemCountOutputType
   */

  export type DatasetItemCountOutputType = {
    datasetRunItems: number
  }

  export type DatasetItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasetRunItems?: boolean | DatasetItemCountOutputTypeCountDatasetRunItemsArgs
  }

  // Custom InputTypes
  /**
   * DatasetItemCountOutputType without action
   */
  export type DatasetItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItemCountOutputType
     */
    select?: DatasetItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatasetItemCountOutputType without action
   */
  export type DatasetItemCountOutputTypeCountDatasetRunItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetRunItemsWhereInput
  }


  /**
   * Count Type DatasetRunsCountOutputType
   */

  export type DatasetRunsCountOutputType = {
    datasetRunItems: number
  }

  export type DatasetRunsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasetRunItems?: boolean | DatasetRunsCountOutputTypeCountDatasetRunItemsArgs
  }

  // Custom InputTypes
  /**
   * DatasetRunsCountOutputType without action
   */
  export type DatasetRunsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunsCountOutputType
     */
    select?: DatasetRunsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatasetRunsCountOutputType without action
   */
  export type DatasetRunsCountOutputTypeCountDatasetRunItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetRunItemsWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    Price: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Price?: boolean | ModelCountOutputTypeCountPriceArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
  }


  /**
   * Count Type EvalTemplateCountOutputType
   */

  export type EvalTemplateCountOutputType = {
    JobConfiguration: number
  }

  export type EvalTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JobConfiguration?: boolean | EvalTemplateCountOutputTypeCountJobConfigurationArgs
  }

  // Custom InputTypes
  /**
   * EvalTemplateCountOutputType without action
   */
  export type EvalTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplateCountOutputType
     */
    select?: EvalTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvalTemplateCountOutputType without action
   */
  export type EvalTemplateCountOutputTypeCountJobConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobConfigurationWhereInput
  }


  /**
   * Count Type JobConfigurationCountOutputType
   */

  export type JobConfigurationCountOutputType = {
    JobExecution: number
  }

  export type JobConfigurationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JobExecution?: boolean | JobConfigurationCountOutputTypeCountJobExecutionArgs
  }

  // Custom InputTypes
  /**
   * JobConfigurationCountOutputType without action
   */
  export type JobConfigurationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfigurationCountOutputType
     */
    select?: JobConfigurationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobConfigurationCountOutputType without action
   */
  export type JobConfigurationCountOutputTypeCountJobExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobExecutionWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    TraceMedia: number
    ObservationMedia: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TraceMedia?: boolean | MediaCountOutputTypeCountTraceMediaArgs
    ObservationMedia?: boolean | MediaCountOutputTypeCountObservationMediaArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountTraceMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceMediaWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountObservationMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationMediaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
    expires_in: number | null
    ext_expires_in: number | null
    refresh_token_expires_in: number | null
    created_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
    expires_in: number | null
    ext_expires_in: number | null
    refresh_token_expires_in: number | null
    created_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    expires_in: number | null
    ext_expires_in: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
    created_at: number | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    expires_in: number | null
    ext_expires_in: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
    created_at: number | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    expires_in: number
    ext_expires_in: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    refresh_token_expires_in: number
    created_at: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
    expires_in?: true
    ext_expires_in?: true
    refresh_token_expires_in?: true
    created_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
    expires_in?: true
    ext_expires_in?: true
    refresh_token_expires_in?: true
    created_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    expires_in?: true
    ext_expires_in?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
    created_at?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    expires_in?: true
    ext_expires_in?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
    created_at?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    expires_in?: true
    ext_expires_in?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
    created_at?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    expires_in: number | null
    ext_expires_in: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
    created_at: number | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    expires_in?: boolean
    ext_expires_in?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    expires_in?: boolean
    ext_expires_in?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    expires_in?: boolean
    ext_expires_in?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    created_at?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      expires_in: number | null
      ext_expires_in: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      refresh_token_expires_in: number | null
      created_at: number | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly expires_in: FieldRef<"Account", 'Int'>
    readonly ext_expires_in: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly refresh_token_expires_in: FieldRef<"Account", 'Int'>
    readonly created_at: FieldRef<"Account", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    admin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    admin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    admin: number
    createdAt: number
    updatedAt: number
    featureFlags: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    admin?: true
    createdAt?: true
    updatedAt?: true
    featureFlags?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    admin: boolean
    createdAt: Date
    updatedAt: Date
    featureFlags: string[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureFlags?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    organizationMemberships?: boolean | User$organizationMembershipsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    annotatedLockedItem?: boolean | User$annotatedLockedItemArgs<ExtArgs>
    annotatedCompletedItem?: boolean | User$annotatedCompletedItemArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureFlags?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureFlags?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    organizationMemberships?: boolean | User$organizationMembershipsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    annotatedLockedItem?: boolean | User$annotatedLockedItemArgs<ExtArgs>
    annotatedCompletedItem?: boolean | User$annotatedCompletedItemArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      organizationMemberships: Prisma.$OrganizationMembershipPayload<ExtArgs>[]
      projectMemberships: Prisma.$ProjectMembershipPayload<ExtArgs>[]
      invitations: Prisma.$MembershipInvitationPayload<ExtArgs>[]
      annotatedLockedItem: Prisma.$AnnotationQueueItemPayload<ExtArgs>[]
      annotatedCompletedItem: Prisma.$AnnotationQueueItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      password: string | null
      image: string | null
      admin: boolean
      createdAt: Date
      updatedAt: Date
      featureFlags: string[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    organizationMemberships<T extends User$organizationMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    projectMemberships<T extends User$projectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    annotatedLockedItem<T extends User$annotatedLockedItemArgs<ExtArgs> = {}>(args?: Subset<T, User$annotatedLockedItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findMany"> | Null>
    annotatedCompletedItem<T extends User$annotatedCompletedItemArgs<ExtArgs> = {}>(args?: Subset<T, User$annotatedCompletedItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly admin: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly featureFlags: FieldRef<"User", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.organizationMemberships
   */
  export type User$organizationMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    where?: OrganizationMembershipWhereInput
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    cursor?: OrganizationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * User.projectMemberships
   */
  export type User$projectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    where?: ProjectMembershipWhereInput
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    cursor?: ProjectMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMembershipScalarFieldEnum | ProjectMembershipScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    where?: MembershipInvitationWhereInput
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    cursor?: MembershipInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipInvitationScalarFieldEnum | MembershipInvitationScalarFieldEnum[]
  }

  /**
   * User.annotatedLockedItem
   */
  export type User$annotatedLockedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    where?: AnnotationQueueItemWhereInput
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    cursor?: AnnotationQueueItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
  }

  /**
   * User.annotatedCompletedItem
   */
  export type User$annotatedCompletedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    where?: AnnotationQueueItemWhereInput
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    cursor?: AnnotationQueueItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    cloudConfig: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    cloudConfig?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    cloudConfig: JsonValue | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cloudConfig?: boolean
    organizationMemberships?: boolean | Organization$organizationMembershipsArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    MembershipInvitation?: boolean | Organization$MembershipInvitationArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cloudConfig?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cloudConfig?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationMemberships?: boolean | Organization$organizationMembershipsArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    MembershipInvitation?: boolean | Organization$MembershipInvitationArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      organizationMemberships: Prisma.$OrganizationMembershipPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      MembershipInvitation: Prisma.$MembershipInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      cloudConfig: Prisma.JsonValue | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizationMemberships<T extends Organization$organizationMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$organizationMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Organization$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    MembershipInvitation<T extends Organization$MembershipInvitationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$MembershipInvitationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly cloudConfig: FieldRef<"Organization", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.organizationMemberships
   */
  export type Organization$organizationMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    where?: OrganizationMembershipWhereInput
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    cursor?: OrganizationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * Organization.projects
   */
  export type Organization$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Organization.MembershipInvitation
   */
  export type Organization$MembershipInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    where?: MembershipInvitationWhereInput
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    cursor?: MembershipInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipInvitationScalarFieldEnum | MembershipInvitationScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    name: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    name: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    orgId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    name: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    name?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    name?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    name?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    orgId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    name: string
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    name?: boolean
    projectMembers?: boolean | Project$projectMembersArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    traces?: boolean | Project$tracesArgs<ExtArgs>
    observations?: boolean | Project$observationsArgs<ExtArgs>
    apiKeys?: boolean | Project$apiKeysArgs<ExtArgs>
    dataset?: boolean | Project$datasetArgs<ExtArgs>
    RawEvents?: boolean | Project$RawEventsArgs<ExtArgs>
    invitations?: boolean | Project$invitationsArgs<ExtArgs>
    sessions?: boolean | Project$sessionsArgs<ExtArgs>
    Prompt?: boolean | Project$PromptArgs<ExtArgs>
    Model?: boolean | Project$ModelArgs<ExtArgs>
    EvalTemplate?: boolean | Project$EvalTemplateArgs<ExtArgs>
    JobConfiguration?: boolean | Project$JobConfigurationArgs<ExtArgs>
    JobExecution?: boolean | Project$JobExecutionArgs<ExtArgs>
    LlmApiKeys?: boolean | Project$LlmApiKeysArgs<ExtArgs>
    PosthogIntegration?: boolean | Project$PosthogIntegrationArgs<ExtArgs>
    Score?: boolean | Project$ScoreArgs<ExtArgs>
    scoreConfig?: boolean | Project$scoreConfigArgs<ExtArgs>
    BatchExport?: boolean | Project$BatchExportArgs<ExtArgs>
    comment?: boolean | Project$commentArgs<ExtArgs>
    annotationQueue?: boolean | Project$annotationQueueArgs<ExtArgs>
    annotationQueueItem?: boolean | Project$annotationQueueItemArgs<ExtArgs>
    TraceMedia?: boolean | Project$TraceMediaArgs<ExtArgs>
    Media?: boolean | Project$MediaArgs<ExtArgs>
    ObservationMedia?: boolean | Project$ObservationMediaArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    name?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    name?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectMembers?: boolean | Project$projectMembersArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    traces?: boolean | Project$tracesArgs<ExtArgs>
    observations?: boolean | Project$observationsArgs<ExtArgs>
    apiKeys?: boolean | Project$apiKeysArgs<ExtArgs>
    dataset?: boolean | Project$datasetArgs<ExtArgs>
    RawEvents?: boolean | Project$RawEventsArgs<ExtArgs>
    invitations?: boolean | Project$invitationsArgs<ExtArgs>
    sessions?: boolean | Project$sessionsArgs<ExtArgs>
    Prompt?: boolean | Project$PromptArgs<ExtArgs>
    Model?: boolean | Project$ModelArgs<ExtArgs>
    EvalTemplate?: boolean | Project$EvalTemplateArgs<ExtArgs>
    JobConfiguration?: boolean | Project$JobConfigurationArgs<ExtArgs>
    JobExecution?: boolean | Project$JobExecutionArgs<ExtArgs>
    LlmApiKeys?: boolean | Project$LlmApiKeysArgs<ExtArgs>
    PosthogIntegration?: boolean | Project$PosthogIntegrationArgs<ExtArgs>
    Score?: boolean | Project$ScoreArgs<ExtArgs>
    scoreConfig?: boolean | Project$scoreConfigArgs<ExtArgs>
    BatchExport?: boolean | Project$BatchExportArgs<ExtArgs>
    comment?: boolean | Project$commentArgs<ExtArgs>
    annotationQueue?: boolean | Project$annotationQueueArgs<ExtArgs>
    annotationQueueItem?: boolean | Project$annotationQueueItemArgs<ExtArgs>
    TraceMedia?: boolean | Project$TraceMediaArgs<ExtArgs>
    Media?: boolean | Project$MediaArgs<ExtArgs>
    ObservationMedia?: boolean | Project$ObservationMediaArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      projectMembers: Prisma.$ProjectMembershipPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
      traces: Prisma.$TracePayload<ExtArgs>[]
      observations: Prisma.$ObservationPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      dataset: Prisma.$DatasetPayload<ExtArgs>[]
      RawEvents: Prisma.$EventsPayload<ExtArgs>[]
      invitations: Prisma.$MembershipInvitationPayload<ExtArgs>[]
      sessions: Prisma.$TraceSessionPayload<ExtArgs>[]
      Prompt: Prisma.$PromptPayload<ExtArgs>[]
      Model: Prisma.$ModelPayload<ExtArgs>[]
      EvalTemplate: Prisma.$EvalTemplatePayload<ExtArgs>[]
      JobConfiguration: Prisma.$JobConfigurationPayload<ExtArgs>[]
      JobExecution: Prisma.$JobExecutionPayload<ExtArgs>[]
      LlmApiKeys: Prisma.$LlmApiKeysPayload<ExtArgs>[]
      PosthogIntegration: Prisma.$PosthogIntegrationPayload<ExtArgs>[]
      Score: Prisma.$ScorePayload<ExtArgs>[]
      scoreConfig: Prisma.$ScoreConfigPayload<ExtArgs>[]
      BatchExport: Prisma.$BatchExportPayload<ExtArgs>[]
      comment: Prisma.$CommentPayload<ExtArgs>[]
      annotationQueue: Prisma.$AnnotationQueuePayload<ExtArgs>[]
      annotationQueueItem: Prisma.$AnnotationQueueItemPayload<ExtArgs>[]
      TraceMedia: Prisma.$TraceMediaPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs>[]
      ObservationMedia: Prisma.$ObservationMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      name: string
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectMembers<T extends Project$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    traces<T extends Project$tracesArgs<ExtArgs> = {}>(args?: Subset<T, Project$tracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findMany"> | Null>
    observations<T extends Project$observationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$observationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Project$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Project$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    dataset<T extends Project$datasetArgs<ExtArgs> = {}>(args?: Subset<T, Project$datasetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findMany"> | Null>
    RawEvents<T extends Project$RawEventsArgs<ExtArgs> = {}>(args?: Subset<T, Project$RawEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends Project$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Project$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findMany"> | Null>
    Prompt<T extends Project$PromptArgs<ExtArgs> = {}>(args?: Subset<T, Project$PromptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany"> | Null>
    Model<T extends Project$ModelArgs<ExtArgs> = {}>(args?: Subset<T, Project$ModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany"> | Null>
    EvalTemplate<T extends Project$EvalTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Project$EvalTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    JobConfiguration<T extends Project$JobConfigurationArgs<ExtArgs> = {}>(args?: Subset<T, Project$JobConfigurationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    JobExecution<T extends Project$JobExecutionArgs<ExtArgs> = {}>(args?: Subset<T, Project$JobExecutionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    LlmApiKeys<T extends Project$LlmApiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Project$LlmApiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "findMany"> | Null>
    PosthogIntegration<T extends Project$PosthogIntegrationArgs<ExtArgs> = {}>(args?: Subset<T, Project$PosthogIntegrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    Score<T extends Project$ScoreArgs<ExtArgs> = {}>(args?: Subset<T, Project$ScoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany"> | Null>
    scoreConfig<T extends Project$scoreConfigArgs<ExtArgs> = {}>(args?: Subset<T, Project$scoreConfigArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findMany"> | Null>
    BatchExport<T extends Project$BatchExportArgs<ExtArgs> = {}>(args?: Subset<T, Project$BatchExportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "findMany"> | Null>
    comment<T extends Project$commentArgs<ExtArgs> = {}>(args?: Subset<T, Project$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    annotationQueue<T extends Project$annotationQueueArgs<ExtArgs> = {}>(args?: Subset<T, Project$annotationQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findMany"> | Null>
    annotationQueueItem<T extends Project$annotationQueueItemArgs<ExtArgs> = {}>(args?: Subset<T, Project$annotationQueueItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findMany"> | Null>
    TraceMedia<T extends Project$TraceMediaArgs<ExtArgs> = {}>(args?: Subset<T, Project$TraceMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findMany"> | Null>
    Media<T extends Project$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Project$MediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    ObservationMedia<T extends Project$ObservationMediaArgs<ExtArgs> = {}>(args?: Subset<T, Project$ObservationMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly orgId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly deletedAt: FieldRef<"Project", 'DateTime'>
    readonly name: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.projectMembers
   */
  export type Project$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    where?: ProjectMembershipWhereInput
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    cursor?: ProjectMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMembershipScalarFieldEnum | ProjectMembershipScalarFieldEnum[]
  }

  /**
   * Project.traces
   */
  export type Project$tracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    where?: TraceWhereInput
    orderBy?: TraceOrderByWithRelationInput | TraceOrderByWithRelationInput[]
    cursor?: TraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraceScalarFieldEnum | TraceScalarFieldEnum[]
  }

  /**
   * Project.observations
   */
  export type Project$observationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    cursor?: ObservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Project.apiKeys
   */
  export type Project$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Project.dataset
   */
  export type Project$datasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    where?: DatasetWhereInput
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    cursor?: DatasetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Project.RawEvents
   */
  export type Project$RawEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Project.invitations
   */
  export type Project$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    where?: MembershipInvitationWhereInput
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    cursor?: MembershipInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipInvitationScalarFieldEnum | MembershipInvitationScalarFieldEnum[]
  }

  /**
   * Project.sessions
   */
  export type Project$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    where?: TraceSessionWhereInput
    orderBy?: TraceSessionOrderByWithRelationInput | TraceSessionOrderByWithRelationInput[]
    cursor?: TraceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraceSessionScalarFieldEnum | TraceSessionScalarFieldEnum[]
  }

  /**
   * Project.Prompt
   */
  export type Project$PromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    cursor?: PromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Project.Model
   */
  export type Project$ModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Project.EvalTemplate
   */
  export type Project$EvalTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    where?: EvalTemplateWhereInput
    orderBy?: EvalTemplateOrderByWithRelationInput | EvalTemplateOrderByWithRelationInput[]
    cursor?: EvalTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvalTemplateScalarFieldEnum | EvalTemplateScalarFieldEnum[]
  }

  /**
   * Project.JobConfiguration
   */
  export type Project$JobConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    where?: JobConfigurationWhereInput
    orderBy?: JobConfigurationOrderByWithRelationInput | JobConfigurationOrderByWithRelationInput[]
    cursor?: JobConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobConfigurationScalarFieldEnum | JobConfigurationScalarFieldEnum[]
  }

  /**
   * Project.JobExecution
   */
  export type Project$JobExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    where?: JobExecutionWhereInput
    orderBy?: JobExecutionOrderByWithRelationInput | JobExecutionOrderByWithRelationInput[]
    cursor?: JobExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobExecutionScalarFieldEnum | JobExecutionScalarFieldEnum[]
  }

  /**
   * Project.LlmApiKeys
   */
  export type Project$LlmApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    where?: LlmApiKeysWhereInput
    orderBy?: LlmApiKeysOrderByWithRelationInput | LlmApiKeysOrderByWithRelationInput[]
    cursor?: LlmApiKeysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmApiKeysScalarFieldEnum | LlmApiKeysScalarFieldEnum[]
  }

  /**
   * Project.PosthogIntegration
   */
  export type Project$PosthogIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    where?: PosthogIntegrationWhereInput
    orderBy?: PosthogIntegrationOrderByWithRelationInput | PosthogIntegrationOrderByWithRelationInput[]
    cursor?: PosthogIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosthogIntegrationScalarFieldEnum | PosthogIntegrationScalarFieldEnum[]
  }

  /**
   * Project.Score
   */
  export type Project$ScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    cursor?: ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Project.scoreConfig
   */
  export type Project$scoreConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    where?: ScoreConfigWhereInput
    orderBy?: ScoreConfigOrderByWithRelationInput | ScoreConfigOrderByWithRelationInput[]
    cursor?: ScoreConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreConfigScalarFieldEnum | ScoreConfigScalarFieldEnum[]
  }

  /**
   * Project.BatchExport
   */
  export type Project$BatchExportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    where?: BatchExportWhereInput
    orderBy?: BatchExportOrderByWithRelationInput | BatchExportOrderByWithRelationInput[]
    cursor?: BatchExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchExportScalarFieldEnum | BatchExportScalarFieldEnum[]
  }

  /**
   * Project.comment
   */
  export type Project$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Project.annotationQueue
   */
  export type Project$annotationQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    where?: AnnotationQueueWhereInput
    orderBy?: AnnotationQueueOrderByWithRelationInput | AnnotationQueueOrderByWithRelationInput[]
    cursor?: AnnotationQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationQueueScalarFieldEnum | AnnotationQueueScalarFieldEnum[]
  }

  /**
   * Project.annotationQueueItem
   */
  export type Project$annotationQueueItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    where?: AnnotationQueueItemWhereInput
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    cursor?: AnnotationQueueItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
  }

  /**
   * Project.TraceMedia
   */
  export type Project$TraceMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    where?: TraceMediaWhereInput
    orderBy?: TraceMediaOrderByWithRelationInput | TraceMediaOrderByWithRelationInput[]
    cursor?: TraceMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraceMediaScalarFieldEnum | TraceMediaScalarFieldEnum[]
  }

  /**
   * Project.Media
   */
  export type Project$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Project.ObservationMedia
   */
  export type Project$ObservationMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    where?: ObservationMediaWhereInput
    orderBy?: ObservationMediaOrderByWithRelationInput | ObservationMediaOrderByWithRelationInput[]
    cursor?: ObservationMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationMediaScalarFieldEnum | ObservationMediaScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    note: string | null
    publicKey: string | null
    hashedSecretKey: string | null
    fastHashedSecretKey: string | null
    displaySecretKey: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    projectId: string | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    note: string | null
    publicKey: string | null
    hashedSecretKey: string | null
    fastHashedSecretKey: string | null
    displaySecretKey: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    projectId: string | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    createdAt: number
    note: number
    publicKey: number
    hashedSecretKey: number
    fastHashedSecretKey: number
    displaySecretKey: number
    lastUsedAt: number
    expiresAt: number
    projectId: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    createdAt?: true
    note?: true
    publicKey?: true
    hashedSecretKey?: true
    fastHashedSecretKey?: true
    displaySecretKey?: true
    lastUsedAt?: true
    expiresAt?: true
    projectId?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    note?: true
    publicKey?: true
    hashedSecretKey?: true
    fastHashedSecretKey?: true
    displaySecretKey?: true
    lastUsedAt?: true
    expiresAt?: true
    projectId?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    createdAt?: true
    note?: true
    publicKey?: true
    hashedSecretKey?: true
    fastHashedSecretKey?: true
    displaySecretKey?: true
    lastUsedAt?: true
    expiresAt?: true
    projectId?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    createdAt: Date
    note: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey: string | null
    displaySecretKey: string
    lastUsedAt: Date | null
    expiresAt: Date | null
    projectId: string
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    note?: boolean
    publicKey?: boolean
    hashedSecretKey?: boolean
    fastHashedSecretKey?: boolean
    displaySecretKey?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    note?: boolean
    publicKey?: boolean
    hashedSecretKey?: boolean
    fastHashedSecretKey?: boolean
    displaySecretKey?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    createdAt?: boolean
    note?: boolean
    publicKey?: boolean
    hashedSecretKey?: boolean
    fastHashedSecretKey?: boolean
    displaySecretKey?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    projectId?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      note: string | null
      publicKey: string
      hashedSecretKey: string
      fastHashedSecretKey: string | null
      displaySecretKey: string
      lastUsedAt: Date | null
      expiresAt: Date | null
      projectId: string
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly note: FieldRef<"ApiKey", 'String'>
    readonly publicKey: FieldRef<"ApiKey", 'String'>
    readonly hashedSecretKey: FieldRef<"ApiKey", 'String'>
    readonly fastHashedSecretKey: FieldRef<"ApiKey", 'String'>
    readonly displaySecretKey: FieldRef<"ApiKey", 'String'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly projectId: FieldRef<"ApiKey", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model BackgroundMigration
   */

  export type AggregateBackgroundMigration = {
    _count: BackgroundMigrationCountAggregateOutputType | null
    _min: BackgroundMigrationMinAggregateOutputType | null
    _max: BackgroundMigrationMaxAggregateOutputType | null
  }

  export type BackgroundMigrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    script: string | null
    finishedAt: Date | null
    failedAt: Date | null
    failedReason: string | null
    workerId: string | null
    lockedAt: Date | null
  }

  export type BackgroundMigrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    script: string | null
    finishedAt: Date | null
    failedAt: Date | null
    failedReason: string | null
    workerId: string | null
    lockedAt: Date | null
  }

  export type BackgroundMigrationCountAggregateOutputType = {
    id: number
    name: number
    script: number
    args: number
    state: number
    finishedAt: number
    failedAt: number
    failedReason: number
    workerId: number
    lockedAt: number
    _all: number
  }


  export type BackgroundMigrationMinAggregateInputType = {
    id?: true
    name?: true
    script?: true
    finishedAt?: true
    failedAt?: true
    failedReason?: true
    workerId?: true
    lockedAt?: true
  }

  export type BackgroundMigrationMaxAggregateInputType = {
    id?: true
    name?: true
    script?: true
    finishedAt?: true
    failedAt?: true
    failedReason?: true
    workerId?: true
    lockedAt?: true
  }

  export type BackgroundMigrationCountAggregateInputType = {
    id?: true
    name?: true
    script?: true
    args?: true
    state?: true
    finishedAt?: true
    failedAt?: true
    failedReason?: true
    workerId?: true
    lockedAt?: true
    _all?: true
  }

  export type BackgroundMigrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackgroundMigration to aggregate.
     */
    where?: BackgroundMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackgroundMigrations to fetch.
     */
    orderBy?: BackgroundMigrationOrderByWithRelationInput | BackgroundMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackgroundMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackgroundMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackgroundMigrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackgroundMigrations
    **/
    _count?: true | BackgroundMigrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackgroundMigrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackgroundMigrationMaxAggregateInputType
  }

  export type GetBackgroundMigrationAggregateType<T extends BackgroundMigrationAggregateArgs> = {
        [P in keyof T & keyof AggregateBackgroundMigration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackgroundMigration[P]>
      : GetScalarType<T[P], AggregateBackgroundMigration[P]>
  }




  export type BackgroundMigrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackgroundMigrationWhereInput
    orderBy?: BackgroundMigrationOrderByWithAggregationInput | BackgroundMigrationOrderByWithAggregationInput[]
    by: BackgroundMigrationScalarFieldEnum[] | BackgroundMigrationScalarFieldEnum
    having?: BackgroundMigrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackgroundMigrationCountAggregateInputType | true
    _min?: BackgroundMigrationMinAggregateInputType
    _max?: BackgroundMigrationMaxAggregateInputType
  }

  export type BackgroundMigrationGroupByOutputType = {
    id: string
    name: string
    script: string
    args: JsonValue
    state: JsonValue
    finishedAt: Date | null
    failedAt: Date | null
    failedReason: string | null
    workerId: string | null
    lockedAt: Date | null
    _count: BackgroundMigrationCountAggregateOutputType | null
    _min: BackgroundMigrationMinAggregateOutputType | null
    _max: BackgroundMigrationMaxAggregateOutputType | null
  }

  type GetBackgroundMigrationGroupByPayload<T extends BackgroundMigrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackgroundMigrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackgroundMigrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackgroundMigrationGroupByOutputType[P]>
            : GetScalarType<T[P], BackgroundMigrationGroupByOutputType[P]>
        }
      >
    >


  export type BackgroundMigrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    script?: boolean
    args?: boolean
    state?: boolean
    finishedAt?: boolean
    failedAt?: boolean
    failedReason?: boolean
    workerId?: boolean
    lockedAt?: boolean
  }, ExtArgs["result"]["backgroundMigration"]>

  export type BackgroundMigrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    script?: boolean
    args?: boolean
    state?: boolean
    finishedAt?: boolean
    failedAt?: boolean
    failedReason?: boolean
    workerId?: boolean
    lockedAt?: boolean
  }, ExtArgs["result"]["backgroundMigration"]>

  export type BackgroundMigrationSelectScalar = {
    id?: boolean
    name?: boolean
    script?: boolean
    args?: boolean
    state?: boolean
    finishedAt?: boolean
    failedAt?: boolean
    failedReason?: boolean
    workerId?: boolean
    lockedAt?: boolean
  }


  export type $BackgroundMigrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackgroundMigration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      script: string
      args: Prisma.JsonValue
      state: Prisma.JsonValue
      finishedAt: Date | null
      failedAt: Date | null
      failedReason: string | null
      workerId: string | null
      lockedAt: Date | null
    }, ExtArgs["result"]["backgroundMigration"]>
    composites: {}
  }

  type BackgroundMigrationGetPayload<S extends boolean | null | undefined | BackgroundMigrationDefaultArgs> = $Result.GetResult<Prisma.$BackgroundMigrationPayload, S>

  type BackgroundMigrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BackgroundMigrationFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: BackgroundMigrationCountAggregateInputType | true
    }

  export interface BackgroundMigrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackgroundMigration'], meta: { name: 'BackgroundMigration' } }
    /**
     * Find zero or one BackgroundMigration that matches the filter.
     * @param {BackgroundMigrationFindUniqueArgs} args - Arguments to find a BackgroundMigration
     * @example
     * // Get one BackgroundMigration
     * const backgroundMigration = await prisma.backgroundMigration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackgroundMigrationFindUniqueArgs>(args: SelectSubset<T, BackgroundMigrationFindUniqueArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BackgroundMigration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BackgroundMigrationFindUniqueOrThrowArgs} args - Arguments to find a BackgroundMigration
     * @example
     * // Get one BackgroundMigration
     * const backgroundMigration = await prisma.backgroundMigration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackgroundMigrationFindUniqueOrThrowArgs>(args: SelectSubset<T, BackgroundMigrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BackgroundMigration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationFindFirstArgs} args - Arguments to find a BackgroundMigration
     * @example
     * // Get one BackgroundMigration
     * const backgroundMigration = await prisma.backgroundMigration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackgroundMigrationFindFirstArgs>(args?: SelectSubset<T, BackgroundMigrationFindFirstArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BackgroundMigration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationFindFirstOrThrowArgs} args - Arguments to find a BackgroundMigration
     * @example
     * // Get one BackgroundMigration
     * const backgroundMigration = await prisma.backgroundMigration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackgroundMigrationFindFirstOrThrowArgs>(args?: SelectSubset<T, BackgroundMigrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BackgroundMigrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackgroundMigrations
     * const backgroundMigrations = await prisma.backgroundMigration.findMany()
     * 
     * // Get first 10 BackgroundMigrations
     * const backgroundMigrations = await prisma.backgroundMigration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backgroundMigrationWithIdOnly = await prisma.backgroundMigration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackgroundMigrationFindManyArgs>(args?: SelectSubset<T, BackgroundMigrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BackgroundMigration.
     * @param {BackgroundMigrationCreateArgs} args - Arguments to create a BackgroundMigration.
     * @example
     * // Create one BackgroundMigration
     * const BackgroundMigration = await prisma.backgroundMigration.create({
     *   data: {
     *     // ... data to create a BackgroundMigration
     *   }
     * })
     * 
     */
    create<T extends BackgroundMigrationCreateArgs>(args: SelectSubset<T, BackgroundMigrationCreateArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BackgroundMigrations.
     * @param {BackgroundMigrationCreateManyArgs} args - Arguments to create many BackgroundMigrations.
     * @example
     * // Create many BackgroundMigrations
     * const backgroundMigration = await prisma.backgroundMigration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackgroundMigrationCreateManyArgs>(args?: SelectSubset<T, BackgroundMigrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackgroundMigrations and returns the data saved in the database.
     * @param {BackgroundMigrationCreateManyAndReturnArgs} args - Arguments to create many BackgroundMigrations.
     * @example
     * // Create many BackgroundMigrations
     * const backgroundMigration = await prisma.backgroundMigration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackgroundMigrations and only return the `id`
     * const backgroundMigrationWithIdOnly = await prisma.backgroundMigration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackgroundMigrationCreateManyAndReturnArgs>(args?: SelectSubset<T, BackgroundMigrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BackgroundMigration.
     * @param {BackgroundMigrationDeleteArgs} args - Arguments to delete one BackgroundMigration.
     * @example
     * // Delete one BackgroundMigration
     * const BackgroundMigration = await prisma.backgroundMigration.delete({
     *   where: {
     *     // ... filter to delete one BackgroundMigration
     *   }
     * })
     * 
     */
    delete<T extends BackgroundMigrationDeleteArgs>(args: SelectSubset<T, BackgroundMigrationDeleteArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BackgroundMigration.
     * @param {BackgroundMigrationUpdateArgs} args - Arguments to update one BackgroundMigration.
     * @example
     * // Update one BackgroundMigration
     * const backgroundMigration = await prisma.backgroundMigration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackgroundMigrationUpdateArgs>(args: SelectSubset<T, BackgroundMigrationUpdateArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BackgroundMigrations.
     * @param {BackgroundMigrationDeleteManyArgs} args - Arguments to filter BackgroundMigrations to delete.
     * @example
     * // Delete a few BackgroundMigrations
     * const { count } = await prisma.backgroundMigration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackgroundMigrationDeleteManyArgs>(args?: SelectSubset<T, BackgroundMigrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackgroundMigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackgroundMigrations
     * const backgroundMigration = await prisma.backgroundMigration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackgroundMigrationUpdateManyArgs>(args: SelectSubset<T, BackgroundMigrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BackgroundMigration.
     * @param {BackgroundMigrationUpsertArgs} args - Arguments to update or create a BackgroundMigration.
     * @example
     * // Update or create a BackgroundMigration
     * const backgroundMigration = await prisma.backgroundMigration.upsert({
     *   create: {
     *     // ... data to create a BackgroundMigration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackgroundMigration we want to update
     *   }
     * })
     */
    upsert<T extends BackgroundMigrationUpsertArgs>(args: SelectSubset<T, BackgroundMigrationUpsertArgs<ExtArgs>>): Prisma__BackgroundMigrationClient<$Result.GetResult<Prisma.$BackgroundMigrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BackgroundMigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationCountArgs} args - Arguments to filter BackgroundMigrations to count.
     * @example
     * // Count the number of BackgroundMigrations
     * const count = await prisma.backgroundMigration.count({
     *   where: {
     *     // ... the filter for the BackgroundMigrations we want to count
     *   }
     * })
    **/
    count<T extends BackgroundMigrationCountArgs>(
      args?: Subset<T, BackgroundMigrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackgroundMigrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackgroundMigration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackgroundMigrationAggregateArgs>(args: Subset<T, BackgroundMigrationAggregateArgs>): Prisma.PrismaPromise<GetBackgroundMigrationAggregateType<T>>

    /**
     * Group by BackgroundMigration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundMigrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackgroundMigrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackgroundMigrationGroupByArgs['orderBy'] }
        : { orderBy?: BackgroundMigrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackgroundMigrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackgroundMigrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackgroundMigration model
   */
  readonly fields: BackgroundMigrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackgroundMigration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackgroundMigrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackgroundMigration model
   */ 
  interface BackgroundMigrationFieldRefs {
    readonly id: FieldRef<"BackgroundMigration", 'String'>
    readonly name: FieldRef<"BackgroundMigration", 'String'>
    readonly script: FieldRef<"BackgroundMigration", 'String'>
    readonly args: FieldRef<"BackgroundMigration", 'Json'>
    readonly state: FieldRef<"BackgroundMigration", 'Json'>
    readonly finishedAt: FieldRef<"BackgroundMigration", 'DateTime'>
    readonly failedAt: FieldRef<"BackgroundMigration", 'DateTime'>
    readonly failedReason: FieldRef<"BackgroundMigration", 'String'>
    readonly workerId: FieldRef<"BackgroundMigration", 'String'>
    readonly lockedAt: FieldRef<"BackgroundMigration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BackgroundMigration findUnique
   */
  export type BackgroundMigrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * Filter, which BackgroundMigration to fetch.
     */
    where: BackgroundMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration findUniqueOrThrow
   */
  export type BackgroundMigrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * Filter, which BackgroundMigration to fetch.
     */
    where: BackgroundMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration findFirst
   */
  export type BackgroundMigrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * Filter, which BackgroundMigration to fetch.
     */
    where?: BackgroundMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackgroundMigrations to fetch.
     */
    orderBy?: BackgroundMigrationOrderByWithRelationInput | BackgroundMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackgroundMigrations.
     */
    cursor?: BackgroundMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackgroundMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackgroundMigrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackgroundMigrations.
     */
    distinct?: BackgroundMigrationScalarFieldEnum | BackgroundMigrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration findFirstOrThrow
   */
  export type BackgroundMigrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * Filter, which BackgroundMigration to fetch.
     */
    where?: BackgroundMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackgroundMigrations to fetch.
     */
    orderBy?: BackgroundMigrationOrderByWithRelationInput | BackgroundMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackgroundMigrations.
     */
    cursor?: BackgroundMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackgroundMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackgroundMigrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackgroundMigrations.
     */
    distinct?: BackgroundMigrationScalarFieldEnum | BackgroundMigrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration findMany
   */
  export type BackgroundMigrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * Filter, which BackgroundMigrations to fetch.
     */
    where?: BackgroundMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackgroundMigrations to fetch.
     */
    orderBy?: BackgroundMigrationOrderByWithRelationInput | BackgroundMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackgroundMigrations.
     */
    cursor?: BackgroundMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackgroundMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackgroundMigrations.
     */
    skip?: number
    distinct?: BackgroundMigrationScalarFieldEnum | BackgroundMigrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration create
   */
  export type BackgroundMigrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * The data needed to create a BackgroundMigration.
     */
    data: XOR<BackgroundMigrationCreateInput, BackgroundMigrationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration createMany
   */
  export type BackgroundMigrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackgroundMigrations.
     */
    data: BackgroundMigrationCreateManyInput | BackgroundMigrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackgroundMigration createManyAndReturn
   */
  export type BackgroundMigrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BackgroundMigrations.
     */
    data: BackgroundMigrationCreateManyInput | BackgroundMigrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackgroundMigration update
   */
  export type BackgroundMigrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * The data needed to update a BackgroundMigration.
     */
    data: XOR<BackgroundMigrationUpdateInput, BackgroundMigrationUncheckedUpdateInput>
    /**
     * Choose, which BackgroundMigration to update.
     */
    where: BackgroundMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration updateMany
   */
  export type BackgroundMigrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackgroundMigrations.
     */
    data: XOR<BackgroundMigrationUpdateManyMutationInput, BackgroundMigrationUncheckedUpdateManyInput>
    /**
     * Filter which BackgroundMigrations to update
     */
    where?: BackgroundMigrationWhereInput
  }

  /**
   * BackgroundMigration upsert
   */
  export type BackgroundMigrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * The filter to search for the BackgroundMigration to update in case it exists.
     */
    where: BackgroundMigrationWhereUniqueInput
    /**
     * In case the BackgroundMigration found by the `where` argument doesn't exist, create a new BackgroundMigration with this data.
     */
    create: XOR<BackgroundMigrationCreateInput, BackgroundMigrationUncheckedCreateInput>
    /**
     * In case the BackgroundMigration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackgroundMigrationUpdateInput, BackgroundMigrationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration delete
   */
  export type BackgroundMigrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
    /**
     * Filter which BackgroundMigration to delete.
     */
    where: BackgroundMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BackgroundMigration deleteMany
   */
  export type BackgroundMigrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackgroundMigrations to delete
     */
    where?: BackgroundMigrationWhereInput
  }

  /**
   * BackgroundMigration without action
   */
  export type BackgroundMigrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundMigration
     */
    select?: BackgroundMigrationSelect<ExtArgs> | null
  }


  /**
   * Model LlmApiKeys
   */

  export type AggregateLlmApiKeys = {
    _count: LlmApiKeysCountAggregateOutputType | null
    _min: LlmApiKeysMinAggregateOutputType | null
    _max: LlmApiKeysMaxAggregateOutputType | null
  }

  export type LlmApiKeysMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    provider: string | null
    adapter: string | null
    displaySecretKey: string | null
    secretKey: string | null
    baseURL: string | null
    withDefaultModels: boolean | null
    projectId: string | null
  }

  export type LlmApiKeysMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    provider: string | null
    adapter: string | null
    displaySecretKey: string | null
    secretKey: string | null
    baseURL: string | null
    withDefaultModels: boolean | null
    projectId: string | null
  }

  export type LlmApiKeysCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    provider: number
    adapter: number
    displaySecretKey: number
    secretKey: number
    baseURL: number
    customModels: number
    withDefaultModels: number
    config: number
    projectId: number
    _all: number
  }


  export type LlmApiKeysMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    provider?: true
    adapter?: true
    displaySecretKey?: true
    secretKey?: true
    baseURL?: true
    withDefaultModels?: true
    projectId?: true
  }

  export type LlmApiKeysMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    provider?: true
    adapter?: true
    displaySecretKey?: true
    secretKey?: true
    baseURL?: true
    withDefaultModels?: true
    projectId?: true
  }

  export type LlmApiKeysCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    provider?: true
    adapter?: true
    displaySecretKey?: true
    secretKey?: true
    baseURL?: true
    customModels?: true
    withDefaultModels?: true
    config?: true
    projectId?: true
    _all?: true
  }

  export type LlmApiKeysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LlmApiKeys to aggregate.
     */
    where?: LlmApiKeysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmApiKeys to fetch.
     */
    orderBy?: LlmApiKeysOrderByWithRelationInput | LlmApiKeysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LlmApiKeysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LlmApiKeys
    **/
    _count?: true | LlmApiKeysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LlmApiKeysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LlmApiKeysMaxAggregateInputType
  }

  export type GetLlmApiKeysAggregateType<T extends LlmApiKeysAggregateArgs> = {
        [P in keyof T & keyof AggregateLlmApiKeys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLlmApiKeys[P]>
      : GetScalarType<T[P], AggregateLlmApiKeys[P]>
  }




  export type LlmApiKeysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmApiKeysWhereInput
    orderBy?: LlmApiKeysOrderByWithAggregationInput | LlmApiKeysOrderByWithAggregationInput[]
    by: LlmApiKeysScalarFieldEnum[] | LlmApiKeysScalarFieldEnum
    having?: LlmApiKeysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LlmApiKeysCountAggregateInputType | true
    _min?: LlmApiKeysMinAggregateInputType
    _max?: LlmApiKeysMaxAggregateInputType
  }

  export type LlmApiKeysGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL: string | null
    customModels: string[]
    withDefaultModels: boolean
    config: JsonValue | null
    projectId: string
    _count: LlmApiKeysCountAggregateOutputType | null
    _min: LlmApiKeysMinAggregateOutputType | null
    _max: LlmApiKeysMaxAggregateOutputType | null
  }

  type GetLlmApiKeysGroupByPayload<T extends LlmApiKeysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LlmApiKeysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LlmApiKeysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LlmApiKeysGroupByOutputType[P]>
            : GetScalarType<T[P], LlmApiKeysGroupByOutputType[P]>
        }
      >
    >


  export type LlmApiKeysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    adapter?: boolean
    displaySecretKey?: boolean
    secretKey?: boolean
    baseURL?: boolean
    customModels?: boolean
    withDefaultModels?: boolean
    config?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["llmApiKeys"]>

  export type LlmApiKeysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    adapter?: boolean
    displaySecretKey?: boolean
    secretKey?: boolean
    baseURL?: boolean
    customModels?: boolean
    withDefaultModels?: boolean
    config?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["llmApiKeys"]>

  export type LlmApiKeysSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    adapter?: boolean
    displaySecretKey?: boolean
    secretKey?: boolean
    baseURL?: boolean
    customModels?: boolean
    withDefaultModels?: boolean
    config?: boolean
    projectId?: boolean
  }

  export type LlmApiKeysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type LlmApiKeysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $LlmApiKeysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LlmApiKeys"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      provider: string
      adapter: string
      displaySecretKey: string
      secretKey: string
      baseURL: string | null
      customModels: string[]
      withDefaultModels: boolean
      config: Prisma.JsonValue | null
      projectId: string
    }, ExtArgs["result"]["llmApiKeys"]>
    composites: {}
  }

  type LlmApiKeysGetPayload<S extends boolean | null | undefined | LlmApiKeysDefaultArgs> = $Result.GetResult<Prisma.$LlmApiKeysPayload, S>

  type LlmApiKeysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LlmApiKeysFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LlmApiKeysCountAggregateInputType | true
    }

  export interface LlmApiKeysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LlmApiKeys'], meta: { name: 'LlmApiKeys' } }
    /**
     * Find zero or one LlmApiKeys that matches the filter.
     * @param {LlmApiKeysFindUniqueArgs} args - Arguments to find a LlmApiKeys
     * @example
     * // Get one LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LlmApiKeysFindUniqueArgs>(args: SelectSubset<T, LlmApiKeysFindUniqueArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LlmApiKeys that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LlmApiKeysFindUniqueOrThrowArgs} args - Arguments to find a LlmApiKeys
     * @example
     * // Get one LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LlmApiKeysFindUniqueOrThrowArgs>(args: SelectSubset<T, LlmApiKeysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LlmApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysFindFirstArgs} args - Arguments to find a LlmApiKeys
     * @example
     * // Get one LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LlmApiKeysFindFirstArgs>(args?: SelectSubset<T, LlmApiKeysFindFirstArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LlmApiKeys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysFindFirstOrThrowArgs} args - Arguments to find a LlmApiKeys
     * @example
     * // Get one LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LlmApiKeysFindFirstOrThrowArgs>(args?: SelectSubset<T, LlmApiKeysFindFirstOrThrowArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LlmApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.findMany()
     * 
     * // Get first 10 LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const llmApiKeysWithIdOnly = await prisma.llmApiKeys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LlmApiKeysFindManyArgs>(args?: SelectSubset<T, LlmApiKeysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LlmApiKeys.
     * @param {LlmApiKeysCreateArgs} args - Arguments to create a LlmApiKeys.
     * @example
     * // Create one LlmApiKeys
     * const LlmApiKeys = await prisma.llmApiKeys.create({
     *   data: {
     *     // ... data to create a LlmApiKeys
     *   }
     * })
     * 
     */
    create<T extends LlmApiKeysCreateArgs>(args: SelectSubset<T, LlmApiKeysCreateArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LlmApiKeys.
     * @param {LlmApiKeysCreateManyArgs} args - Arguments to create many LlmApiKeys.
     * @example
     * // Create many LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LlmApiKeysCreateManyArgs>(args?: SelectSubset<T, LlmApiKeysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LlmApiKeys and returns the data saved in the database.
     * @param {LlmApiKeysCreateManyAndReturnArgs} args - Arguments to create many LlmApiKeys.
     * @example
     * // Create many LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LlmApiKeys and only return the `id`
     * const llmApiKeysWithIdOnly = await prisma.llmApiKeys.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LlmApiKeysCreateManyAndReturnArgs>(args?: SelectSubset<T, LlmApiKeysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LlmApiKeys.
     * @param {LlmApiKeysDeleteArgs} args - Arguments to delete one LlmApiKeys.
     * @example
     * // Delete one LlmApiKeys
     * const LlmApiKeys = await prisma.llmApiKeys.delete({
     *   where: {
     *     // ... filter to delete one LlmApiKeys
     *   }
     * })
     * 
     */
    delete<T extends LlmApiKeysDeleteArgs>(args: SelectSubset<T, LlmApiKeysDeleteArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LlmApiKeys.
     * @param {LlmApiKeysUpdateArgs} args - Arguments to update one LlmApiKeys.
     * @example
     * // Update one LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LlmApiKeysUpdateArgs>(args: SelectSubset<T, LlmApiKeysUpdateArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LlmApiKeys.
     * @param {LlmApiKeysDeleteManyArgs} args - Arguments to filter LlmApiKeys to delete.
     * @example
     * // Delete a few LlmApiKeys
     * const { count } = await prisma.llmApiKeys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LlmApiKeysDeleteManyArgs>(args?: SelectSubset<T, LlmApiKeysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LlmApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LlmApiKeysUpdateManyArgs>(args: SelectSubset<T, LlmApiKeysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LlmApiKeys.
     * @param {LlmApiKeysUpsertArgs} args - Arguments to update or create a LlmApiKeys.
     * @example
     * // Update or create a LlmApiKeys
     * const llmApiKeys = await prisma.llmApiKeys.upsert({
     *   create: {
     *     // ... data to create a LlmApiKeys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LlmApiKeys we want to update
     *   }
     * })
     */
    upsert<T extends LlmApiKeysUpsertArgs>(args: SelectSubset<T, LlmApiKeysUpsertArgs<ExtArgs>>): Prisma__LlmApiKeysClient<$Result.GetResult<Prisma.$LlmApiKeysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LlmApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysCountArgs} args - Arguments to filter LlmApiKeys to count.
     * @example
     * // Count the number of LlmApiKeys
     * const count = await prisma.llmApiKeys.count({
     *   where: {
     *     // ... the filter for the LlmApiKeys we want to count
     *   }
     * })
    **/
    count<T extends LlmApiKeysCountArgs>(
      args?: Subset<T, LlmApiKeysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LlmApiKeysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LlmApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LlmApiKeysAggregateArgs>(args: Subset<T, LlmApiKeysAggregateArgs>): Prisma.PrismaPromise<GetLlmApiKeysAggregateType<T>>

    /**
     * Group by LlmApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmApiKeysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LlmApiKeysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LlmApiKeysGroupByArgs['orderBy'] }
        : { orderBy?: LlmApiKeysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LlmApiKeysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLlmApiKeysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LlmApiKeys model
   */
  readonly fields: LlmApiKeysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LlmApiKeys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LlmApiKeysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LlmApiKeys model
   */ 
  interface LlmApiKeysFieldRefs {
    readonly id: FieldRef<"LlmApiKeys", 'String'>
    readonly createdAt: FieldRef<"LlmApiKeys", 'DateTime'>
    readonly updatedAt: FieldRef<"LlmApiKeys", 'DateTime'>
    readonly provider: FieldRef<"LlmApiKeys", 'String'>
    readonly adapter: FieldRef<"LlmApiKeys", 'String'>
    readonly displaySecretKey: FieldRef<"LlmApiKeys", 'String'>
    readonly secretKey: FieldRef<"LlmApiKeys", 'String'>
    readonly baseURL: FieldRef<"LlmApiKeys", 'String'>
    readonly customModels: FieldRef<"LlmApiKeys", 'String[]'>
    readonly withDefaultModels: FieldRef<"LlmApiKeys", 'Boolean'>
    readonly config: FieldRef<"LlmApiKeys", 'Json'>
    readonly projectId: FieldRef<"LlmApiKeys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LlmApiKeys findUnique
   */
  export type LlmApiKeysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * Filter, which LlmApiKeys to fetch.
     */
    where: LlmApiKeysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys findUniqueOrThrow
   */
  export type LlmApiKeysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * Filter, which LlmApiKeys to fetch.
     */
    where: LlmApiKeysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys findFirst
   */
  export type LlmApiKeysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * Filter, which LlmApiKeys to fetch.
     */
    where?: LlmApiKeysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmApiKeys to fetch.
     */
    orderBy?: LlmApiKeysOrderByWithRelationInput | LlmApiKeysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LlmApiKeys.
     */
    cursor?: LlmApiKeysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LlmApiKeys.
     */
    distinct?: LlmApiKeysScalarFieldEnum | LlmApiKeysScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys findFirstOrThrow
   */
  export type LlmApiKeysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * Filter, which LlmApiKeys to fetch.
     */
    where?: LlmApiKeysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmApiKeys to fetch.
     */
    orderBy?: LlmApiKeysOrderByWithRelationInput | LlmApiKeysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LlmApiKeys.
     */
    cursor?: LlmApiKeysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LlmApiKeys.
     */
    distinct?: LlmApiKeysScalarFieldEnum | LlmApiKeysScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys findMany
   */
  export type LlmApiKeysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * Filter, which LlmApiKeys to fetch.
     */
    where?: LlmApiKeysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmApiKeys to fetch.
     */
    orderBy?: LlmApiKeysOrderByWithRelationInput | LlmApiKeysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LlmApiKeys.
     */
    cursor?: LlmApiKeysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmApiKeys.
     */
    skip?: number
    distinct?: LlmApiKeysScalarFieldEnum | LlmApiKeysScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys create
   */
  export type LlmApiKeysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * The data needed to create a LlmApiKeys.
     */
    data: XOR<LlmApiKeysCreateInput, LlmApiKeysUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys createMany
   */
  export type LlmApiKeysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LlmApiKeys.
     */
    data: LlmApiKeysCreateManyInput | LlmApiKeysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LlmApiKeys createManyAndReturn
   */
  export type LlmApiKeysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LlmApiKeys.
     */
    data: LlmApiKeysCreateManyInput | LlmApiKeysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LlmApiKeys update
   */
  export type LlmApiKeysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * The data needed to update a LlmApiKeys.
     */
    data: XOR<LlmApiKeysUpdateInput, LlmApiKeysUncheckedUpdateInput>
    /**
     * Choose, which LlmApiKeys to update.
     */
    where: LlmApiKeysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys updateMany
   */
  export type LlmApiKeysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LlmApiKeys.
     */
    data: XOR<LlmApiKeysUpdateManyMutationInput, LlmApiKeysUncheckedUpdateManyInput>
    /**
     * Filter which LlmApiKeys to update
     */
    where?: LlmApiKeysWhereInput
  }

  /**
   * LlmApiKeys upsert
   */
  export type LlmApiKeysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * The filter to search for the LlmApiKeys to update in case it exists.
     */
    where: LlmApiKeysWhereUniqueInput
    /**
     * In case the LlmApiKeys found by the `where` argument doesn't exist, create a new LlmApiKeys with this data.
     */
    create: XOR<LlmApiKeysCreateInput, LlmApiKeysUncheckedCreateInput>
    /**
     * In case the LlmApiKeys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LlmApiKeysUpdateInput, LlmApiKeysUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys delete
   */
  export type LlmApiKeysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
    /**
     * Filter which LlmApiKeys to delete.
     */
    where: LlmApiKeysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LlmApiKeys deleteMany
   */
  export type LlmApiKeysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LlmApiKeys to delete
     */
    where?: LlmApiKeysWhereInput
  }

  /**
   * LlmApiKeys without action
   */
  export type LlmApiKeysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmApiKeys
     */
    select?: LlmApiKeysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmApiKeysInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMembership
   */

  export type AggregateOrganizationMembership = {
    _count: OrganizationMembershipCountAggregateOutputType | null
    _min: OrganizationMembershipMinAggregateOutputType | null
    _max: OrganizationMembershipMaxAggregateOutputType | null
  }

  export type OrganizationMembershipMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMembershipMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMembershipCountAggregateOutputType = {
    id: number
    orgId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMembershipMinAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMembershipMaxAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMembershipCountAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembership to aggregate.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMemberships
    **/
    _count?: true | OrganizationMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMembershipMaxAggregateInputType
  }

  export type GetOrganizationMembershipAggregateType<T extends OrganizationMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMembership[P]>
      : GetScalarType<T[P], AggregateOrganizationMembership[P]>
  }




  export type OrganizationMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMembershipWhereInput
    orderBy?: OrganizationMembershipOrderByWithAggregationInput | OrganizationMembershipOrderByWithAggregationInput[]
    by: OrganizationMembershipScalarFieldEnum[] | OrganizationMembershipScalarFieldEnum
    having?: OrganizationMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMembershipCountAggregateInputType | true
    _min?: OrganizationMembershipMinAggregateInputType
    _max?: OrganizationMembershipMaxAggregateInputType
  }

  export type OrganizationMembershipGroupByOutputType = {
    id: string
    orgId: string
    userId: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: OrganizationMembershipCountAggregateOutputType | null
    _min: OrganizationMembershipMinAggregateOutputType | null
    _max: OrganizationMembershipMaxAggregateOutputType | null
  }

  type GetOrganizationMembershipGroupByPayload<T extends OrganizationMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMembershipGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    ProjectMemberships?: boolean | OrganizationMembership$ProjectMembershipsArgs<ExtArgs>
    _count?: boolean | OrganizationMembershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMembership"]>

  export type OrganizationMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMembership"]>

  export type OrganizationMembershipSelectScalar = {
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    ProjectMemberships?: boolean | OrganizationMembership$ProjectMembershipsArgs<ExtArgs>
    _count?: boolean | OrganizationMembershipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMembership"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      ProjectMemberships: Prisma.$ProjectMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      userId: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationMembership"]>
    composites: {}
  }

  type OrganizationMembershipGetPayload<S extends boolean | null | undefined | OrganizationMembershipDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMembershipPayload, S>

  type OrganizationMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: OrganizationMembershipCountAggregateInputType | true
    }

  export interface OrganizationMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMembership'], meta: { name: 'OrganizationMembership' } }
    /**
     * Find zero or one OrganizationMembership that matches the filter.
     * @param {OrganizationMembershipFindUniqueArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMembershipFindUniqueArgs>(args: SelectSubset<T, OrganizationMembershipFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrganizationMembership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationMembershipFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrganizationMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipFindFirstArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMembershipFindFirstArgs>(args?: SelectSubset<T, OrganizationMembershipFindFirstArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrganizationMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipFindFirstOrThrowArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrganizationMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMemberships
     * const organizationMemberships = await prisma.organizationMembership.findMany()
     * 
     * // Get first 10 OrganizationMemberships
     * const organizationMemberships = await prisma.organizationMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMembershipWithIdOnly = await prisma.organizationMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMembershipFindManyArgs>(args?: SelectSubset<T, OrganizationMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrganizationMembership.
     * @param {OrganizationMembershipCreateArgs} args - Arguments to create a OrganizationMembership.
     * @example
     * // Create one OrganizationMembership
     * const OrganizationMembership = await prisma.organizationMembership.create({
     *   data: {
     *     // ... data to create a OrganizationMembership
     *   }
     * })
     * 
     */
    create<T extends OrganizationMembershipCreateArgs>(args: SelectSubset<T, OrganizationMembershipCreateArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrganizationMemberships.
     * @param {OrganizationMembershipCreateManyArgs} args - Arguments to create many OrganizationMemberships.
     * @example
     * // Create many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMembershipCreateManyArgs>(args?: SelectSubset<T, OrganizationMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMemberships and returns the data saved in the database.
     * @param {OrganizationMembershipCreateManyAndReturnArgs} args - Arguments to create many OrganizationMemberships.
     * @example
     * // Create many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMemberships and only return the `id`
     * const organizationMembershipWithIdOnly = await prisma.organizationMembership.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrganizationMembership.
     * @param {OrganizationMembershipDeleteArgs} args - Arguments to delete one OrganizationMembership.
     * @example
     * // Delete one OrganizationMembership
     * const OrganizationMembership = await prisma.organizationMembership.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMembership
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMembershipDeleteArgs>(args: SelectSubset<T, OrganizationMembershipDeleteArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrganizationMembership.
     * @param {OrganizationMembershipUpdateArgs} args - Arguments to update one OrganizationMembership.
     * @example
     * // Update one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMembershipUpdateArgs>(args: SelectSubset<T, OrganizationMembershipUpdateArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrganizationMemberships.
     * @param {OrganizationMembershipDeleteManyArgs} args - Arguments to filter OrganizationMemberships to delete.
     * @example
     * // Delete a few OrganizationMemberships
     * const { count } = await prisma.organizationMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMembershipDeleteManyArgs>(args?: SelectSubset<T, OrganizationMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMembershipUpdateManyArgs>(args: SelectSubset<T, OrganizationMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationMembership.
     * @param {OrganizationMembershipUpsertArgs} args - Arguments to update or create a OrganizationMembership.
     * @example
     * // Update or create a OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.upsert({
     *   create: {
     *     // ... data to create a OrganizationMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMembership we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMembershipUpsertArgs>(args: SelectSubset<T, OrganizationMembershipUpsertArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrganizationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipCountArgs} args - Arguments to filter OrganizationMemberships to count.
     * @example
     * // Count the number of OrganizationMemberships
     * const count = await prisma.organizationMembership.count({
     *   where: {
     *     // ... the filter for the OrganizationMemberships we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMembershipCountArgs>(
      args?: Subset<T, OrganizationMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMembershipAggregateArgs>(args: Subset<T, OrganizationMembershipAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMembershipAggregateType<T>>

    /**
     * Group by OrganizationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMembershipGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMembership model
   */
  readonly fields: OrganizationMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ProjectMemberships<T extends OrganizationMembership$ProjectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationMembership$ProjectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMembership model
   */ 
  interface OrganizationMembershipFieldRefs {
    readonly id: FieldRef<"OrganizationMembership", 'String'>
    readonly orgId: FieldRef<"OrganizationMembership", 'String'>
    readonly userId: FieldRef<"OrganizationMembership", 'String'>
    readonly role: FieldRef<"OrganizationMembership", 'Role'>
    readonly createdAt: FieldRef<"OrganizationMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMembership findUnique
   */
  export type OrganizationMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where: OrganizationMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership findUniqueOrThrow
   */
  export type OrganizationMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where: OrganizationMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership findFirst
   */
  export type OrganizationMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMemberships.
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMemberships.
     */
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership findFirstOrThrow
   */
  export type OrganizationMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMemberships.
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMemberships.
     */
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership findMany
   */
  export type OrganizationMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMemberships to fetch.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMemberships.
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership create
   */
  export type OrganizationMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMembership.
     */
    data: XOR<OrganizationMembershipCreateInput, OrganizationMembershipUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership createMany
   */
  export type OrganizationMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMemberships.
     */
    data: OrganizationMembershipCreateManyInput | OrganizationMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMembership createManyAndReturn
   */
  export type OrganizationMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrganizationMemberships.
     */
    data: OrganizationMembershipCreateManyInput | OrganizationMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMembership update
   */
  export type OrganizationMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMembership.
     */
    data: XOR<OrganizationMembershipUpdateInput, OrganizationMembershipUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMembership to update.
     */
    where: OrganizationMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership updateMany
   */
  export type OrganizationMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMemberships.
     */
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMemberships to update
     */
    where?: OrganizationMembershipWhereInput
  }

  /**
   * OrganizationMembership upsert
   */
  export type OrganizationMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMembership to update in case it exists.
     */
    where: OrganizationMembershipWhereUniqueInput
    /**
     * In case the OrganizationMembership found by the `where` argument doesn't exist, create a new OrganizationMembership with this data.
     */
    create: XOR<OrganizationMembershipCreateInput, OrganizationMembershipUncheckedCreateInput>
    /**
     * In case the OrganizationMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMembershipUpdateInput, OrganizationMembershipUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership delete
   */
  export type OrganizationMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMembership to delete.
     */
    where: OrganizationMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationMembership deleteMany
   */
  export type OrganizationMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMemberships to delete
     */
    where?: OrganizationMembershipWhereInput
  }

  /**
   * OrganizationMembership.ProjectMemberships
   */
  export type OrganizationMembership$ProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    where?: ProjectMembershipWhereInput
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    cursor?: ProjectMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMembershipScalarFieldEnum | ProjectMembershipScalarFieldEnum[]
  }

  /**
   * OrganizationMembership without action
   */
  export type OrganizationMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMembership
   */

  export type AggregateProjectMembership = {
    _count: ProjectMembershipCountAggregateOutputType | null
    _min: ProjectMembershipMinAggregateOutputType | null
    _max: ProjectMembershipMaxAggregateOutputType | null
  }

  export type ProjectMembershipMinAggregateOutputType = {
    orgMembershipId: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMembershipMaxAggregateOutputType = {
    orgMembershipId: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMembershipCountAggregateOutputType = {
    orgMembershipId: number
    projectId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMembershipMinAggregateInputType = {
    orgMembershipId?: true
    projectId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMembershipMaxAggregateInputType = {
    orgMembershipId?: true
    projectId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMembershipCountAggregateInputType = {
    orgMembershipId?: true
    projectId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembership to aggregate.
     */
    where?: ProjectMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMemberships to fetch.
     */
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMemberships
    **/
    _count?: true | ProjectMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMembershipMaxAggregateInputType
  }

  export type GetProjectMembershipAggregateType<T extends ProjectMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMembership[P]>
      : GetScalarType<T[P], AggregateProjectMembership[P]>
  }




  export type ProjectMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMembershipWhereInput
    orderBy?: ProjectMembershipOrderByWithAggregationInput | ProjectMembershipOrderByWithAggregationInput[]
    by: ProjectMembershipScalarFieldEnum[] | ProjectMembershipScalarFieldEnum
    having?: ProjectMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMembershipCountAggregateInputType | true
    _min?: ProjectMembershipMinAggregateInputType
    _max?: ProjectMembershipMaxAggregateInputType
  }

  export type ProjectMembershipGroupByOutputType = {
    orgMembershipId: string
    projectId: string
    userId: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: ProjectMembershipCountAggregateOutputType | null
    _min: ProjectMembershipMinAggregateOutputType | null
    _max: ProjectMembershipMaxAggregateOutputType | null
  }

  type GetProjectMembershipGroupByPayload<T extends ProjectMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMembershipGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orgMembershipId?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationMembership?: boolean | OrganizationMembershipDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMembership"]>

  export type ProjectMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orgMembershipId?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationMembership?: boolean | OrganizationMembershipDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMembership"]>

  export type ProjectMembershipSelectScalar = {
    orgMembershipId?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationMembership?: boolean | OrganizationMembershipDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationMembership?: boolean | OrganizationMembershipDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMembership"
    objects: {
      organizationMembership: Prisma.$OrganizationMembershipPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      orgMembershipId: string
      projectId: string
      userId: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectMembership"]>
    composites: {}
  }

  type ProjectMembershipGetPayload<S extends boolean | null | undefined | ProjectMembershipDefaultArgs> = $Result.GetResult<Prisma.$ProjectMembershipPayload, S>

  type ProjectMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ProjectMembershipCountAggregateInputType | true
    }

  export interface ProjectMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMembership'], meta: { name: 'ProjectMembership' } }
    /**
     * Find zero or one ProjectMembership that matches the filter.
     * @param {ProjectMembershipFindUniqueArgs} args - Arguments to find a ProjectMembership
     * @example
     * // Get one ProjectMembership
     * const projectMembership = await prisma.projectMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMembershipFindUniqueArgs>(args: SelectSubset<T, ProjectMembershipFindUniqueArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMembership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMembershipFindUniqueOrThrowArgs} args - Arguments to find a ProjectMembership
     * @example
     * // Get one ProjectMembership
     * const projectMembership = await prisma.projectMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipFindFirstArgs} args - Arguments to find a ProjectMembership
     * @example
     * // Get one ProjectMembership
     * const projectMembership = await prisma.projectMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMembershipFindFirstArgs>(args?: SelectSubset<T, ProjectMembershipFindFirstArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipFindFirstOrThrowArgs} args - Arguments to find a ProjectMembership
     * @example
     * // Get one ProjectMembership
     * const projectMembership = await prisma.projectMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMemberships
     * const projectMemberships = await prisma.projectMembership.findMany()
     * 
     * // Get first 10 ProjectMemberships
     * const projectMemberships = await prisma.projectMembership.findMany({ take: 10 })
     * 
     * // Only select the `orgMembershipId`
     * const projectMembershipWithOrgMembershipIdOnly = await prisma.projectMembership.findMany({ select: { orgMembershipId: true } })
     * 
     */
    findMany<T extends ProjectMembershipFindManyArgs>(args?: SelectSubset<T, ProjectMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMembership.
     * @param {ProjectMembershipCreateArgs} args - Arguments to create a ProjectMembership.
     * @example
     * // Create one ProjectMembership
     * const ProjectMembership = await prisma.projectMembership.create({
     *   data: {
     *     // ... data to create a ProjectMembership
     *   }
     * })
     * 
     */
    create<T extends ProjectMembershipCreateArgs>(args: SelectSubset<T, ProjectMembershipCreateArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMemberships.
     * @param {ProjectMembershipCreateManyArgs} args - Arguments to create many ProjectMemberships.
     * @example
     * // Create many ProjectMemberships
     * const projectMembership = await prisma.projectMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMembershipCreateManyArgs>(args?: SelectSubset<T, ProjectMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMemberships and returns the data saved in the database.
     * @param {ProjectMembershipCreateManyAndReturnArgs} args - Arguments to create many ProjectMemberships.
     * @example
     * // Create many ProjectMemberships
     * const projectMembership = await prisma.projectMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMemberships and only return the `orgMembershipId`
     * const projectMembershipWithOrgMembershipIdOnly = await prisma.projectMembership.createManyAndReturn({ 
     *   select: { orgMembershipId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMembership.
     * @param {ProjectMembershipDeleteArgs} args - Arguments to delete one ProjectMembership.
     * @example
     * // Delete one ProjectMembership
     * const ProjectMembership = await prisma.projectMembership.delete({
     *   where: {
     *     // ... filter to delete one ProjectMembership
     *   }
     * })
     * 
     */
    delete<T extends ProjectMembershipDeleteArgs>(args: SelectSubset<T, ProjectMembershipDeleteArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMembership.
     * @param {ProjectMembershipUpdateArgs} args - Arguments to update one ProjectMembership.
     * @example
     * // Update one ProjectMembership
     * const projectMembership = await prisma.projectMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMembershipUpdateArgs>(args: SelectSubset<T, ProjectMembershipUpdateArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMemberships.
     * @param {ProjectMembershipDeleteManyArgs} args - Arguments to filter ProjectMemberships to delete.
     * @example
     * // Delete a few ProjectMemberships
     * const { count } = await prisma.projectMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMembershipDeleteManyArgs>(args?: SelectSubset<T, ProjectMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMemberships
     * const projectMembership = await prisma.projectMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMembershipUpdateManyArgs>(args: SelectSubset<T, ProjectMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMembership.
     * @param {ProjectMembershipUpsertArgs} args - Arguments to update or create a ProjectMembership.
     * @example
     * // Update or create a ProjectMembership
     * const projectMembership = await prisma.projectMembership.upsert({
     *   create: {
     *     // ... data to create a ProjectMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMembership we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMembershipUpsertArgs>(args: SelectSubset<T, ProjectMembershipUpsertArgs<ExtArgs>>): Prisma__ProjectMembershipClient<$Result.GetResult<Prisma.$ProjectMembershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipCountArgs} args - Arguments to filter ProjectMemberships to count.
     * @example
     * // Count the number of ProjectMemberships
     * const count = await prisma.projectMembership.count({
     *   where: {
     *     // ... the filter for the ProjectMemberships we want to count
     *   }
     * })
    **/
    count<T extends ProjectMembershipCountArgs>(
      args?: Subset<T, ProjectMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMembershipAggregateArgs>(args: Subset<T, ProjectMembershipAggregateArgs>): Prisma.PrismaPromise<GetProjectMembershipAggregateType<T>>

    /**
     * Group by ProjectMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMembershipGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMembership model
   */
  readonly fields: ProjectMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizationMembership<T extends OrganizationMembershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationMembershipDefaultArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMembership model
   */ 
  interface ProjectMembershipFieldRefs {
    readonly orgMembershipId: FieldRef<"ProjectMembership", 'String'>
    readonly projectId: FieldRef<"ProjectMembership", 'String'>
    readonly userId: FieldRef<"ProjectMembership", 'String'>
    readonly role: FieldRef<"ProjectMembership", 'Role'>
    readonly createdAt: FieldRef<"ProjectMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMembership findUnique
   */
  export type ProjectMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembership to fetch.
     */
    where: ProjectMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership findUniqueOrThrow
   */
  export type ProjectMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembership to fetch.
     */
    where: ProjectMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership findFirst
   */
  export type ProjectMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembership to fetch.
     */
    where?: ProjectMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMemberships to fetch.
     */
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMemberships.
     */
    cursor?: ProjectMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMemberships.
     */
    distinct?: ProjectMembershipScalarFieldEnum | ProjectMembershipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership findFirstOrThrow
   */
  export type ProjectMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembership to fetch.
     */
    where?: ProjectMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMemberships to fetch.
     */
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMemberships.
     */
    cursor?: ProjectMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMemberships.
     */
    distinct?: ProjectMembershipScalarFieldEnum | ProjectMembershipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership findMany
   */
  export type ProjectMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMemberships to fetch.
     */
    where?: ProjectMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMemberships to fetch.
     */
    orderBy?: ProjectMembershipOrderByWithRelationInput | ProjectMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMemberships.
     */
    cursor?: ProjectMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMemberships.
     */
    skip?: number
    distinct?: ProjectMembershipScalarFieldEnum | ProjectMembershipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership create
   */
  export type ProjectMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMembership.
     */
    data: XOR<ProjectMembershipCreateInput, ProjectMembershipUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership createMany
   */
  export type ProjectMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMemberships.
     */
    data: ProjectMembershipCreateManyInput | ProjectMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMembership createManyAndReturn
   */
  export type ProjectMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMemberships.
     */
    data: ProjectMembershipCreateManyInput | ProjectMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMembership update
   */
  export type ProjectMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMembership.
     */
    data: XOR<ProjectMembershipUpdateInput, ProjectMembershipUncheckedUpdateInput>
    /**
     * Choose, which ProjectMembership to update.
     */
    where: ProjectMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership updateMany
   */
  export type ProjectMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMemberships.
     */
    data: XOR<ProjectMembershipUpdateManyMutationInput, ProjectMembershipUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMemberships to update
     */
    where?: ProjectMembershipWhereInput
  }

  /**
   * ProjectMembership upsert
   */
  export type ProjectMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMembership to update in case it exists.
     */
    where: ProjectMembershipWhereUniqueInput
    /**
     * In case the ProjectMembership found by the `where` argument doesn't exist, create a new ProjectMembership with this data.
     */
    create: XOR<ProjectMembershipCreateInput, ProjectMembershipUncheckedCreateInput>
    /**
     * In case the ProjectMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMembershipUpdateInput, ProjectMembershipUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership delete
   */
  export type ProjectMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
    /**
     * Filter which ProjectMembership to delete.
     */
    where: ProjectMembershipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProjectMembership deleteMany
   */
  export type ProjectMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMemberships to delete
     */
    where?: ProjectMembershipWhereInput
  }

  /**
   * ProjectMembership without action
   */
  export type ProjectMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMembership
     */
    select?: ProjectMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMembershipInclude<ExtArgs> | null
  }


  /**
   * Model MembershipInvitation
   */

  export type AggregateMembershipInvitation = {
    _count: MembershipInvitationCountAggregateOutputType | null
    _min: MembershipInvitationMinAggregateOutputType | null
    _max: MembershipInvitationMaxAggregateOutputType | null
  }

  export type MembershipInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    orgId: string | null
    orgRole: $Enums.Role | null
    projectId: string | null
    projectRole: $Enums.Role | null
    invitedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    orgId: string | null
    orgRole: $Enums.Role | null
    projectId: string | null
    projectRole: $Enums.Role | null
    invitedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipInvitationCountAggregateOutputType = {
    id: number
    email: number
    orgId: number
    orgRole: number
    projectId: number
    projectRole: number
    invitedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipInvitationMinAggregateInputType = {
    id?: true
    email?: true
    orgId?: true
    orgRole?: true
    projectId?: true
    projectRole?: true
    invitedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipInvitationMaxAggregateInputType = {
    id?: true
    email?: true
    orgId?: true
    orgRole?: true
    projectId?: true
    projectRole?: true
    invitedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipInvitationCountAggregateInputType = {
    id?: true
    email?: true
    orgId?: true
    orgRole?: true
    projectId?: true
    projectRole?: true
    invitedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipInvitation to aggregate.
     */
    where?: MembershipInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipInvitations to fetch.
     */
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipInvitations
    **/
    _count?: true | MembershipInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipInvitationMaxAggregateInputType
  }

  export type GetMembershipInvitationAggregateType<T extends MembershipInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipInvitation[P]>
      : GetScalarType<T[P], AggregateMembershipInvitation[P]>
  }




  export type MembershipInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipInvitationWhereInput
    orderBy?: MembershipInvitationOrderByWithAggregationInput | MembershipInvitationOrderByWithAggregationInput[]
    by: MembershipInvitationScalarFieldEnum[] | MembershipInvitationScalarFieldEnum
    having?: MembershipInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipInvitationCountAggregateInputType | true
    _min?: MembershipInvitationMinAggregateInputType
    _max?: MembershipInvitationMaxAggregateInputType
  }

  export type MembershipInvitationGroupByOutputType = {
    id: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectId: string | null
    projectRole: $Enums.Role | null
    invitedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MembershipInvitationCountAggregateOutputType | null
    _min: MembershipInvitationMinAggregateOutputType | null
    _max: MembershipInvitationMaxAggregateOutputType | null
  }

  type GetMembershipInvitationGroupByPayload<T extends MembershipInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipInvitationGroupByOutputType[P]>
        }
      >
    >


  export type MembershipInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    orgId?: boolean
    orgRole?: boolean
    projectId?: boolean
    projectRole?: boolean
    invitedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | MembershipInvitation$projectArgs<ExtArgs>
    invitedByUser?: boolean | MembershipInvitation$invitedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["membershipInvitation"]>

  export type MembershipInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    orgId?: boolean
    orgRole?: boolean
    projectId?: boolean
    projectRole?: boolean
    invitedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | MembershipInvitation$projectArgs<ExtArgs>
    invitedByUser?: boolean | MembershipInvitation$invitedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["membershipInvitation"]>

  export type MembershipInvitationSelectScalar = {
    id?: boolean
    email?: boolean
    orgId?: boolean
    orgRole?: boolean
    projectId?: boolean
    projectRole?: boolean
    invitedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | MembershipInvitation$projectArgs<ExtArgs>
    invitedByUser?: boolean | MembershipInvitation$invitedByUserArgs<ExtArgs>
  }
  export type MembershipInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | MembershipInvitation$projectArgs<ExtArgs>
    invitedByUser?: boolean | MembershipInvitation$invitedByUserArgs<ExtArgs>
  }

  export type $MembershipInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipInvitation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      invitedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      orgId: string
      orgRole: $Enums.Role
      projectId: string | null
      projectRole: $Enums.Role | null
      invitedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipInvitation"]>
    composites: {}
  }

  type MembershipInvitationGetPayload<S extends boolean | null | undefined | MembershipInvitationDefaultArgs> = $Result.GetResult<Prisma.$MembershipInvitationPayload, S>

  type MembershipInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembershipInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: MembershipInvitationCountAggregateInputType | true
    }

  export interface MembershipInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipInvitation'], meta: { name: 'MembershipInvitation' } }
    /**
     * Find zero or one MembershipInvitation that matches the filter.
     * @param {MembershipInvitationFindUniqueArgs} args - Arguments to find a MembershipInvitation
     * @example
     * // Get one MembershipInvitation
     * const membershipInvitation = await prisma.membershipInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipInvitationFindUniqueArgs>(args: SelectSubset<T, MembershipInvitationFindUniqueArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MembershipInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MembershipInvitationFindUniqueOrThrowArgs} args - Arguments to find a MembershipInvitation
     * @example
     * // Get one MembershipInvitation
     * const membershipInvitation = await prisma.membershipInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MembershipInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationFindFirstArgs} args - Arguments to find a MembershipInvitation
     * @example
     * // Get one MembershipInvitation
     * const membershipInvitation = await prisma.membershipInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipInvitationFindFirstArgs>(args?: SelectSubset<T, MembershipInvitationFindFirstArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MembershipInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationFindFirstOrThrowArgs} args - Arguments to find a MembershipInvitation
     * @example
     * // Get one MembershipInvitation
     * const membershipInvitation = await prisma.membershipInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MembershipInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipInvitations
     * const membershipInvitations = await prisma.membershipInvitation.findMany()
     * 
     * // Get first 10 MembershipInvitations
     * const membershipInvitations = await prisma.membershipInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipInvitationWithIdOnly = await prisma.membershipInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipInvitationFindManyArgs>(args?: SelectSubset<T, MembershipInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MembershipInvitation.
     * @param {MembershipInvitationCreateArgs} args - Arguments to create a MembershipInvitation.
     * @example
     * // Create one MembershipInvitation
     * const MembershipInvitation = await prisma.membershipInvitation.create({
     *   data: {
     *     // ... data to create a MembershipInvitation
     *   }
     * })
     * 
     */
    create<T extends MembershipInvitationCreateArgs>(args: SelectSubset<T, MembershipInvitationCreateArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MembershipInvitations.
     * @param {MembershipInvitationCreateManyArgs} args - Arguments to create many MembershipInvitations.
     * @example
     * // Create many MembershipInvitations
     * const membershipInvitation = await prisma.membershipInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipInvitationCreateManyArgs>(args?: SelectSubset<T, MembershipInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipInvitations and returns the data saved in the database.
     * @param {MembershipInvitationCreateManyAndReturnArgs} args - Arguments to create many MembershipInvitations.
     * @example
     * // Create many MembershipInvitations
     * const membershipInvitation = await prisma.membershipInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipInvitations and only return the `id`
     * const membershipInvitationWithIdOnly = await prisma.membershipInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MembershipInvitation.
     * @param {MembershipInvitationDeleteArgs} args - Arguments to delete one MembershipInvitation.
     * @example
     * // Delete one MembershipInvitation
     * const MembershipInvitation = await prisma.membershipInvitation.delete({
     *   where: {
     *     // ... filter to delete one MembershipInvitation
     *   }
     * })
     * 
     */
    delete<T extends MembershipInvitationDeleteArgs>(args: SelectSubset<T, MembershipInvitationDeleteArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MembershipInvitation.
     * @param {MembershipInvitationUpdateArgs} args - Arguments to update one MembershipInvitation.
     * @example
     * // Update one MembershipInvitation
     * const membershipInvitation = await prisma.membershipInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipInvitationUpdateArgs>(args: SelectSubset<T, MembershipInvitationUpdateArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MembershipInvitations.
     * @param {MembershipInvitationDeleteManyArgs} args - Arguments to filter MembershipInvitations to delete.
     * @example
     * // Delete a few MembershipInvitations
     * const { count } = await prisma.membershipInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipInvitationDeleteManyArgs>(args?: SelectSubset<T, MembershipInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipInvitations
     * const membershipInvitation = await prisma.membershipInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipInvitationUpdateManyArgs>(args: SelectSubset<T, MembershipInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MembershipInvitation.
     * @param {MembershipInvitationUpsertArgs} args - Arguments to update or create a MembershipInvitation.
     * @example
     * // Update or create a MembershipInvitation
     * const membershipInvitation = await prisma.membershipInvitation.upsert({
     *   create: {
     *     // ... data to create a MembershipInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipInvitation we want to update
     *   }
     * })
     */
    upsert<T extends MembershipInvitationUpsertArgs>(args: SelectSubset<T, MembershipInvitationUpsertArgs<ExtArgs>>): Prisma__MembershipInvitationClient<$Result.GetResult<Prisma.$MembershipInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MembershipInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationCountArgs} args - Arguments to filter MembershipInvitations to count.
     * @example
     * // Count the number of MembershipInvitations
     * const count = await prisma.membershipInvitation.count({
     *   where: {
     *     // ... the filter for the MembershipInvitations we want to count
     *   }
     * })
    **/
    count<T extends MembershipInvitationCountArgs>(
      args?: Subset<T, MembershipInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipInvitationAggregateArgs>(args: Subset<T, MembershipInvitationAggregateArgs>): Prisma.PrismaPromise<GetMembershipInvitationAggregateType<T>>

    /**
     * Group by MembershipInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipInvitationGroupByArgs['orderBy'] }
        : { orderBy?: MembershipInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipInvitation model
   */
  readonly fields: MembershipInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends MembershipInvitation$projectArgs<ExtArgs> = {}>(args?: Subset<T, MembershipInvitation$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invitedByUser<T extends MembershipInvitation$invitedByUserArgs<ExtArgs> = {}>(args?: Subset<T, MembershipInvitation$invitedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipInvitation model
   */ 
  interface MembershipInvitationFieldRefs {
    readonly id: FieldRef<"MembershipInvitation", 'String'>
    readonly email: FieldRef<"MembershipInvitation", 'String'>
    readonly orgId: FieldRef<"MembershipInvitation", 'String'>
    readonly orgRole: FieldRef<"MembershipInvitation", 'Role'>
    readonly projectId: FieldRef<"MembershipInvitation", 'String'>
    readonly projectRole: FieldRef<"MembershipInvitation", 'Role'>
    readonly invitedByUserId: FieldRef<"MembershipInvitation", 'String'>
    readonly createdAt: FieldRef<"MembershipInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipInvitation findUnique
   */
  export type MembershipInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * Filter, which MembershipInvitation to fetch.
     */
    where: MembershipInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation findUniqueOrThrow
   */
  export type MembershipInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * Filter, which MembershipInvitation to fetch.
     */
    where: MembershipInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation findFirst
   */
  export type MembershipInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * Filter, which MembershipInvitation to fetch.
     */
    where?: MembershipInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipInvitations to fetch.
     */
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipInvitations.
     */
    cursor?: MembershipInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipInvitations.
     */
    distinct?: MembershipInvitationScalarFieldEnum | MembershipInvitationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation findFirstOrThrow
   */
  export type MembershipInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * Filter, which MembershipInvitation to fetch.
     */
    where?: MembershipInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipInvitations to fetch.
     */
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipInvitations.
     */
    cursor?: MembershipInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipInvitations.
     */
    distinct?: MembershipInvitationScalarFieldEnum | MembershipInvitationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation findMany
   */
  export type MembershipInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * Filter, which MembershipInvitations to fetch.
     */
    where?: MembershipInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipInvitations to fetch.
     */
    orderBy?: MembershipInvitationOrderByWithRelationInput | MembershipInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipInvitations.
     */
    cursor?: MembershipInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipInvitations.
     */
    skip?: number
    distinct?: MembershipInvitationScalarFieldEnum | MembershipInvitationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation create
   */
  export type MembershipInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipInvitation.
     */
    data: XOR<MembershipInvitationCreateInput, MembershipInvitationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation createMany
   */
  export type MembershipInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipInvitations.
     */
    data: MembershipInvitationCreateManyInput | MembershipInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipInvitation createManyAndReturn
   */
  export type MembershipInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MembershipInvitations.
     */
    data: MembershipInvitationCreateManyInput | MembershipInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipInvitation update
   */
  export type MembershipInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipInvitation.
     */
    data: XOR<MembershipInvitationUpdateInput, MembershipInvitationUncheckedUpdateInput>
    /**
     * Choose, which MembershipInvitation to update.
     */
    where: MembershipInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation updateMany
   */
  export type MembershipInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipInvitations.
     */
    data: XOR<MembershipInvitationUpdateManyMutationInput, MembershipInvitationUncheckedUpdateManyInput>
    /**
     * Filter which MembershipInvitations to update
     */
    where?: MembershipInvitationWhereInput
  }

  /**
   * MembershipInvitation upsert
   */
  export type MembershipInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipInvitation to update in case it exists.
     */
    where: MembershipInvitationWhereUniqueInput
    /**
     * In case the MembershipInvitation found by the `where` argument doesn't exist, create a new MembershipInvitation with this data.
     */
    create: XOR<MembershipInvitationCreateInput, MembershipInvitationUncheckedCreateInput>
    /**
     * In case the MembershipInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipInvitationUpdateInput, MembershipInvitationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation delete
   */
  export type MembershipInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
    /**
     * Filter which MembershipInvitation to delete.
     */
    where: MembershipInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MembershipInvitation deleteMany
   */
  export type MembershipInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipInvitations to delete
     */
    where?: MembershipInvitationWhereInput
  }

  /**
   * MembershipInvitation.project
   */
  export type MembershipInvitation$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * MembershipInvitation.invitedByUser
   */
  export type MembershipInvitation$invitedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MembershipInvitation without action
   */
  export type MembershipInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipInvitation
     */
    select?: MembershipInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInvitationInclude<ExtArgs> | null
  }


  /**
   * Model TraceSession
   */

  export type AggregateTraceSession = {
    _count: TraceSessionCountAggregateOutputType | null
    _min: TraceSessionMinAggregateOutputType | null
    _max: TraceSessionMaxAggregateOutputType | null
  }

  export type TraceSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    bookmarked: boolean | null
    public: boolean | null
  }

  export type TraceSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    bookmarked: boolean | null
    public: boolean | null
  }

  export type TraceSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    bookmarked: number
    public: number
    _all: number
  }


  export type TraceSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    bookmarked?: true
    public?: true
  }

  export type TraceSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    bookmarked?: true
    public?: true
  }

  export type TraceSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    bookmarked?: true
    public?: true
    _all?: true
  }

  export type TraceSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceSession to aggregate.
     */
    where?: TraceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceSessions to fetch.
     */
    orderBy?: TraceSessionOrderByWithRelationInput | TraceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraceSessions
    **/
    _count?: true | TraceSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceSessionMaxAggregateInputType
  }

  export type GetTraceSessionAggregateType<T extends TraceSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTraceSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraceSession[P]>
      : GetScalarType<T[P], AggregateTraceSession[P]>
  }




  export type TraceSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceSessionWhereInput
    orderBy?: TraceSessionOrderByWithAggregationInput | TraceSessionOrderByWithAggregationInput[]
    by: TraceSessionScalarFieldEnum[] | TraceSessionScalarFieldEnum
    having?: TraceSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceSessionCountAggregateInputType | true
    _min?: TraceSessionMinAggregateInputType
    _max?: TraceSessionMaxAggregateInputType
  }

  export type TraceSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    bookmarked: boolean
    public: boolean
    _count: TraceSessionCountAggregateOutputType | null
    _min: TraceSessionMinAggregateOutputType | null
    _max: TraceSessionMaxAggregateOutputType | null
  }

  type GetTraceSessionGroupByPayload<T extends TraceSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraceSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TraceSessionGroupByOutputType[P]>
        }
      >
    >


  export type TraceSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    bookmarked?: boolean
    public?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    traces?: boolean | TraceSession$tracesArgs<ExtArgs>
    _count?: boolean | TraceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traceSession"]>

  export type TraceSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    bookmarked?: boolean
    public?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traceSession"]>

  export type TraceSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    bookmarked?: boolean
    public?: boolean
  }

  export type TraceSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    traces?: boolean | TraceSession$tracesArgs<ExtArgs>
    _count?: boolean | TraceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TraceSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TraceSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraceSession"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      traces: Prisma.$TracePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      bookmarked: boolean
      public: boolean
    }, ExtArgs["result"]["traceSession"]>
    composites: {}
  }

  type TraceSessionGetPayload<S extends boolean | null | undefined | TraceSessionDefaultArgs> = $Result.GetResult<Prisma.$TraceSessionPayload, S>

  type TraceSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TraceSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TraceSessionCountAggregateInputType | true
    }

  export interface TraceSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraceSession'], meta: { name: 'TraceSession' } }
    /**
     * Find zero or one TraceSession that matches the filter.
     * @param {TraceSessionFindUniqueArgs} args - Arguments to find a TraceSession
     * @example
     * // Get one TraceSession
     * const traceSession = await prisma.traceSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraceSessionFindUniqueArgs>(args: SelectSubset<T, TraceSessionFindUniqueArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TraceSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TraceSessionFindUniqueOrThrowArgs} args - Arguments to find a TraceSession
     * @example
     * // Get one TraceSession
     * const traceSession = await prisma.traceSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraceSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TraceSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TraceSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionFindFirstArgs} args - Arguments to find a TraceSession
     * @example
     * // Get one TraceSession
     * const traceSession = await prisma.traceSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraceSessionFindFirstArgs>(args?: SelectSubset<T, TraceSessionFindFirstArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TraceSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionFindFirstOrThrowArgs} args - Arguments to find a TraceSession
     * @example
     * // Get one TraceSession
     * const traceSession = await prisma.traceSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraceSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TraceSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TraceSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraceSessions
     * const traceSessions = await prisma.traceSession.findMany()
     * 
     * // Get first 10 TraceSessions
     * const traceSessions = await prisma.traceSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traceSessionWithIdOnly = await prisma.traceSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraceSessionFindManyArgs>(args?: SelectSubset<T, TraceSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TraceSession.
     * @param {TraceSessionCreateArgs} args - Arguments to create a TraceSession.
     * @example
     * // Create one TraceSession
     * const TraceSession = await prisma.traceSession.create({
     *   data: {
     *     // ... data to create a TraceSession
     *   }
     * })
     * 
     */
    create<T extends TraceSessionCreateArgs>(args: SelectSubset<T, TraceSessionCreateArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TraceSessions.
     * @param {TraceSessionCreateManyArgs} args - Arguments to create many TraceSessions.
     * @example
     * // Create many TraceSessions
     * const traceSession = await prisma.traceSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraceSessionCreateManyArgs>(args?: SelectSubset<T, TraceSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TraceSessions and returns the data saved in the database.
     * @param {TraceSessionCreateManyAndReturnArgs} args - Arguments to create many TraceSessions.
     * @example
     * // Create many TraceSessions
     * const traceSession = await prisma.traceSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TraceSessions and only return the `id`
     * const traceSessionWithIdOnly = await prisma.traceSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraceSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TraceSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TraceSession.
     * @param {TraceSessionDeleteArgs} args - Arguments to delete one TraceSession.
     * @example
     * // Delete one TraceSession
     * const TraceSession = await prisma.traceSession.delete({
     *   where: {
     *     // ... filter to delete one TraceSession
     *   }
     * })
     * 
     */
    delete<T extends TraceSessionDeleteArgs>(args: SelectSubset<T, TraceSessionDeleteArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TraceSession.
     * @param {TraceSessionUpdateArgs} args - Arguments to update one TraceSession.
     * @example
     * // Update one TraceSession
     * const traceSession = await prisma.traceSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraceSessionUpdateArgs>(args: SelectSubset<T, TraceSessionUpdateArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TraceSessions.
     * @param {TraceSessionDeleteManyArgs} args - Arguments to filter TraceSessions to delete.
     * @example
     * // Delete a few TraceSessions
     * const { count } = await prisma.traceSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraceSessionDeleteManyArgs>(args?: SelectSubset<T, TraceSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraceSessions
     * const traceSession = await prisma.traceSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraceSessionUpdateManyArgs>(args: SelectSubset<T, TraceSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TraceSession.
     * @param {TraceSessionUpsertArgs} args - Arguments to update or create a TraceSession.
     * @example
     * // Update or create a TraceSession
     * const traceSession = await prisma.traceSession.upsert({
     *   create: {
     *     // ... data to create a TraceSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraceSession we want to update
     *   }
     * })
     */
    upsert<T extends TraceSessionUpsertArgs>(args: SelectSubset<T, TraceSessionUpsertArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TraceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionCountArgs} args - Arguments to filter TraceSessions to count.
     * @example
     * // Count the number of TraceSessions
     * const count = await prisma.traceSession.count({
     *   where: {
     *     // ... the filter for the TraceSessions we want to count
     *   }
     * })
    **/
    count<T extends TraceSessionCountArgs>(
      args?: Subset<T, TraceSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceSessionAggregateArgs>(args: Subset<T, TraceSessionAggregateArgs>): Prisma.PrismaPromise<GetTraceSessionAggregateType<T>>

    /**
     * Group by TraceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceSessionGroupByArgs['orderBy'] }
        : { orderBy?: TraceSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraceSession model
   */
  readonly fields: TraceSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraceSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraceSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    traces<T extends TraceSession$tracesArgs<ExtArgs> = {}>(args?: Subset<T, TraceSession$tracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraceSession model
   */ 
  interface TraceSessionFieldRefs {
    readonly id: FieldRef<"TraceSession", 'String'>
    readonly createdAt: FieldRef<"TraceSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TraceSession", 'DateTime'>
    readonly projectId: FieldRef<"TraceSession", 'String'>
    readonly bookmarked: FieldRef<"TraceSession", 'Boolean'>
    readonly public: FieldRef<"TraceSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TraceSession findUnique
   */
  export type TraceSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * Filter, which TraceSession to fetch.
     */
    where: TraceSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession findUniqueOrThrow
   */
  export type TraceSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * Filter, which TraceSession to fetch.
     */
    where: TraceSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession findFirst
   */
  export type TraceSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * Filter, which TraceSession to fetch.
     */
    where?: TraceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceSessions to fetch.
     */
    orderBy?: TraceSessionOrderByWithRelationInput | TraceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceSessions.
     */
    cursor?: TraceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceSessions.
     */
    distinct?: TraceSessionScalarFieldEnum | TraceSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession findFirstOrThrow
   */
  export type TraceSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * Filter, which TraceSession to fetch.
     */
    where?: TraceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceSessions to fetch.
     */
    orderBy?: TraceSessionOrderByWithRelationInput | TraceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceSessions.
     */
    cursor?: TraceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceSessions.
     */
    distinct?: TraceSessionScalarFieldEnum | TraceSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession findMany
   */
  export type TraceSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * Filter, which TraceSessions to fetch.
     */
    where?: TraceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceSessions to fetch.
     */
    orderBy?: TraceSessionOrderByWithRelationInput | TraceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraceSessions.
     */
    cursor?: TraceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceSessions.
     */
    skip?: number
    distinct?: TraceSessionScalarFieldEnum | TraceSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession create
   */
  export type TraceSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TraceSession.
     */
    data: XOR<TraceSessionCreateInput, TraceSessionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession createMany
   */
  export type TraceSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraceSessions.
     */
    data: TraceSessionCreateManyInput | TraceSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraceSession createManyAndReturn
   */
  export type TraceSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TraceSessions.
     */
    data: TraceSessionCreateManyInput | TraceSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TraceSession update
   */
  export type TraceSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TraceSession.
     */
    data: XOR<TraceSessionUpdateInput, TraceSessionUncheckedUpdateInput>
    /**
     * Choose, which TraceSession to update.
     */
    where: TraceSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession updateMany
   */
  export type TraceSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraceSessions.
     */
    data: XOR<TraceSessionUpdateManyMutationInput, TraceSessionUncheckedUpdateManyInput>
    /**
     * Filter which TraceSessions to update
     */
    where?: TraceSessionWhereInput
  }

  /**
   * TraceSession upsert
   */
  export type TraceSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TraceSession to update in case it exists.
     */
    where: TraceSessionWhereUniqueInput
    /**
     * In case the TraceSession found by the `where` argument doesn't exist, create a new TraceSession with this data.
     */
    create: XOR<TraceSessionCreateInput, TraceSessionUncheckedCreateInput>
    /**
     * In case the TraceSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraceSessionUpdateInput, TraceSessionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession delete
   */
  export type TraceSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    /**
     * Filter which TraceSession to delete.
     */
    where: TraceSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceSession deleteMany
   */
  export type TraceSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceSessions to delete
     */
    where?: TraceSessionWhereInput
  }

  /**
   * TraceSession.traces
   */
  export type TraceSession$tracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    where?: TraceWhereInput
    orderBy?: TraceOrderByWithRelationInput | TraceOrderByWithRelationInput[]
    cursor?: TraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraceScalarFieldEnum | TraceScalarFieldEnum[]
  }

  /**
   * TraceSession without action
   */
  export type TraceSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
  }


  /**
   * Model Trace
   */

  export type AggregateTrace = {
    _count: TraceCountAggregateOutputType | null
    _min: TraceMinAggregateOutputType | null
    _max: TraceMaxAggregateOutputType | null
  }

  export type TraceMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    timestamp: Date | null
    name: string | null
    userId: string | null
    release: string | null
    version: string | null
    projectId: string | null
    public: boolean | null
    bookmarked: boolean | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TraceMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    timestamp: Date | null
    name: string | null
    userId: string | null
    release: string | null
    version: string | null
    projectId: string | null
    public: boolean | null
    bookmarked: boolean | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TraceCountAggregateOutputType = {
    id: number
    externalId: number
    timestamp: number
    name: number
    userId: number
    metadata: number
    release: number
    version: number
    projectId: number
    public: number
    bookmarked: number
    tags: number
    input: number
    output: number
    sessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TraceMinAggregateInputType = {
    id?: true
    externalId?: true
    timestamp?: true
    name?: true
    userId?: true
    release?: true
    version?: true
    projectId?: true
    public?: true
    bookmarked?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TraceMaxAggregateInputType = {
    id?: true
    externalId?: true
    timestamp?: true
    name?: true
    userId?: true
    release?: true
    version?: true
    projectId?: true
    public?: true
    bookmarked?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TraceCountAggregateInputType = {
    id?: true
    externalId?: true
    timestamp?: true
    name?: true
    userId?: true
    metadata?: true
    release?: true
    version?: true
    projectId?: true
    public?: true
    bookmarked?: true
    tags?: true
    input?: true
    output?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TraceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trace to aggregate.
     */
    where?: TraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traces to fetch.
     */
    orderBy?: TraceOrderByWithRelationInput | TraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Traces
    **/
    _count?: true | TraceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceMaxAggregateInputType
  }

  export type GetTraceAggregateType<T extends TraceAggregateArgs> = {
        [P in keyof T & keyof AggregateTrace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrace[P]>
      : GetScalarType<T[P], AggregateTrace[P]>
  }




  export type TraceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceWhereInput
    orderBy?: TraceOrderByWithAggregationInput | TraceOrderByWithAggregationInput[]
    by: TraceScalarFieldEnum[] | TraceScalarFieldEnum
    having?: TraceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceCountAggregateInputType | true
    _min?: TraceMinAggregateInputType
    _max?: TraceMaxAggregateInputType
  }

  export type TraceGroupByOutputType = {
    id: string
    externalId: string | null
    timestamp: Date
    name: string | null
    userId: string | null
    metadata: JsonValue | null
    release: string | null
    version: string | null
    projectId: string
    public: boolean
    bookmarked: boolean
    tags: string[]
    input: JsonValue | null
    output: JsonValue | null
    sessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TraceCountAggregateOutputType | null
    _min: TraceMinAggregateOutputType | null
    _max: TraceMaxAggregateOutputType | null
  }

  type GetTraceGroupByPayload<T extends TraceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceGroupByOutputType[P]>
            : GetScalarType<T[P], TraceGroupByOutputType[P]>
        }
      >
    >


  export type TraceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    timestamp?: boolean
    name?: boolean
    userId?: boolean
    metadata?: boolean
    release?: boolean
    version?: boolean
    projectId?: boolean
    public?: boolean
    bookmarked?: boolean
    tags?: boolean
    input?: boolean
    output?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    session?: boolean | Trace$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["trace"]>

  export type TraceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    timestamp?: boolean
    name?: boolean
    userId?: boolean
    metadata?: boolean
    release?: boolean
    version?: boolean
    projectId?: boolean
    public?: boolean
    bookmarked?: boolean
    tags?: boolean
    input?: boolean
    output?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    session?: boolean | Trace$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["trace"]>

  export type TraceSelectScalar = {
    id?: boolean
    externalId?: boolean
    timestamp?: boolean
    name?: boolean
    userId?: boolean
    metadata?: boolean
    release?: boolean
    version?: boolean
    projectId?: boolean
    public?: boolean
    bookmarked?: boolean
    tags?: boolean
    input?: boolean
    output?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TraceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    session?: boolean | Trace$sessionArgs<ExtArgs>
  }
  export type TraceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    session?: boolean | Trace$sessionArgs<ExtArgs>
  }

  export type $TracePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trace"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      session: Prisma.$TraceSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      timestamp: Date
      name: string | null
      userId: string | null
      metadata: Prisma.JsonValue | null
      release: string | null
      version: string | null
      projectId: string
      public: boolean
      bookmarked: boolean
      tags: string[]
      input: Prisma.JsonValue | null
      output: Prisma.JsonValue | null
      sessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trace"]>
    composites: {}
  }

  type TraceGetPayload<S extends boolean | null | undefined | TraceDefaultArgs> = $Result.GetResult<Prisma.$TracePayload, S>

  type TraceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TraceFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TraceCountAggregateInputType | true
    }

  export interface TraceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trace'], meta: { name: 'Trace' } }
    /**
     * Find zero or one Trace that matches the filter.
     * @param {TraceFindUniqueArgs} args - Arguments to find a Trace
     * @example
     * // Get one Trace
     * const trace = await prisma.trace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraceFindUniqueArgs>(args: SelectSubset<T, TraceFindUniqueArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TraceFindUniqueOrThrowArgs} args - Arguments to find a Trace
     * @example
     * // Get one Trace
     * const trace = await prisma.trace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraceFindUniqueOrThrowArgs>(args: SelectSubset<T, TraceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceFindFirstArgs} args - Arguments to find a Trace
     * @example
     * // Get one Trace
     * const trace = await prisma.trace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraceFindFirstArgs>(args?: SelectSubset<T, TraceFindFirstArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceFindFirstOrThrowArgs} args - Arguments to find a Trace
     * @example
     * // Get one Trace
     * const trace = await prisma.trace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraceFindFirstOrThrowArgs>(args?: SelectSubset<T, TraceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Traces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Traces
     * const traces = await prisma.trace.findMany()
     * 
     * // Get first 10 Traces
     * const traces = await prisma.trace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traceWithIdOnly = await prisma.trace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraceFindManyArgs>(args?: SelectSubset<T, TraceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trace.
     * @param {TraceCreateArgs} args - Arguments to create a Trace.
     * @example
     * // Create one Trace
     * const Trace = await prisma.trace.create({
     *   data: {
     *     // ... data to create a Trace
     *   }
     * })
     * 
     */
    create<T extends TraceCreateArgs>(args: SelectSubset<T, TraceCreateArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Traces.
     * @param {TraceCreateManyArgs} args - Arguments to create many Traces.
     * @example
     * // Create many Traces
     * const trace = await prisma.trace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraceCreateManyArgs>(args?: SelectSubset<T, TraceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Traces and returns the data saved in the database.
     * @param {TraceCreateManyAndReturnArgs} args - Arguments to create many Traces.
     * @example
     * // Create many Traces
     * const trace = await prisma.trace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Traces and only return the `id`
     * const traceWithIdOnly = await prisma.trace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraceCreateManyAndReturnArgs>(args?: SelectSubset<T, TraceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trace.
     * @param {TraceDeleteArgs} args - Arguments to delete one Trace.
     * @example
     * // Delete one Trace
     * const Trace = await prisma.trace.delete({
     *   where: {
     *     // ... filter to delete one Trace
     *   }
     * })
     * 
     */
    delete<T extends TraceDeleteArgs>(args: SelectSubset<T, TraceDeleteArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trace.
     * @param {TraceUpdateArgs} args - Arguments to update one Trace.
     * @example
     * // Update one Trace
     * const trace = await prisma.trace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraceUpdateArgs>(args: SelectSubset<T, TraceUpdateArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Traces.
     * @param {TraceDeleteManyArgs} args - Arguments to filter Traces to delete.
     * @example
     * // Delete a few Traces
     * const { count } = await prisma.trace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraceDeleteManyArgs>(args?: SelectSubset<T, TraceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Traces
     * const trace = await prisma.trace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraceUpdateManyArgs>(args: SelectSubset<T, TraceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trace.
     * @param {TraceUpsertArgs} args - Arguments to update or create a Trace.
     * @example
     * // Update or create a Trace
     * const trace = await prisma.trace.upsert({
     *   create: {
     *     // ... data to create a Trace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trace we want to update
     *   }
     * })
     */
    upsert<T extends TraceUpsertArgs>(args: SelectSubset<T, TraceUpsertArgs<ExtArgs>>): Prisma__TraceClient<$Result.GetResult<Prisma.$TracePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Traces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceCountArgs} args - Arguments to filter Traces to count.
     * @example
     * // Count the number of Traces
     * const count = await prisma.trace.count({
     *   where: {
     *     // ... the filter for the Traces we want to count
     *   }
     * })
    **/
    count<T extends TraceCountArgs>(
      args?: Subset<T, TraceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceAggregateArgs>(args: Subset<T, TraceAggregateArgs>): Prisma.PrismaPromise<GetTraceAggregateType<T>>

    /**
     * Group by Trace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceGroupByArgs['orderBy'] }
        : { orderBy?: TraceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trace model
   */
  readonly fields: TraceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends Trace$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Trace$sessionArgs<ExtArgs>>): Prisma__TraceSessionClient<$Result.GetResult<Prisma.$TraceSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trace model
   */ 
  interface TraceFieldRefs {
    readonly id: FieldRef<"Trace", 'String'>
    readonly externalId: FieldRef<"Trace", 'String'>
    readonly timestamp: FieldRef<"Trace", 'DateTime'>
    readonly name: FieldRef<"Trace", 'String'>
    readonly userId: FieldRef<"Trace", 'String'>
    readonly metadata: FieldRef<"Trace", 'Json'>
    readonly release: FieldRef<"Trace", 'String'>
    readonly version: FieldRef<"Trace", 'String'>
    readonly projectId: FieldRef<"Trace", 'String'>
    readonly public: FieldRef<"Trace", 'Boolean'>
    readonly bookmarked: FieldRef<"Trace", 'Boolean'>
    readonly tags: FieldRef<"Trace", 'String[]'>
    readonly input: FieldRef<"Trace", 'Json'>
    readonly output: FieldRef<"Trace", 'Json'>
    readonly sessionId: FieldRef<"Trace", 'String'>
    readonly createdAt: FieldRef<"Trace", 'DateTime'>
    readonly updatedAt: FieldRef<"Trace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trace findUnique
   */
  export type TraceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * Filter, which Trace to fetch.
     */
    where: TraceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace findUniqueOrThrow
   */
  export type TraceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * Filter, which Trace to fetch.
     */
    where: TraceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace findFirst
   */
  export type TraceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * Filter, which Trace to fetch.
     */
    where?: TraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traces to fetch.
     */
    orderBy?: TraceOrderByWithRelationInput | TraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traces.
     */
    cursor?: TraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traces.
     */
    distinct?: TraceScalarFieldEnum | TraceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace findFirstOrThrow
   */
  export type TraceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * Filter, which Trace to fetch.
     */
    where?: TraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traces to fetch.
     */
    orderBy?: TraceOrderByWithRelationInput | TraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traces.
     */
    cursor?: TraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traces.
     */
    distinct?: TraceScalarFieldEnum | TraceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace findMany
   */
  export type TraceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * Filter, which Traces to fetch.
     */
    where?: TraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traces to fetch.
     */
    orderBy?: TraceOrderByWithRelationInput | TraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Traces.
     */
    cursor?: TraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traces.
     */
    skip?: number
    distinct?: TraceScalarFieldEnum | TraceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace create
   */
  export type TraceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * The data needed to create a Trace.
     */
    data: XOR<TraceCreateInput, TraceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace createMany
   */
  export type TraceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Traces.
     */
    data: TraceCreateManyInput | TraceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trace createManyAndReturn
   */
  export type TraceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Traces.
     */
    data: TraceCreateManyInput | TraceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trace update
   */
  export type TraceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * The data needed to update a Trace.
     */
    data: XOR<TraceUpdateInput, TraceUncheckedUpdateInput>
    /**
     * Choose, which Trace to update.
     */
    where: TraceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace updateMany
   */
  export type TraceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Traces.
     */
    data: XOR<TraceUpdateManyMutationInput, TraceUncheckedUpdateManyInput>
    /**
     * Filter which Traces to update
     */
    where?: TraceWhereInput
  }

  /**
   * Trace upsert
   */
  export type TraceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * The filter to search for the Trace to update in case it exists.
     */
    where: TraceWhereUniqueInput
    /**
     * In case the Trace found by the `where` argument doesn't exist, create a new Trace with this data.
     */
    create: XOR<TraceCreateInput, TraceUncheckedCreateInput>
    /**
     * In case the Trace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraceUpdateInput, TraceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace delete
   */
  export type TraceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
    /**
     * Filter which Trace to delete.
     */
    where: TraceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Trace deleteMany
   */
  export type TraceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Traces to delete
     */
    where?: TraceWhereInput
  }

  /**
   * Trace.session
   */
  export type Trace$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceSession
     */
    select?: TraceSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceSessionInclude<ExtArgs> | null
    where?: TraceSessionWhereInput
  }

  /**
   * Trace without action
   */
  export type TraceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trace
     */
    select?: TraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceInclude<ExtArgs> | null
  }


  /**
   * Model Observation
   */

  export type AggregateObservation = {
    _count: ObservationCountAggregateOutputType | null
    _avg: ObservationAvgAggregateOutputType | null
    _sum: ObservationSumAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  export type ObservationAvgAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    totalCost: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
  }

  export type ObservationSumAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    totalCost: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
  }

  export type ObservationMinAggregateOutputType = {
    id: string | null
    traceId: string | null
    projectId: string | null
    type: $Enums.ObservationType | null
    startTime: Date | null
    endTime: Date | null
    name: string | null
    parentObservationId: string | null
    level: $Enums.ObservationLevel | null
    statusMessage: string | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    model: string | null
    internalModel: string | null
    internalModelId: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    unit: string | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    totalCost: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    completionStartTime: Date | null
    promptId: string | null
  }

  export type ObservationMaxAggregateOutputType = {
    id: string | null
    traceId: string | null
    projectId: string | null
    type: $Enums.ObservationType | null
    startTime: Date | null
    endTime: Date | null
    name: string | null
    parentObservationId: string | null
    level: $Enums.ObservationLevel | null
    statusMessage: string | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    model: string | null
    internalModel: string | null
    internalModelId: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    unit: string | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    totalCost: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    completionStartTime: Date | null
    promptId: string | null
  }

  export type ObservationCountAggregateOutputType = {
    id: number
    traceId: number
    projectId: number
    type: number
    startTime: number
    endTime: number
    name: number
    metadata: number
    parentObservationId: number
    level: number
    statusMessage: number
    version: number
    createdAt: number
    updatedAt: number
    model: number
    internalModel: number
    internalModelId: number
    modelParameters: number
    input: number
    output: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    unit: number
    inputCost: number
    outputCost: number
    totalCost: number
    calculatedInputCost: number
    calculatedOutputCost: number
    calculatedTotalCost: number
    completionStartTime: number
    promptId: number
    _all: number
  }


  export type ObservationAvgAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    inputCost?: true
    outputCost?: true
    totalCost?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
  }

  export type ObservationSumAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    inputCost?: true
    outputCost?: true
    totalCost?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
  }

  export type ObservationMinAggregateInputType = {
    id?: true
    traceId?: true
    projectId?: true
    type?: true
    startTime?: true
    endTime?: true
    name?: true
    parentObservationId?: true
    level?: true
    statusMessage?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    model?: true
    internalModel?: true
    internalModelId?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    unit?: true
    inputCost?: true
    outputCost?: true
    totalCost?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    completionStartTime?: true
    promptId?: true
  }

  export type ObservationMaxAggregateInputType = {
    id?: true
    traceId?: true
    projectId?: true
    type?: true
    startTime?: true
    endTime?: true
    name?: true
    parentObservationId?: true
    level?: true
    statusMessage?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    model?: true
    internalModel?: true
    internalModelId?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    unit?: true
    inputCost?: true
    outputCost?: true
    totalCost?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    completionStartTime?: true
    promptId?: true
  }

  export type ObservationCountAggregateInputType = {
    id?: true
    traceId?: true
    projectId?: true
    type?: true
    startTime?: true
    endTime?: true
    name?: true
    metadata?: true
    parentObservationId?: true
    level?: true
    statusMessage?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    model?: true
    internalModel?: true
    internalModelId?: true
    modelParameters?: true
    input?: true
    output?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    unit?: true
    inputCost?: true
    outputCost?: true
    totalCost?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    completionStartTime?: true
    promptId?: true
    _all?: true
  }

  export type ObservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observation to aggregate.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Observations
    **/
    _count?: true | ObservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationMaxAggregateInputType
  }

  export type GetObservationAggregateType<T extends ObservationAggregateArgs> = {
        [P in keyof T & keyof AggregateObservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservation[P]>
      : GetScalarType<T[P], AggregateObservation[P]>
  }




  export type ObservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithAggregationInput | ObservationOrderByWithAggregationInput[]
    by: ObservationScalarFieldEnum[] | ObservationScalarFieldEnum
    having?: ObservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationCountAggregateInputType | true
    _avg?: ObservationAvgAggregateInputType
    _sum?: ObservationSumAggregateInputType
    _min?: ObservationMinAggregateInputType
    _max?: ObservationMaxAggregateInputType
  }

  export type ObservationGroupByOutputType = {
    id: string
    traceId: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime: Date
    endTime: Date | null
    name: string | null
    metadata: JsonValue | null
    parentObservationId: string | null
    level: $Enums.ObservationLevel
    statusMessage: string | null
    version: string | null
    createdAt: Date
    updatedAt: Date
    model: string | null
    internalModel: string | null
    internalModelId: string | null
    modelParameters: JsonValue | null
    input: JsonValue | null
    output: JsonValue | null
    promptTokens: number
    completionTokens: number
    totalTokens: number
    unit: string | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    totalCost: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    completionStartTime: Date | null
    promptId: string | null
    _count: ObservationCountAggregateOutputType | null
    _avg: ObservationAvgAggregateOutputType | null
    _sum: ObservationSumAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  type GetObservationGroupByPayload<T extends ObservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationGroupByOutputType[P]>
        }
      >
    >


  export type ObservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    projectId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    name?: boolean
    metadata?: boolean
    parentObservationId?: boolean
    level?: boolean
    statusMessage?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean
    internalModel?: boolean
    internalModelId?: boolean
    modelParameters?: boolean
    input?: boolean
    output?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    unit?: boolean
    inputCost?: boolean
    outputCost?: boolean
    totalCost?: boolean
    calculatedInputCost?: boolean
    calculatedOutputCost?: boolean
    calculatedTotalCost?: boolean
    completionStartTime?: boolean
    promptId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    projectId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    name?: boolean
    metadata?: boolean
    parentObservationId?: boolean
    level?: boolean
    statusMessage?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean
    internalModel?: boolean
    internalModelId?: boolean
    modelParameters?: boolean
    input?: boolean
    output?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    unit?: boolean
    inputCost?: boolean
    outputCost?: boolean
    totalCost?: boolean
    calculatedInputCost?: boolean
    calculatedOutputCost?: boolean
    calculatedTotalCost?: boolean
    completionStartTime?: boolean
    promptId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectScalar = {
    id?: boolean
    traceId?: boolean
    projectId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    name?: boolean
    metadata?: boolean
    parentObservationId?: boolean
    level?: boolean
    statusMessage?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean
    internalModel?: boolean
    internalModelId?: boolean
    modelParameters?: boolean
    input?: boolean
    output?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    unit?: boolean
    inputCost?: boolean
    outputCost?: boolean
    totalCost?: boolean
    calculatedInputCost?: boolean
    calculatedOutputCost?: boolean
    calculatedTotalCost?: boolean
    completionStartTime?: boolean
    promptId?: boolean
  }

  export type ObservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ObservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ObservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Observation"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      traceId: string | null
      projectId: string
      type: $Enums.ObservationType
      startTime: Date
      endTime: Date | null
      name: string | null
      metadata: Prisma.JsonValue | null
      parentObservationId: string | null
      level: $Enums.ObservationLevel
      statusMessage: string | null
      version: string | null
      createdAt: Date
      updatedAt: Date
      model: string | null
      internalModel: string | null
      internalModelId: string | null
      modelParameters: Prisma.JsonValue | null
      input: Prisma.JsonValue | null
      output: Prisma.JsonValue | null
      promptTokens: number
      completionTokens: number
      totalTokens: number
      unit: string | null
      inputCost: Prisma.Decimal | null
      outputCost: Prisma.Decimal | null
      totalCost: Prisma.Decimal | null
      calculatedInputCost: Prisma.Decimal | null
      calculatedOutputCost: Prisma.Decimal | null
      calculatedTotalCost: Prisma.Decimal | null
      completionStartTime: Date | null
      promptId: string | null
    }, ExtArgs["result"]["observation"]>
    composites: {}
  }

  type ObservationGetPayload<S extends boolean | null | undefined | ObservationDefaultArgs> = $Result.GetResult<Prisma.$ObservationPayload, S>

  type ObservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObservationFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ObservationCountAggregateInputType | true
    }

  export interface ObservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Observation'], meta: { name: 'Observation' } }
    /**
     * Find zero or one Observation that matches the filter.
     * @param {ObservationFindUniqueArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationFindUniqueArgs>(args: SelectSubset<T, ObservationFindUniqueArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Observation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObservationFindUniqueOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Observation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationFindFirstArgs>(args?: SelectSubset<T, ObservationFindFirstArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Observation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Observations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Observations
     * const observations = await prisma.observation.findMany()
     * 
     * // Get first 10 Observations
     * const observations = await prisma.observation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationWithIdOnly = await prisma.observation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationFindManyArgs>(args?: SelectSubset<T, ObservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Observation.
     * @param {ObservationCreateArgs} args - Arguments to create a Observation.
     * @example
     * // Create one Observation
     * const Observation = await prisma.observation.create({
     *   data: {
     *     // ... data to create a Observation
     *   }
     * })
     * 
     */
    create<T extends ObservationCreateArgs>(args: SelectSubset<T, ObservationCreateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Observations.
     * @param {ObservationCreateManyArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationCreateManyArgs>(args?: SelectSubset<T, ObservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Observations and returns the data saved in the database.
     * @param {ObservationCreateManyAndReturnArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Observations and only return the `id`
     * const observationWithIdOnly = await prisma.observation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ObservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Observation.
     * @param {ObservationDeleteArgs} args - Arguments to delete one Observation.
     * @example
     * // Delete one Observation
     * const Observation = await prisma.observation.delete({
     *   where: {
     *     // ... filter to delete one Observation
     *   }
     * })
     * 
     */
    delete<T extends ObservationDeleteArgs>(args: SelectSubset<T, ObservationDeleteArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Observation.
     * @param {ObservationUpdateArgs} args - Arguments to update one Observation.
     * @example
     * // Update one Observation
     * const observation = await prisma.observation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationUpdateArgs>(args: SelectSubset<T, ObservationUpdateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Observations.
     * @param {ObservationDeleteManyArgs} args - Arguments to filter Observations to delete.
     * @example
     * // Delete a few Observations
     * const { count } = await prisma.observation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationDeleteManyArgs>(args?: SelectSubset<T, ObservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Observations
     * const observation = await prisma.observation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationUpdateManyArgs>(args: SelectSubset<T, ObservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Observation.
     * @param {ObservationUpsertArgs} args - Arguments to update or create a Observation.
     * @example
     * // Update or create a Observation
     * const observation = await prisma.observation.upsert({
     *   create: {
     *     // ... data to create a Observation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Observation we want to update
     *   }
     * })
     */
    upsert<T extends ObservationUpsertArgs>(args: SelectSubset<T, ObservationUpsertArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationCountArgs} args - Arguments to filter Observations to count.
     * @example
     * // Count the number of Observations
     * const count = await prisma.observation.count({
     *   where: {
     *     // ... the filter for the Observations we want to count
     *   }
     * })
    **/
    count<T extends ObservationCountArgs>(
      args?: Subset<T, ObservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationAggregateArgs>(args: Subset<T, ObservationAggregateArgs>): Prisma.PrismaPromise<GetObservationAggregateType<T>>

    /**
     * Group by Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationGroupByArgs['orderBy'] }
        : { orderBy?: ObservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Observation model
   */
  readonly fields: ObservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Observation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Observation model
   */ 
  interface ObservationFieldRefs {
    readonly id: FieldRef<"Observation", 'String'>
    readonly traceId: FieldRef<"Observation", 'String'>
    readonly projectId: FieldRef<"Observation", 'String'>
    readonly type: FieldRef<"Observation", 'ObservationType'>
    readonly startTime: FieldRef<"Observation", 'DateTime'>
    readonly endTime: FieldRef<"Observation", 'DateTime'>
    readonly name: FieldRef<"Observation", 'String'>
    readonly metadata: FieldRef<"Observation", 'Json'>
    readonly parentObservationId: FieldRef<"Observation", 'String'>
    readonly level: FieldRef<"Observation", 'ObservationLevel'>
    readonly statusMessage: FieldRef<"Observation", 'String'>
    readonly version: FieldRef<"Observation", 'String'>
    readonly createdAt: FieldRef<"Observation", 'DateTime'>
    readonly updatedAt: FieldRef<"Observation", 'DateTime'>
    readonly model: FieldRef<"Observation", 'String'>
    readonly internalModel: FieldRef<"Observation", 'String'>
    readonly internalModelId: FieldRef<"Observation", 'String'>
    readonly modelParameters: FieldRef<"Observation", 'Json'>
    readonly input: FieldRef<"Observation", 'Json'>
    readonly output: FieldRef<"Observation", 'Json'>
    readonly promptTokens: FieldRef<"Observation", 'Int'>
    readonly completionTokens: FieldRef<"Observation", 'Int'>
    readonly totalTokens: FieldRef<"Observation", 'Int'>
    readonly unit: FieldRef<"Observation", 'String'>
    readonly inputCost: FieldRef<"Observation", 'Decimal'>
    readonly outputCost: FieldRef<"Observation", 'Decimal'>
    readonly totalCost: FieldRef<"Observation", 'Decimal'>
    readonly calculatedInputCost: FieldRef<"Observation", 'Decimal'>
    readonly calculatedOutputCost: FieldRef<"Observation", 'Decimal'>
    readonly calculatedTotalCost: FieldRef<"Observation", 'Decimal'>
    readonly completionStartTime: FieldRef<"Observation", 'DateTime'>
    readonly promptId: FieldRef<"Observation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Observation findUnique
   */
  export type ObservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation findUniqueOrThrow
   */
  export type ObservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation findFirst
   */
  export type ObservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation findFirstOrThrow
   */
  export type ObservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation findMany
   */
  export type ObservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observations to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation create
   */
  export type ObservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Observation.
     */
    data: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation createMany
   */
  export type ObservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Observation createManyAndReturn
   */
  export type ObservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Observation update
   */
  export type ObservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Observation.
     */
    data: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
    /**
     * Choose, which Observation to update.
     */
    where: ObservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation updateMany
   */
  export type ObservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Observations.
     */
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyInput>
    /**
     * Filter which Observations to update
     */
    where?: ObservationWhereInput
  }

  /**
   * Observation upsert
   */
  export type ObservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Observation to update in case it exists.
     */
    where: ObservationWhereUniqueInput
    /**
     * In case the Observation found by the `where` argument doesn't exist, create a new Observation with this data.
     */
    create: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
    /**
     * In case the Observation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation delete
   */
  export type ObservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter which Observation to delete.
     */
    where: ObservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Observation deleteMany
   */
  export type ObservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observations to delete
     */
    where?: ObservationWhereInput
  }

  /**
   * Observation without action
   */
  export type ObservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
  }


  /**
   * Model Score
   */

  export type AggregateScore = {
    _count: ScoreCountAggregateOutputType | null
    _avg: ScoreAvgAggregateOutputType | null
    _sum: ScoreSumAggregateOutputType | null
    _min: ScoreMinAggregateOutputType | null
    _max: ScoreMaxAggregateOutputType | null
  }

  export type ScoreAvgAggregateOutputType = {
    value: number | null
  }

  export type ScoreSumAggregateOutputType = {
    value: number | null
  }

  export type ScoreMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    projectId: string | null
    name: string | null
    value: number | null
    source: $Enums.ScoreSource | null
    authorUserId: string | null
    comment: string | null
    traceId: string | null
    observationId: string | null
    configId: string | null
    stringValue: string | null
    queueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dataType: $Enums.ScoreDataType | null
  }

  export type ScoreMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    projectId: string | null
    name: string | null
    value: number | null
    source: $Enums.ScoreSource | null
    authorUserId: string | null
    comment: string | null
    traceId: string | null
    observationId: string | null
    configId: string | null
    stringValue: string | null
    queueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dataType: $Enums.ScoreDataType | null
  }

  export type ScoreCountAggregateOutputType = {
    id: number
    timestamp: number
    projectId: number
    name: number
    value: number
    source: number
    authorUserId: number
    comment: number
    traceId: number
    observationId: number
    configId: number
    stringValue: number
    queueId: number
    createdAt: number
    updatedAt: number
    dataType: number
    _all: number
  }


  export type ScoreAvgAggregateInputType = {
    value?: true
  }

  export type ScoreSumAggregateInputType = {
    value?: true
  }

  export type ScoreMinAggregateInputType = {
    id?: true
    timestamp?: true
    projectId?: true
    name?: true
    value?: true
    source?: true
    authorUserId?: true
    comment?: true
    traceId?: true
    observationId?: true
    configId?: true
    stringValue?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
    dataType?: true
  }

  export type ScoreMaxAggregateInputType = {
    id?: true
    timestamp?: true
    projectId?: true
    name?: true
    value?: true
    source?: true
    authorUserId?: true
    comment?: true
    traceId?: true
    observationId?: true
    configId?: true
    stringValue?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
    dataType?: true
  }

  export type ScoreCountAggregateInputType = {
    id?: true
    timestamp?: true
    projectId?: true
    name?: true
    value?: true
    source?: true
    authorUserId?: true
    comment?: true
    traceId?: true
    observationId?: true
    configId?: true
    stringValue?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
    dataType?: true
    _all?: true
  }

  export type ScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Score to aggregate.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scores
    **/
    _count?: true | ScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoreMaxAggregateInputType
  }

  export type GetScoreAggregateType<T extends ScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScore[P]>
      : GetScalarType<T[P], AggregateScore[P]>
  }




  export type ScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithAggregationInput | ScoreOrderByWithAggregationInput[]
    by: ScoreScalarFieldEnum[] | ScoreScalarFieldEnum
    having?: ScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoreCountAggregateInputType | true
    _avg?: ScoreAvgAggregateInputType
    _sum?: ScoreSumAggregateInputType
    _min?: ScoreMinAggregateInputType
    _max?: ScoreMaxAggregateInputType
  }

  export type ScoreGroupByOutputType = {
    id: string
    timestamp: Date
    projectId: string
    name: string
    value: number | null
    source: $Enums.ScoreSource
    authorUserId: string | null
    comment: string | null
    traceId: string
    observationId: string | null
    configId: string | null
    stringValue: string | null
    queueId: string | null
    createdAt: Date
    updatedAt: Date
    dataType: $Enums.ScoreDataType
    _count: ScoreCountAggregateOutputType | null
    _avg: ScoreAvgAggregateOutputType | null
    _sum: ScoreSumAggregateOutputType | null
    _min: ScoreMinAggregateOutputType | null
    _max: ScoreMaxAggregateOutputType | null
  }

  type GetScoreGroupByPayload<T extends ScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ScoreGroupByOutputType[P]>
        }
      >
    >


  export type ScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    source?: boolean
    authorUserId?: boolean
    comment?: boolean
    traceId?: boolean
    observationId?: boolean
    configId?: boolean
    stringValue?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataType?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    scoreConfig?: boolean | Score$scoreConfigArgs<ExtArgs>
  }, ExtArgs["result"]["score"]>

  export type ScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    source?: boolean
    authorUserId?: boolean
    comment?: boolean
    traceId?: boolean
    observationId?: boolean
    configId?: boolean
    stringValue?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataType?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    scoreConfig?: boolean | Score$scoreConfigArgs<ExtArgs>
  }, ExtArgs["result"]["score"]>

  export type ScoreSelectScalar = {
    id?: boolean
    timestamp?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    source?: boolean
    authorUserId?: boolean
    comment?: boolean
    traceId?: boolean
    observationId?: boolean
    configId?: boolean
    stringValue?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataType?: boolean
  }

  export type ScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    scoreConfig?: boolean | Score$scoreConfigArgs<ExtArgs>
  }
  export type ScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    scoreConfig?: boolean | Score$scoreConfigArgs<ExtArgs>
  }

  export type $ScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Score"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      scoreConfig: Prisma.$ScoreConfigPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      projectId: string
      name: string
      value: number | null
      source: $Enums.ScoreSource
      authorUserId: string | null
      comment: string | null
      traceId: string
      observationId: string | null
      configId: string | null
      stringValue: string | null
      queueId: string | null
      createdAt: Date
      updatedAt: Date
      dataType: $Enums.ScoreDataType
    }, ExtArgs["result"]["score"]>
    composites: {}
  }

  type ScoreGetPayload<S extends boolean | null | undefined | ScoreDefaultArgs> = $Result.GetResult<Prisma.$ScorePayload, S>

  type ScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ScoreCountAggregateInputType | true
    }

  export interface ScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Score'], meta: { name: 'Score' } }
    /**
     * Find zero or one Score that matches the filter.
     * @param {ScoreFindUniqueArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoreFindUniqueArgs>(args: SelectSubset<T, ScoreFindUniqueArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Score that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScoreFindUniqueOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Score that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoreFindFirstArgs>(args?: SelectSubset<T, ScoreFindFirstArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Score that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scores
     * const scores = await prisma.score.findMany()
     * 
     * // Get first 10 Scores
     * const scores = await prisma.score.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoreWithIdOnly = await prisma.score.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoreFindManyArgs>(args?: SelectSubset<T, ScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Score.
     * @param {ScoreCreateArgs} args - Arguments to create a Score.
     * @example
     * // Create one Score
     * const Score = await prisma.score.create({
     *   data: {
     *     // ... data to create a Score
     *   }
     * })
     * 
     */
    create<T extends ScoreCreateArgs>(args: SelectSubset<T, ScoreCreateArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Scores.
     * @param {ScoreCreateManyArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoreCreateManyArgs>(args?: SelectSubset<T, ScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scores and returns the data saved in the database.
     * @param {ScoreCreateManyAndReturnArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scores and only return the `id`
     * const scoreWithIdOnly = await prisma.score.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Score.
     * @param {ScoreDeleteArgs} args - Arguments to delete one Score.
     * @example
     * // Delete one Score
     * const Score = await prisma.score.delete({
     *   where: {
     *     // ... filter to delete one Score
     *   }
     * })
     * 
     */
    delete<T extends ScoreDeleteArgs>(args: SelectSubset<T, ScoreDeleteArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Score.
     * @param {ScoreUpdateArgs} args - Arguments to update one Score.
     * @example
     * // Update one Score
     * const score = await prisma.score.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoreUpdateArgs>(args: SelectSubset<T, ScoreUpdateArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Scores.
     * @param {ScoreDeleteManyArgs} args - Arguments to filter Scores to delete.
     * @example
     * // Delete a few Scores
     * const { count } = await prisma.score.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoreDeleteManyArgs>(args?: SelectSubset<T, ScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scores
     * const score = await prisma.score.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoreUpdateManyArgs>(args: SelectSubset<T, ScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Score.
     * @param {ScoreUpsertArgs} args - Arguments to update or create a Score.
     * @example
     * // Update or create a Score
     * const score = await prisma.score.upsert({
     *   create: {
     *     // ... data to create a Score
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Score we want to update
     *   }
     * })
     */
    upsert<T extends ScoreUpsertArgs>(args: SelectSubset<T, ScoreUpsertArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreCountArgs} args - Arguments to filter Scores to count.
     * @example
     * // Count the number of Scores
     * const count = await prisma.score.count({
     *   where: {
     *     // ... the filter for the Scores we want to count
     *   }
     * })
    **/
    count<T extends ScoreCountArgs>(
      args?: Subset<T, ScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoreAggregateArgs>(args: Subset<T, ScoreAggregateArgs>): Prisma.PrismaPromise<GetScoreAggregateType<T>>

    /**
     * Group by Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoreGroupByArgs['orderBy'] }
        : { orderBy?: ScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Score model
   */
  readonly fields: ScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Score.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scoreConfig<T extends Score$scoreConfigArgs<ExtArgs> = {}>(args?: Subset<T, Score$scoreConfigArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Score model
   */ 
  interface ScoreFieldRefs {
    readonly id: FieldRef<"Score", 'String'>
    readonly timestamp: FieldRef<"Score", 'DateTime'>
    readonly projectId: FieldRef<"Score", 'String'>
    readonly name: FieldRef<"Score", 'String'>
    readonly value: FieldRef<"Score", 'Float'>
    readonly source: FieldRef<"Score", 'ScoreSource'>
    readonly authorUserId: FieldRef<"Score", 'String'>
    readonly comment: FieldRef<"Score", 'String'>
    readonly traceId: FieldRef<"Score", 'String'>
    readonly observationId: FieldRef<"Score", 'String'>
    readonly configId: FieldRef<"Score", 'String'>
    readonly stringValue: FieldRef<"Score", 'String'>
    readonly queueId: FieldRef<"Score", 'String'>
    readonly createdAt: FieldRef<"Score", 'DateTime'>
    readonly updatedAt: FieldRef<"Score", 'DateTime'>
    readonly dataType: FieldRef<"Score", 'ScoreDataType'>
  }
    

  // Custom InputTypes
  /**
   * Score findUnique
   */
  export type ScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score findUniqueOrThrow
   */
  export type ScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score findFirst
   */
  export type ScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score findFirstOrThrow
   */
  export type ScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score findMany
   */
  export type ScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Scores to fetch.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scores.
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score create
   */
  export type ScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Score.
     */
    data: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score createMany
   */
  export type ScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Score createManyAndReturn
   */
  export type ScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Score update
   */
  export type ScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Score.
     */
    data: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>
    /**
     * Choose, which Score to update.
     */
    where: ScoreWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score updateMany
   */
  export type ScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scores.
     */
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyInput>
    /**
     * Filter which Scores to update
     */
    where?: ScoreWhereInput
  }

  /**
   * Score upsert
   */
  export type ScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Score to update in case it exists.
     */
    where: ScoreWhereUniqueInput
    /**
     * In case the Score found by the `where` argument doesn't exist, create a new Score with this data.
     */
    create: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>
    /**
     * In case the Score was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score delete
   */
  export type ScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter which Score to delete.
     */
    where: ScoreWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Score deleteMany
   */
  export type ScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scores to delete
     */
    where?: ScoreWhereInput
  }

  /**
   * Score.scoreConfig
   */
  export type Score$scoreConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    where?: ScoreConfigWhereInput
  }

  /**
   * Score without action
   */
  export type ScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
  }


  /**
   * Model ScoreConfig
   */

  export type AggregateScoreConfig = {
    _count: ScoreConfigCountAggregateOutputType | null
    _avg: ScoreConfigAvgAggregateOutputType | null
    _sum: ScoreConfigSumAggregateOutputType | null
    _min: ScoreConfigMinAggregateOutputType | null
    _max: ScoreConfigMaxAggregateOutputType | null
  }

  export type ScoreConfigAvgAggregateOutputType = {
    minValue: number | null
    maxValue: number | null
  }

  export type ScoreConfigSumAggregateOutputType = {
    minValue: number | null
    maxValue: number | null
  }

  export type ScoreConfigMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    name: string | null
    dataType: $Enums.ScoreDataType | null
    isArchived: boolean | null
    minValue: number | null
    maxValue: number | null
    description: string | null
  }

  export type ScoreConfigMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    name: string | null
    dataType: $Enums.ScoreDataType | null
    isArchived: boolean | null
    minValue: number | null
    maxValue: number | null
    description: string | null
  }

  export type ScoreConfigCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    name: number
    dataType: number
    isArchived: number
    minValue: number
    maxValue: number
    categories: number
    description: number
    _all: number
  }


  export type ScoreConfigAvgAggregateInputType = {
    minValue?: true
    maxValue?: true
  }

  export type ScoreConfigSumAggregateInputType = {
    minValue?: true
    maxValue?: true
  }

  export type ScoreConfigMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    name?: true
    dataType?: true
    isArchived?: true
    minValue?: true
    maxValue?: true
    description?: true
  }

  export type ScoreConfigMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    name?: true
    dataType?: true
    isArchived?: true
    minValue?: true
    maxValue?: true
    description?: true
  }

  export type ScoreConfigCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    name?: true
    dataType?: true
    isArchived?: true
    minValue?: true
    maxValue?: true
    categories?: true
    description?: true
    _all?: true
  }

  export type ScoreConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoreConfig to aggregate.
     */
    where?: ScoreConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoreConfigs to fetch.
     */
    orderBy?: ScoreConfigOrderByWithRelationInput | ScoreConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoreConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoreConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoreConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScoreConfigs
    **/
    _count?: true | ScoreConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoreConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoreConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoreConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoreConfigMaxAggregateInputType
  }

  export type GetScoreConfigAggregateType<T extends ScoreConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateScoreConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoreConfig[P]>
      : GetScalarType<T[P], AggregateScoreConfig[P]>
  }




  export type ScoreConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreConfigWhereInput
    orderBy?: ScoreConfigOrderByWithAggregationInput | ScoreConfigOrderByWithAggregationInput[]
    by: ScoreConfigScalarFieldEnum[] | ScoreConfigScalarFieldEnum
    having?: ScoreConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoreConfigCountAggregateInputType | true
    _avg?: ScoreConfigAvgAggregateInputType
    _sum?: ScoreConfigSumAggregateInputType
    _min?: ScoreConfigMinAggregateInputType
    _max?: ScoreConfigMaxAggregateInputType
  }

  export type ScoreConfigGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived: boolean
    minValue: number | null
    maxValue: number | null
    categories: JsonValue | null
    description: string | null
    _count: ScoreConfigCountAggregateOutputType | null
    _avg: ScoreConfigAvgAggregateOutputType | null
    _sum: ScoreConfigSumAggregateOutputType | null
    _min: ScoreConfigMinAggregateOutputType | null
    _max: ScoreConfigMaxAggregateOutputType | null
  }

  type GetScoreConfigGroupByPayload<T extends ScoreConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoreConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoreConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoreConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ScoreConfigGroupByOutputType[P]>
        }
      >
    >


  export type ScoreConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    name?: boolean
    dataType?: boolean
    isArchived?: boolean
    minValue?: boolean
    maxValue?: boolean
    categories?: boolean
    description?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    score?: boolean | ScoreConfig$scoreArgs<ExtArgs>
    _count?: boolean | ScoreConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoreConfig"]>

  export type ScoreConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    name?: boolean
    dataType?: boolean
    isArchived?: boolean
    minValue?: boolean
    maxValue?: boolean
    categories?: boolean
    description?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoreConfig"]>

  export type ScoreConfigSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    name?: boolean
    dataType?: boolean
    isArchived?: boolean
    minValue?: boolean
    maxValue?: boolean
    categories?: boolean
    description?: boolean
  }

  export type ScoreConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    score?: boolean | ScoreConfig$scoreArgs<ExtArgs>
    _count?: boolean | ScoreConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScoreConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ScoreConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScoreConfig"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      score: Prisma.$ScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      name: string
      dataType: $Enums.ScoreDataType
      isArchived: boolean
      minValue: number | null
      maxValue: number | null
      categories: Prisma.JsonValue | null
      description: string | null
    }, ExtArgs["result"]["scoreConfig"]>
    composites: {}
  }

  type ScoreConfigGetPayload<S extends boolean | null | undefined | ScoreConfigDefaultArgs> = $Result.GetResult<Prisma.$ScoreConfigPayload, S>

  type ScoreConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScoreConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ScoreConfigCountAggregateInputType | true
    }

  export interface ScoreConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScoreConfig'], meta: { name: 'ScoreConfig' } }
    /**
     * Find zero or one ScoreConfig that matches the filter.
     * @param {ScoreConfigFindUniqueArgs} args - Arguments to find a ScoreConfig
     * @example
     * // Get one ScoreConfig
     * const scoreConfig = await prisma.scoreConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoreConfigFindUniqueArgs>(args: SelectSubset<T, ScoreConfigFindUniqueArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScoreConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScoreConfigFindUniqueOrThrowArgs} args - Arguments to find a ScoreConfig
     * @example
     * // Get one ScoreConfig
     * const scoreConfig = await prisma.scoreConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoreConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoreConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScoreConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigFindFirstArgs} args - Arguments to find a ScoreConfig
     * @example
     * // Get one ScoreConfig
     * const scoreConfig = await prisma.scoreConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoreConfigFindFirstArgs>(args?: SelectSubset<T, ScoreConfigFindFirstArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScoreConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigFindFirstOrThrowArgs} args - Arguments to find a ScoreConfig
     * @example
     * // Get one ScoreConfig
     * const scoreConfig = await prisma.scoreConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoreConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoreConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScoreConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScoreConfigs
     * const scoreConfigs = await prisma.scoreConfig.findMany()
     * 
     * // Get first 10 ScoreConfigs
     * const scoreConfigs = await prisma.scoreConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoreConfigWithIdOnly = await prisma.scoreConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoreConfigFindManyArgs>(args?: SelectSubset<T, ScoreConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScoreConfig.
     * @param {ScoreConfigCreateArgs} args - Arguments to create a ScoreConfig.
     * @example
     * // Create one ScoreConfig
     * const ScoreConfig = await prisma.scoreConfig.create({
     *   data: {
     *     // ... data to create a ScoreConfig
     *   }
     * })
     * 
     */
    create<T extends ScoreConfigCreateArgs>(args: SelectSubset<T, ScoreConfigCreateArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScoreConfigs.
     * @param {ScoreConfigCreateManyArgs} args - Arguments to create many ScoreConfigs.
     * @example
     * // Create many ScoreConfigs
     * const scoreConfig = await prisma.scoreConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoreConfigCreateManyArgs>(args?: SelectSubset<T, ScoreConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScoreConfigs and returns the data saved in the database.
     * @param {ScoreConfigCreateManyAndReturnArgs} args - Arguments to create many ScoreConfigs.
     * @example
     * // Create many ScoreConfigs
     * const scoreConfig = await prisma.scoreConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScoreConfigs and only return the `id`
     * const scoreConfigWithIdOnly = await prisma.scoreConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScoreConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ScoreConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScoreConfig.
     * @param {ScoreConfigDeleteArgs} args - Arguments to delete one ScoreConfig.
     * @example
     * // Delete one ScoreConfig
     * const ScoreConfig = await prisma.scoreConfig.delete({
     *   where: {
     *     // ... filter to delete one ScoreConfig
     *   }
     * })
     * 
     */
    delete<T extends ScoreConfigDeleteArgs>(args: SelectSubset<T, ScoreConfigDeleteArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScoreConfig.
     * @param {ScoreConfigUpdateArgs} args - Arguments to update one ScoreConfig.
     * @example
     * // Update one ScoreConfig
     * const scoreConfig = await prisma.scoreConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoreConfigUpdateArgs>(args: SelectSubset<T, ScoreConfigUpdateArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScoreConfigs.
     * @param {ScoreConfigDeleteManyArgs} args - Arguments to filter ScoreConfigs to delete.
     * @example
     * // Delete a few ScoreConfigs
     * const { count } = await prisma.scoreConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoreConfigDeleteManyArgs>(args?: SelectSubset<T, ScoreConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoreConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScoreConfigs
     * const scoreConfig = await prisma.scoreConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoreConfigUpdateManyArgs>(args: SelectSubset<T, ScoreConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScoreConfig.
     * @param {ScoreConfigUpsertArgs} args - Arguments to update or create a ScoreConfig.
     * @example
     * // Update or create a ScoreConfig
     * const scoreConfig = await prisma.scoreConfig.upsert({
     *   create: {
     *     // ... data to create a ScoreConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScoreConfig we want to update
     *   }
     * })
     */
    upsert<T extends ScoreConfigUpsertArgs>(args: SelectSubset<T, ScoreConfigUpsertArgs<ExtArgs>>): Prisma__ScoreConfigClient<$Result.GetResult<Prisma.$ScoreConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScoreConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigCountArgs} args - Arguments to filter ScoreConfigs to count.
     * @example
     * // Count the number of ScoreConfigs
     * const count = await prisma.scoreConfig.count({
     *   where: {
     *     // ... the filter for the ScoreConfigs we want to count
     *   }
     * })
    **/
    count<T extends ScoreConfigCountArgs>(
      args?: Subset<T, ScoreConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoreConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScoreConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoreConfigAggregateArgs>(args: Subset<T, ScoreConfigAggregateArgs>): Prisma.PrismaPromise<GetScoreConfigAggregateType<T>>

    /**
     * Group by ScoreConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoreConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoreConfigGroupByArgs['orderBy'] }
        : { orderBy?: ScoreConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoreConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoreConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScoreConfig model
   */
  readonly fields: ScoreConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScoreConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoreConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    score<T extends ScoreConfig$scoreArgs<ExtArgs> = {}>(args?: Subset<T, ScoreConfig$scoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScoreConfig model
   */ 
  interface ScoreConfigFieldRefs {
    readonly id: FieldRef<"ScoreConfig", 'String'>
    readonly createdAt: FieldRef<"ScoreConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"ScoreConfig", 'DateTime'>
    readonly projectId: FieldRef<"ScoreConfig", 'String'>
    readonly name: FieldRef<"ScoreConfig", 'String'>
    readonly dataType: FieldRef<"ScoreConfig", 'ScoreDataType'>
    readonly isArchived: FieldRef<"ScoreConfig", 'Boolean'>
    readonly minValue: FieldRef<"ScoreConfig", 'Float'>
    readonly maxValue: FieldRef<"ScoreConfig", 'Float'>
    readonly categories: FieldRef<"ScoreConfig", 'Json'>
    readonly description: FieldRef<"ScoreConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScoreConfig findUnique
   */
  export type ScoreConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * Filter, which ScoreConfig to fetch.
     */
    where: ScoreConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig findUniqueOrThrow
   */
  export type ScoreConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * Filter, which ScoreConfig to fetch.
     */
    where: ScoreConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig findFirst
   */
  export type ScoreConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * Filter, which ScoreConfig to fetch.
     */
    where?: ScoreConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoreConfigs to fetch.
     */
    orderBy?: ScoreConfigOrderByWithRelationInput | ScoreConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoreConfigs.
     */
    cursor?: ScoreConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoreConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoreConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoreConfigs.
     */
    distinct?: ScoreConfigScalarFieldEnum | ScoreConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig findFirstOrThrow
   */
  export type ScoreConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * Filter, which ScoreConfig to fetch.
     */
    where?: ScoreConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoreConfigs to fetch.
     */
    orderBy?: ScoreConfigOrderByWithRelationInput | ScoreConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoreConfigs.
     */
    cursor?: ScoreConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoreConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoreConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoreConfigs.
     */
    distinct?: ScoreConfigScalarFieldEnum | ScoreConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig findMany
   */
  export type ScoreConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * Filter, which ScoreConfigs to fetch.
     */
    where?: ScoreConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoreConfigs to fetch.
     */
    orderBy?: ScoreConfigOrderByWithRelationInput | ScoreConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScoreConfigs.
     */
    cursor?: ScoreConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoreConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoreConfigs.
     */
    skip?: number
    distinct?: ScoreConfigScalarFieldEnum | ScoreConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig create
   */
  export type ScoreConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a ScoreConfig.
     */
    data: XOR<ScoreConfigCreateInput, ScoreConfigUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig createMany
   */
  export type ScoreConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScoreConfigs.
     */
    data: ScoreConfigCreateManyInput | ScoreConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScoreConfig createManyAndReturn
   */
  export type ScoreConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScoreConfigs.
     */
    data: ScoreConfigCreateManyInput | ScoreConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScoreConfig update
   */
  export type ScoreConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a ScoreConfig.
     */
    data: XOR<ScoreConfigUpdateInput, ScoreConfigUncheckedUpdateInput>
    /**
     * Choose, which ScoreConfig to update.
     */
    where: ScoreConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig updateMany
   */
  export type ScoreConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScoreConfigs.
     */
    data: XOR<ScoreConfigUpdateManyMutationInput, ScoreConfigUncheckedUpdateManyInput>
    /**
     * Filter which ScoreConfigs to update
     */
    where?: ScoreConfigWhereInput
  }

  /**
   * ScoreConfig upsert
   */
  export type ScoreConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the ScoreConfig to update in case it exists.
     */
    where: ScoreConfigWhereUniqueInput
    /**
     * In case the ScoreConfig found by the `where` argument doesn't exist, create a new ScoreConfig with this data.
     */
    create: XOR<ScoreConfigCreateInput, ScoreConfigUncheckedCreateInput>
    /**
     * In case the ScoreConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoreConfigUpdateInput, ScoreConfigUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig delete
   */
  export type ScoreConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
    /**
     * Filter which ScoreConfig to delete.
     */
    where: ScoreConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScoreConfig deleteMany
   */
  export type ScoreConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoreConfigs to delete
     */
    where?: ScoreConfigWhereInput
  }

  /**
   * ScoreConfig.score
   */
  export type ScoreConfig$scoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    cursor?: ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * ScoreConfig without action
   */
  export type ScoreConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoreConfig
     */
    select?: ScoreConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreConfigInclude<ExtArgs> | null
  }


  /**
   * Model AnnotationQueue
   */

  export type AggregateAnnotationQueue = {
    _count: AnnotationQueueCountAggregateOutputType | null
    _min: AnnotationQueueMinAggregateOutputType | null
    _max: AnnotationQueueMaxAggregateOutputType | null
  }

  export type AnnotationQueueMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnotationQueueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnotationQueueCountAggregateOutputType = {
    id: number
    name: number
    description: number
    scoreConfigIds: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnotationQueueMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnotationQueueMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnotationQueueCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scoreConfigIds?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnotationQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnotationQueue to aggregate.
     */
    where?: AnnotationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueues to fetch.
     */
    orderBy?: AnnotationQueueOrderByWithRelationInput | AnnotationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnotationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnnotationQueues
    **/
    _count?: true | AnnotationQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnotationQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnotationQueueMaxAggregateInputType
  }

  export type GetAnnotationQueueAggregateType<T extends AnnotationQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnotationQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnotationQueue[P]>
      : GetScalarType<T[P], AggregateAnnotationQueue[P]>
  }




  export type AnnotationQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueWhereInput
    orderBy?: AnnotationQueueOrderByWithAggregationInput | AnnotationQueueOrderByWithAggregationInput[]
    by: AnnotationQueueScalarFieldEnum[] | AnnotationQueueScalarFieldEnum
    having?: AnnotationQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnotationQueueCountAggregateInputType | true
    _min?: AnnotationQueueMinAggregateInputType
    _max?: AnnotationQueueMaxAggregateInputType
  }

  export type AnnotationQueueGroupByOutputType = {
    id: string
    name: string
    description: string | null
    scoreConfigIds: string[]
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: AnnotationQueueCountAggregateOutputType | null
    _min: AnnotationQueueMinAggregateOutputType | null
    _max: AnnotationQueueMaxAggregateOutputType | null
  }

  type GetAnnotationQueueGroupByPayload<T extends AnnotationQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnotationQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnotationQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnotationQueueGroupByOutputType[P]>
            : GetScalarType<T[P], AnnotationQueueGroupByOutputType[P]>
        }
      >
    >


  export type AnnotationQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    scoreConfigIds?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    annotationQueueItem?: boolean | AnnotationQueue$annotationQueueItemArgs<ExtArgs>
    _count?: boolean | AnnotationQueueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotationQueue"]>

  export type AnnotationQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    scoreConfigIds?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotationQueue"]>

  export type AnnotationQueueSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    scoreConfigIds?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnotationQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    annotationQueueItem?: boolean | AnnotationQueue$annotationQueueItemArgs<ExtArgs>
    _count?: boolean | AnnotationQueueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnnotationQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $AnnotationQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnnotationQueue"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      annotationQueueItem: Prisma.$AnnotationQueueItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      scoreConfigIds: string[]
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["annotationQueue"]>
    composites: {}
  }

  type AnnotationQueueGetPayload<S extends boolean | null | undefined | AnnotationQueueDefaultArgs> = $Result.GetResult<Prisma.$AnnotationQueuePayload, S>

  type AnnotationQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnotationQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AnnotationQueueCountAggregateInputType | true
    }

  export interface AnnotationQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnnotationQueue'], meta: { name: 'AnnotationQueue' } }
    /**
     * Find zero or one AnnotationQueue that matches the filter.
     * @param {AnnotationQueueFindUniqueArgs} args - Arguments to find a AnnotationQueue
     * @example
     * // Get one AnnotationQueue
     * const annotationQueue = await prisma.annotationQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnotationQueueFindUniqueArgs>(args: SelectSubset<T, AnnotationQueueFindUniqueArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnnotationQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnnotationQueueFindUniqueOrThrowArgs} args - Arguments to find a AnnotationQueue
     * @example
     * // Get one AnnotationQueue
     * const annotationQueue = await prisma.annotationQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnotationQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnotationQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnnotationQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueFindFirstArgs} args - Arguments to find a AnnotationQueue
     * @example
     * // Get one AnnotationQueue
     * const annotationQueue = await prisma.annotationQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnotationQueueFindFirstArgs>(args?: SelectSubset<T, AnnotationQueueFindFirstArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnnotationQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueFindFirstOrThrowArgs} args - Arguments to find a AnnotationQueue
     * @example
     * // Get one AnnotationQueue
     * const annotationQueue = await prisma.annotationQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnotationQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnotationQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnnotationQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnotationQueues
     * const annotationQueues = await prisma.annotationQueue.findMany()
     * 
     * // Get first 10 AnnotationQueues
     * const annotationQueues = await prisma.annotationQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annotationQueueWithIdOnly = await prisma.annotationQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnotationQueueFindManyArgs>(args?: SelectSubset<T, AnnotationQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnnotationQueue.
     * @param {AnnotationQueueCreateArgs} args - Arguments to create a AnnotationQueue.
     * @example
     * // Create one AnnotationQueue
     * const AnnotationQueue = await prisma.annotationQueue.create({
     *   data: {
     *     // ... data to create a AnnotationQueue
     *   }
     * })
     * 
     */
    create<T extends AnnotationQueueCreateArgs>(args: SelectSubset<T, AnnotationQueueCreateArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnnotationQueues.
     * @param {AnnotationQueueCreateManyArgs} args - Arguments to create many AnnotationQueues.
     * @example
     * // Create many AnnotationQueues
     * const annotationQueue = await prisma.annotationQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnotationQueueCreateManyArgs>(args?: SelectSubset<T, AnnotationQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnnotationQueues and returns the data saved in the database.
     * @param {AnnotationQueueCreateManyAndReturnArgs} args - Arguments to create many AnnotationQueues.
     * @example
     * // Create many AnnotationQueues
     * const annotationQueue = await prisma.annotationQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnnotationQueues and only return the `id`
     * const annotationQueueWithIdOnly = await prisma.annotationQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnotationQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnotationQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnnotationQueue.
     * @param {AnnotationQueueDeleteArgs} args - Arguments to delete one AnnotationQueue.
     * @example
     * // Delete one AnnotationQueue
     * const AnnotationQueue = await prisma.annotationQueue.delete({
     *   where: {
     *     // ... filter to delete one AnnotationQueue
     *   }
     * })
     * 
     */
    delete<T extends AnnotationQueueDeleteArgs>(args: SelectSubset<T, AnnotationQueueDeleteArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnnotationQueue.
     * @param {AnnotationQueueUpdateArgs} args - Arguments to update one AnnotationQueue.
     * @example
     * // Update one AnnotationQueue
     * const annotationQueue = await prisma.annotationQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnotationQueueUpdateArgs>(args: SelectSubset<T, AnnotationQueueUpdateArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnnotationQueues.
     * @param {AnnotationQueueDeleteManyArgs} args - Arguments to filter AnnotationQueues to delete.
     * @example
     * // Delete a few AnnotationQueues
     * const { count } = await prisma.annotationQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnotationQueueDeleteManyArgs>(args?: SelectSubset<T, AnnotationQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnotationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnotationQueues
     * const annotationQueue = await prisma.annotationQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnotationQueueUpdateManyArgs>(args: SelectSubset<T, AnnotationQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnnotationQueue.
     * @param {AnnotationQueueUpsertArgs} args - Arguments to update or create a AnnotationQueue.
     * @example
     * // Update or create a AnnotationQueue
     * const annotationQueue = await prisma.annotationQueue.upsert({
     *   create: {
     *     // ... data to create a AnnotationQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnotationQueue we want to update
     *   }
     * })
     */
    upsert<T extends AnnotationQueueUpsertArgs>(args: SelectSubset<T, AnnotationQueueUpsertArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnnotationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueCountArgs} args - Arguments to filter AnnotationQueues to count.
     * @example
     * // Count the number of AnnotationQueues
     * const count = await prisma.annotationQueue.count({
     *   where: {
     *     // ... the filter for the AnnotationQueues we want to count
     *   }
     * })
    **/
    count<T extends AnnotationQueueCountArgs>(
      args?: Subset<T, AnnotationQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnotationQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnnotationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnotationQueueAggregateArgs>(args: Subset<T, AnnotationQueueAggregateArgs>): Prisma.PrismaPromise<GetAnnotationQueueAggregateType<T>>

    /**
     * Group by AnnotationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnotationQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnotationQueueGroupByArgs['orderBy'] }
        : { orderBy?: AnnotationQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnotationQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnotationQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnnotationQueue model
   */
  readonly fields: AnnotationQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnotationQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnotationQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    annotationQueueItem<T extends AnnotationQueue$annotationQueueItemArgs<ExtArgs> = {}>(args?: Subset<T, AnnotationQueue$annotationQueueItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnnotationQueue model
   */ 
  interface AnnotationQueueFieldRefs {
    readonly id: FieldRef<"AnnotationQueue", 'String'>
    readonly name: FieldRef<"AnnotationQueue", 'String'>
    readonly description: FieldRef<"AnnotationQueue", 'String'>
    readonly scoreConfigIds: FieldRef<"AnnotationQueue", 'String[]'>
    readonly projectId: FieldRef<"AnnotationQueue", 'String'>
    readonly createdAt: FieldRef<"AnnotationQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"AnnotationQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnnotationQueue findUnique
   */
  export type AnnotationQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueue to fetch.
     */
    where: AnnotationQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue findUniqueOrThrow
   */
  export type AnnotationQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueue to fetch.
     */
    where: AnnotationQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue findFirst
   */
  export type AnnotationQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueue to fetch.
     */
    where?: AnnotationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueues to fetch.
     */
    orderBy?: AnnotationQueueOrderByWithRelationInput | AnnotationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnotationQueues.
     */
    cursor?: AnnotationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnotationQueues.
     */
    distinct?: AnnotationQueueScalarFieldEnum | AnnotationQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue findFirstOrThrow
   */
  export type AnnotationQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueue to fetch.
     */
    where?: AnnotationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueues to fetch.
     */
    orderBy?: AnnotationQueueOrderByWithRelationInput | AnnotationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnotationQueues.
     */
    cursor?: AnnotationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnotationQueues.
     */
    distinct?: AnnotationQueueScalarFieldEnum | AnnotationQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue findMany
   */
  export type AnnotationQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueues to fetch.
     */
    where?: AnnotationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueues to fetch.
     */
    orderBy?: AnnotationQueueOrderByWithRelationInput | AnnotationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnnotationQueues.
     */
    cursor?: AnnotationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueues.
     */
    skip?: number
    distinct?: AnnotationQueueScalarFieldEnum | AnnotationQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue create
   */
  export type AnnotationQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a AnnotationQueue.
     */
    data: XOR<AnnotationQueueCreateInput, AnnotationQueueUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue createMany
   */
  export type AnnotationQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnnotationQueues.
     */
    data: AnnotationQueueCreateManyInput | AnnotationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnnotationQueue createManyAndReturn
   */
  export type AnnotationQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnnotationQueues.
     */
    data: AnnotationQueueCreateManyInput | AnnotationQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnnotationQueue update
   */
  export type AnnotationQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a AnnotationQueue.
     */
    data: XOR<AnnotationQueueUpdateInput, AnnotationQueueUncheckedUpdateInput>
    /**
     * Choose, which AnnotationQueue to update.
     */
    where: AnnotationQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue updateMany
   */
  export type AnnotationQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnnotationQueues.
     */
    data: XOR<AnnotationQueueUpdateManyMutationInput, AnnotationQueueUncheckedUpdateManyInput>
    /**
     * Filter which AnnotationQueues to update
     */
    where?: AnnotationQueueWhereInput
  }

  /**
   * AnnotationQueue upsert
   */
  export type AnnotationQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the AnnotationQueue to update in case it exists.
     */
    where: AnnotationQueueWhereUniqueInput
    /**
     * In case the AnnotationQueue found by the `where` argument doesn't exist, create a new AnnotationQueue with this data.
     */
    create: XOR<AnnotationQueueCreateInput, AnnotationQueueUncheckedCreateInput>
    /**
     * In case the AnnotationQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnotationQueueUpdateInput, AnnotationQueueUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue delete
   */
  export type AnnotationQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
    /**
     * Filter which AnnotationQueue to delete.
     */
    where: AnnotationQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueue deleteMany
   */
  export type AnnotationQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnotationQueues to delete
     */
    where?: AnnotationQueueWhereInput
  }

  /**
   * AnnotationQueue.annotationQueueItem
   */
  export type AnnotationQueue$annotationQueueItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    where?: AnnotationQueueItemWhereInput
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    cursor?: AnnotationQueueItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
  }

  /**
   * AnnotationQueue without action
   */
  export type AnnotationQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueue
     */
    select?: AnnotationQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueInclude<ExtArgs> | null
  }


  /**
   * Model AnnotationQueueItem
   */

  export type AggregateAnnotationQueueItem = {
    _count: AnnotationQueueItemCountAggregateOutputType | null
    _min: AnnotationQueueItemMinAggregateOutputType | null
    _max: AnnotationQueueItemMaxAggregateOutputType | null
  }

  export type AnnotationQueueItemMinAggregateOutputType = {
    id: string | null
    queueId: string | null
    objectId: string | null
    objectType: $Enums.AnnotationQueueObjectType | null
    status: $Enums.AnnotationQueueStatus | null
    lockedAt: Date | null
    lockedByUserId: string | null
    annotatorUserId: string | null
    completedAt: Date | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnotationQueueItemMaxAggregateOutputType = {
    id: string | null
    queueId: string | null
    objectId: string | null
    objectType: $Enums.AnnotationQueueObjectType | null
    status: $Enums.AnnotationQueueStatus | null
    lockedAt: Date | null
    lockedByUserId: string | null
    annotatorUserId: string | null
    completedAt: Date | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnotationQueueItemCountAggregateOutputType = {
    id: number
    queueId: number
    objectId: number
    objectType: number
    status: number
    lockedAt: number
    lockedByUserId: number
    annotatorUserId: number
    completedAt: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnotationQueueItemMinAggregateInputType = {
    id?: true
    queueId?: true
    objectId?: true
    objectType?: true
    status?: true
    lockedAt?: true
    lockedByUserId?: true
    annotatorUserId?: true
    completedAt?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnotationQueueItemMaxAggregateInputType = {
    id?: true
    queueId?: true
    objectId?: true
    objectType?: true
    status?: true
    lockedAt?: true
    lockedByUserId?: true
    annotatorUserId?: true
    completedAt?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnotationQueueItemCountAggregateInputType = {
    id?: true
    queueId?: true
    objectId?: true
    objectType?: true
    status?: true
    lockedAt?: true
    lockedByUserId?: true
    annotatorUserId?: true
    completedAt?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnotationQueueItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnotationQueueItem to aggregate.
     */
    where?: AnnotationQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueueItems to fetch.
     */
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnotationQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnnotationQueueItems
    **/
    _count?: true | AnnotationQueueItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnotationQueueItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnotationQueueItemMaxAggregateInputType
  }

  export type GetAnnotationQueueItemAggregateType<T extends AnnotationQueueItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnotationQueueItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnotationQueueItem[P]>
      : GetScalarType<T[P], AggregateAnnotationQueueItem[P]>
  }




  export type AnnotationQueueItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationQueueItemWhereInput
    orderBy?: AnnotationQueueItemOrderByWithAggregationInput | AnnotationQueueItemOrderByWithAggregationInput[]
    by: AnnotationQueueItemScalarFieldEnum[] | AnnotationQueueItemScalarFieldEnum
    having?: AnnotationQueueItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnotationQueueItemCountAggregateInputType | true
    _min?: AnnotationQueueItemMinAggregateInputType
    _max?: AnnotationQueueItemMaxAggregateInputType
  }

  export type AnnotationQueueItemGroupByOutputType = {
    id: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status: $Enums.AnnotationQueueStatus
    lockedAt: Date | null
    lockedByUserId: string | null
    annotatorUserId: string | null
    completedAt: Date | null
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: AnnotationQueueItemCountAggregateOutputType | null
    _min: AnnotationQueueItemMinAggregateOutputType | null
    _max: AnnotationQueueItemMaxAggregateOutputType | null
  }

  type GetAnnotationQueueItemGroupByPayload<T extends AnnotationQueueItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnotationQueueItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnotationQueueItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnotationQueueItemGroupByOutputType[P]>
            : GetScalarType<T[P], AnnotationQueueItemGroupByOutputType[P]>
        }
      >
    >


  export type AnnotationQueueItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueId?: boolean
    objectId?: boolean
    objectType?: boolean
    status?: boolean
    lockedAt?: boolean
    lockedByUserId?: boolean
    annotatorUserId?: boolean
    completedAt?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    queue?: boolean | AnnotationQueueDefaultArgs<ExtArgs>
    lockedByUser?: boolean | AnnotationQueueItem$lockedByUserArgs<ExtArgs>
    annotatorUser?: boolean | AnnotationQueueItem$annotatorUserArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotationQueueItem"]>

  export type AnnotationQueueItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueId?: boolean
    objectId?: boolean
    objectType?: boolean
    status?: boolean
    lockedAt?: boolean
    lockedByUserId?: boolean
    annotatorUserId?: boolean
    completedAt?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    queue?: boolean | AnnotationQueueDefaultArgs<ExtArgs>
    lockedByUser?: boolean | AnnotationQueueItem$lockedByUserArgs<ExtArgs>
    annotatorUser?: boolean | AnnotationQueueItem$annotatorUserArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotationQueueItem"]>

  export type AnnotationQueueItemSelectScalar = {
    id?: boolean
    queueId?: boolean
    objectId?: boolean
    objectType?: boolean
    status?: boolean
    lockedAt?: boolean
    lockedByUserId?: boolean
    annotatorUserId?: boolean
    completedAt?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnotationQueueItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queue?: boolean | AnnotationQueueDefaultArgs<ExtArgs>
    lockedByUser?: boolean | AnnotationQueueItem$lockedByUserArgs<ExtArgs>
    annotatorUser?: boolean | AnnotationQueueItem$annotatorUserArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type AnnotationQueueItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queue?: boolean | AnnotationQueueDefaultArgs<ExtArgs>
    lockedByUser?: boolean | AnnotationQueueItem$lockedByUserArgs<ExtArgs>
    annotatorUser?: boolean | AnnotationQueueItem$annotatorUserArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $AnnotationQueueItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnnotationQueueItem"
    objects: {
      queue: Prisma.$AnnotationQueuePayload<ExtArgs>
      lockedByUser: Prisma.$UserPayload<ExtArgs> | null
      annotatorUser: Prisma.$UserPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queueId: string
      objectId: string
      objectType: $Enums.AnnotationQueueObjectType
      status: $Enums.AnnotationQueueStatus
      lockedAt: Date | null
      lockedByUserId: string | null
      annotatorUserId: string | null
      completedAt: Date | null
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["annotationQueueItem"]>
    composites: {}
  }

  type AnnotationQueueItemGetPayload<S extends boolean | null | undefined | AnnotationQueueItemDefaultArgs> = $Result.GetResult<Prisma.$AnnotationQueueItemPayload, S>

  type AnnotationQueueItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnotationQueueItemFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AnnotationQueueItemCountAggregateInputType | true
    }

  export interface AnnotationQueueItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnnotationQueueItem'], meta: { name: 'AnnotationQueueItem' } }
    /**
     * Find zero or one AnnotationQueueItem that matches the filter.
     * @param {AnnotationQueueItemFindUniqueArgs} args - Arguments to find a AnnotationQueueItem
     * @example
     * // Get one AnnotationQueueItem
     * const annotationQueueItem = await prisma.annotationQueueItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnotationQueueItemFindUniqueArgs>(args: SelectSubset<T, AnnotationQueueItemFindUniqueArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnnotationQueueItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnnotationQueueItemFindUniqueOrThrowArgs} args - Arguments to find a AnnotationQueueItem
     * @example
     * // Get one AnnotationQueueItem
     * const annotationQueueItem = await prisma.annotationQueueItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnotationQueueItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnotationQueueItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnnotationQueueItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemFindFirstArgs} args - Arguments to find a AnnotationQueueItem
     * @example
     * // Get one AnnotationQueueItem
     * const annotationQueueItem = await prisma.annotationQueueItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnotationQueueItemFindFirstArgs>(args?: SelectSubset<T, AnnotationQueueItemFindFirstArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnnotationQueueItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemFindFirstOrThrowArgs} args - Arguments to find a AnnotationQueueItem
     * @example
     * // Get one AnnotationQueueItem
     * const annotationQueueItem = await prisma.annotationQueueItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnotationQueueItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnotationQueueItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnnotationQueueItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnotationQueueItems
     * const annotationQueueItems = await prisma.annotationQueueItem.findMany()
     * 
     * // Get first 10 AnnotationQueueItems
     * const annotationQueueItems = await prisma.annotationQueueItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annotationQueueItemWithIdOnly = await prisma.annotationQueueItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnotationQueueItemFindManyArgs>(args?: SelectSubset<T, AnnotationQueueItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnnotationQueueItem.
     * @param {AnnotationQueueItemCreateArgs} args - Arguments to create a AnnotationQueueItem.
     * @example
     * // Create one AnnotationQueueItem
     * const AnnotationQueueItem = await prisma.annotationQueueItem.create({
     *   data: {
     *     // ... data to create a AnnotationQueueItem
     *   }
     * })
     * 
     */
    create<T extends AnnotationQueueItemCreateArgs>(args: SelectSubset<T, AnnotationQueueItemCreateArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnnotationQueueItems.
     * @param {AnnotationQueueItemCreateManyArgs} args - Arguments to create many AnnotationQueueItems.
     * @example
     * // Create many AnnotationQueueItems
     * const annotationQueueItem = await prisma.annotationQueueItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnotationQueueItemCreateManyArgs>(args?: SelectSubset<T, AnnotationQueueItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnnotationQueueItems and returns the data saved in the database.
     * @param {AnnotationQueueItemCreateManyAndReturnArgs} args - Arguments to create many AnnotationQueueItems.
     * @example
     * // Create many AnnotationQueueItems
     * const annotationQueueItem = await prisma.annotationQueueItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnnotationQueueItems and only return the `id`
     * const annotationQueueItemWithIdOnly = await prisma.annotationQueueItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnotationQueueItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnotationQueueItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnnotationQueueItem.
     * @param {AnnotationQueueItemDeleteArgs} args - Arguments to delete one AnnotationQueueItem.
     * @example
     * // Delete one AnnotationQueueItem
     * const AnnotationQueueItem = await prisma.annotationQueueItem.delete({
     *   where: {
     *     // ... filter to delete one AnnotationQueueItem
     *   }
     * })
     * 
     */
    delete<T extends AnnotationQueueItemDeleteArgs>(args: SelectSubset<T, AnnotationQueueItemDeleteArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnnotationQueueItem.
     * @param {AnnotationQueueItemUpdateArgs} args - Arguments to update one AnnotationQueueItem.
     * @example
     * // Update one AnnotationQueueItem
     * const annotationQueueItem = await prisma.annotationQueueItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnotationQueueItemUpdateArgs>(args: SelectSubset<T, AnnotationQueueItemUpdateArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnnotationQueueItems.
     * @param {AnnotationQueueItemDeleteManyArgs} args - Arguments to filter AnnotationQueueItems to delete.
     * @example
     * // Delete a few AnnotationQueueItems
     * const { count } = await prisma.annotationQueueItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnotationQueueItemDeleteManyArgs>(args?: SelectSubset<T, AnnotationQueueItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnotationQueueItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnotationQueueItems
     * const annotationQueueItem = await prisma.annotationQueueItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnotationQueueItemUpdateManyArgs>(args: SelectSubset<T, AnnotationQueueItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnnotationQueueItem.
     * @param {AnnotationQueueItemUpsertArgs} args - Arguments to update or create a AnnotationQueueItem.
     * @example
     * // Update or create a AnnotationQueueItem
     * const annotationQueueItem = await prisma.annotationQueueItem.upsert({
     *   create: {
     *     // ... data to create a AnnotationQueueItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnotationQueueItem we want to update
     *   }
     * })
     */
    upsert<T extends AnnotationQueueItemUpsertArgs>(args: SelectSubset<T, AnnotationQueueItemUpsertArgs<ExtArgs>>): Prisma__AnnotationQueueItemClient<$Result.GetResult<Prisma.$AnnotationQueueItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnnotationQueueItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemCountArgs} args - Arguments to filter AnnotationQueueItems to count.
     * @example
     * // Count the number of AnnotationQueueItems
     * const count = await prisma.annotationQueueItem.count({
     *   where: {
     *     // ... the filter for the AnnotationQueueItems we want to count
     *   }
     * })
    **/
    count<T extends AnnotationQueueItemCountArgs>(
      args?: Subset<T, AnnotationQueueItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnotationQueueItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnnotationQueueItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnotationQueueItemAggregateArgs>(args: Subset<T, AnnotationQueueItemAggregateArgs>): Prisma.PrismaPromise<GetAnnotationQueueItemAggregateType<T>>

    /**
     * Group by AnnotationQueueItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationQueueItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnotationQueueItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnotationQueueItemGroupByArgs['orderBy'] }
        : { orderBy?: AnnotationQueueItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnotationQueueItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnotationQueueItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnnotationQueueItem model
   */
  readonly fields: AnnotationQueueItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnotationQueueItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnotationQueueItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    queue<T extends AnnotationQueueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnnotationQueueDefaultArgs<ExtArgs>>): Prisma__AnnotationQueueClient<$Result.GetResult<Prisma.$AnnotationQueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lockedByUser<T extends AnnotationQueueItem$lockedByUserArgs<ExtArgs> = {}>(args?: Subset<T, AnnotationQueueItem$lockedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    annotatorUser<T extends AnnotationQueueItem$annotatorUserArgs<ExtArgs> = {}>(args?: Subset<T, AnnotationQueueItem$annotatorUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnnotationQueueItem model
   */ 
  interface AnnotationQueueItemFieldRefs {
    readonly id: FieldRef<"AnnotationQueueItem", 'String'>
    readonly queueId: FieldRef<"AnnotationQueueItem", 'String'>
    readonly objectId: FieldRef<"AnnotationQueueItem", 'String'>
    readonly objectType: FieldRef<"AnnotationQueueItem", 'AnnotationQueueObjectType'>
    readonly status: FieldRef<"AnnotationQueueItem", 'AnnotationQueueStatus'>
    readonly lockedAt: FieldRef<"AnnotationQueueItem", 'DateTime'>
    readonly lockedByUserId: FieldRef<"AnnotationQueueItem", 'String'>
    readonly annotatorUserId: FieldRef<"AnnotationQueueItem", 'String'>
    readonly completedAt: FieldRef<"AnnotationQueueItem", 'DateTime'>
    readonly projectId: FieldRef<"AnnotationQueueItem", 'String'>
    readonly createdAt: FieldRef<"AnnotationQueueItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AnnotationQueueItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnnotationQueueItem findUnique
   */
  export type AnnotationQueueItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueueItem to fetch.
     */
    where: AnnotationQueueItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem findUniqueOrThrow
   */
  export type AnnotationQueueItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueueItem to fetch.
     */
    where: AnnotationQueueItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem findFirst
   */
  export type AnnotationQueueItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueueItem to fetch.
     */
    where?: AnnotationQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueueItems to fetch.
     */
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnotationQueueItems.
     */
    cursor?: AnnotationQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnotationQueueItems.
     */
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem findFirstOrThrow
   */
  export type AnnotationQueueItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueueItem to fetch.
     */
    where?: AnnotationQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueueItems to fetch.
     */
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnotationQueueItems.
     */
    cursor?: AnnotationQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnotationQueueItems.
     */
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem findMany
   */
  export type AnnotationQueueItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * Filter, which AnnotationQueueItems to fetch.
     */
    where?: AnnotationQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnotationQueueItems to fetch.
     */
    orderBy?: AnnotationQueueItemOrderByWithRelationInput | AnnotationQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnnotationQueueItems.
     */
    cursor?: AnnotationQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnotationQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnotationQueueItems.
     */
    skip?: number
    distinct?: AnnotationQueueItemScalarFieldEnum | AnnotationQueueItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem create
   */
  export type AnnotationQueueItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AnnotationQueueItem.
     */
    data: XOR<AnnotationQueueItemCreateInput, AnnotationQueueItemUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem createMany
   */
  export type AnnotationQueueItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnnotationQueueItems.
     */
    data: AnnotationQueueItemCreateManyInput | AnnotationQueueItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnnotationQueueItem createManyAndReturn
   */
  export type AnnotationQueueItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnnotationQueueItems.
     */
    data: AnnotationQueueItemCreateManyInput | AnnotationQueueItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnnotationQueueItem update
   */
  export type AnnotationQueueItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AnnotationQueueItem.
     */
    data: XOR<AnnotationQueueItemUpdateInput, AnnotationQueueItemUncheckedUpdateInput>
    /**
     * Choose, which AnnotationQueueItem to update.
     */
    where: AnnotationQueueItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem updateMany
   */
  export type AnnotationQueueItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnnotationQueueItems.
     */
    data: XOR<AnnotationQueueItemUpdateManyMutationInput, AnnotationQueueItemUncheckedUpdateManyInput>
    /**
     * Filter which AnnotationQueueItems to update
     */
    where?: AnnotationQueueItemWhereInput
  }

  /**
   * AnnotationQueueItem upsert
   */
  export type AnnotationQueueItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AnnotationQueueItem to update in case it exists.
     */
    where: AnnotationQueueItemWhereUniqueInput
    /**
     * In case the AnnotationQueueItem found by the `where` argument doesn't exist, create a new AnnotationQueueItem with this data.
     */
    create: XOR<AnnotationQueueItemCreateInput, AnnotationQueueItemUncheckedCreateInput>
    /**
     * In case the AnnotationQueueItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnotationQueueItemUpdateInput, AnnotationQueueItemUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem delete
   */
  export type AnnotationQueueItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
    /**
     * Filter which AnnotationQueueItem to delete.
     */
    where: AnnotationQueueItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AnnotationQueueItem deleteMany
   */
  export type AnnotationQueueItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnotationQueueItems to delete
     */
    where?: AnnotationQueueItemWhereInput
  }

  /**
   * AnnotationQueueItem.lockedByUser
   */
  export type AnnotationQueueItem$lockedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AnnotationQueueItem.annotatorUser
   */
  export type AnnotationQueueItem$annotatorUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AnnotationQueueItem without action
   */
  export type AnnotationQueueItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnotationQueueItem
     */
    select?: AnnotationQueueItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationQueueItemInclude<ExtArgs> | null
  }


  /**
   * Model CronJobs
   */

  export type AggregateCronJobs = {
    _count: CronJobsCountAggregateOutputType | null
    _min: CronJobsMinAggregateOutputType | null
    _max: CronJobsMaxAggregateOutputType | null
  }

  export type CronJobsMinAggregateOutputType = {
    name: string | null
    lastRun: Date | null
    jobStartedAt: Date | null
    state: string | null
  }

  export type CronJobsMaxAggregateOutputType = {
    name: string | null
    lastRun: Date | null
    jobStartedAt: Date | null
    state: string | null
  }

  export type CronJobsCountAggregateOutputType = {
    name: number
    lastRun: number
    jobStartedAt: number
    state: number
    _all: number
  }


  export type CronJobsMinAggregateInputType = {
    name?: true
    lastRun?: true
    jobStartedAt?: true
    state?: true
  }

  export type CronJobsMaxAggregateInputType = {
    name?: true
    lastRun?: true
    jobStartedAt?: true
    state?: true
  }

  export type CronJobsCountAggregateInputType = {
    name?: true
    lastRun?: true
    jobStartedAt?: true
    state?: true
    _all?: true
  }

  export type CronJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronJobs to aggregate.
     */
    where?: CronJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobs to fetch.
     */
    orderBy?: CronJobsOrderByWithRelationInput | CronJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CronJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CronJobs
    **/
    _count?: true | CronJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CronJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CronJobsMaxAggregateInputType
  }

  export type GetCronJobsAggregateType<T extends CronJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateCronJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCronJobs[P]>
      : GetScalarType<T[P], AggregateCronJobs[P]>
  }




  export type CronJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CronJobsWhereInput
    orderBy?: CronJobsOrderByWithAggregationInput | CronJobsOrderByWithAggregationInput[]
    by: CronJobsScalarFieldEnum[] | CronJobsScalarFieldEnum
    having?: CronJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CronJobsCountAggregateInputType | true
    _min?: CronJobsMinAggregateInputType
    _max?: CronJobsMaxAggregateInputType
  }

  export type CronJobsGroupByOutputType = {
    name: string
    lastRun: Date | null
    jobStartedAt: Date | null
    state: string | null
    _count: CronJobsCountAggregateOutputType | null
    _min: CronJobsMinAggregateOutputType | null
    _max: CronJobsMaxAggregateOutputType | null
  }

  type GetCronJobsGroupByPayload<T extends CronJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CronJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CronJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CronJobsGroupByOutputType[P]>
            : GetScalarType<T[P], CronJobsGroupByOutputType[P]>
        }
      >
    >


  export type CronJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    lastRun?: boolean
    jobStartedAt?: boolean
    state?: boolean
  }, ExtArgs["result"]["cronJobs"]>

  export type CronJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    lastRun?: boolean
    jobStartedAt?: boolean
    state?: boolean
  }, ExtArgs["result"]["cronJobs"]>

  export type CronJobsSelectScalar = {
    name?: boolean
    lastRun?: boolean
    jobStartedAt?: boolean
    state?: boolean
  }


  export type $CronJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CronJobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      lastRun: Date | null
      jobStartedAt: Date | null
      state: string | null
    }, ExtArgs["result"]["cronJobs"]>
    composites: {}
  }

  type CronJobsGetPayload<S extends boolean | null | undefined | CronJobsDefaultArgs> = $Result.GetResult<Prisma.$CronJobsPayload, S>

  type CronJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CronJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CronJobsCountAggregateInputType | true
    }

  export interface CronJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CronJobs'], meta: { name: 'CronJobs' } }
    /**
     * Find zero or one CronJobs that matches the filter.
     * @param {CronJobsFindUniqueArgs} args - Arguments to find a CronJobs
     * @example
     * // Get one CronJobs
     * const cronJobs = await prisma.cronJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CronJobsFindUniqueArgs>(args: SelectSubset<T, CronJobsFindUniqueArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CronJobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CronJobsFindUniqueOrThrowArgs} args - Arguments to find a CronJobs
     * @example
     * // Get one CronJobs
     * const cronJobs = await prisma.cronJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CronJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, CronJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CronJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsFindFirstArgs} args - Arguments to find a CronJobs
     * @example
     * // Get one CronJobs
     * const cronJobs = await prisma.cronJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CronJobsFindFirstArgs>(args?: SelectSubset<T, CronJobsFindFirstArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CronJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsFindFirstOrThrowArgs} args - Arguments to find a CronJobs
     * @example
     * // Get one CronJobs
     * const cronJobs = await prisma.cronJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CronJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, CronJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CronJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CronJobs
     * const cronJobs = await prisma.cronJobs.findMany()
     * 
     * // Get first 10 CronJobs
     * const cronJobs = await prisma.cronJobs.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const cronJobsWithNameOnly = await prisma.cronJobs.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends CronJobsFindManyArgs>(args?: SelectSubset<T, CronJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CronJobs.
     * @param {CronJobsCreateArgs} args - Arguments to create a CronJobs.
     * @example
     * // Create one CronJobs
     * const CronJobs = await prisma.cronJobs.create({
     *   data: {
     *     // ... data to create a CronJobs
     *   }
     * })
     * 
     */
    create<T extends CronJobsCreateArgs>(args: SelectSubset<T, CronJobsCreateArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CronJobs.
     * @param {CronJobsCreateManyArgs} args - Arguments to create many CronJobs.
     * @example
     * // Create many CronJobs
     * const cronJobs = await prisma.cronJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CronJobsCreateManyArgs>(args?: SelectSubset<T, CronJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CronJobs and returns the data saved in the database.
     * @param {CronJobsCreateManyAndReturnArgs} args - Arguments to create many CronJobs.
     * @example
     * // Create many CronJobs
     * const cronJobs = await prisma.cronJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CronJobs and only return the `name`
     * const cronJobsWithNameOnly = await prisma.cronJobs.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CronJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, CronJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CronJobs.
     * @param {CronJobsDeleteArgs} args - Arguments to delete one CronJobs.
     * @example
     * // Delete one CronJobs
     * const CronJobs = await prisma.cronJobs.delete({
     *   where: {
     *     // ... filter to delete one CronJobs
     *   }
     * })
     * 
     */
    delete<T extends CronJobsDeleteArgs>(args: SelectSubset<T, CronJobsDeleteArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CronJobs.
     * @param {CronJobsUpdateArgs} args - Arguments to update one CronJobs.
     * @example
     * // Update one CronJobs
     * const cronJobs = await prisma.cronJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CronJobsUpdateArgs>(args: SelectSubset<T, CronJobsUpdateArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CronJobs.
     * @param {CronJobsDeleteManyArgs} args - Arguments to filter CronJobs to delete.
     * @example
     * // Delete a few CronJobs
     * const { count } = await prisma.cronJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CronJobsDeleteManyArgs>(args?: SelectSubset<T, CronJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CronJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CronJobs
     * const cronJobs = await prisma.cronJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CronJobsUpdateManyArgs>(args: SelectSubset<T, CronJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CronJobs.
     * @param {CronJobsUpsertArgs} args - Arguments to update or create a CronJobs.
     * @example
     * // Update or create a CronJobs
     * const cronJobs = await prisma.cronJobs.upsert({
     *   create: {
     *     // ... data to create a CronJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CronJobs we want to update
     *   }
     * })
     */
    upsert<T extends CronJobsUpsertArgs>(args: SelectSubset<T, CronJobsUpsertArgs<ExtArgs>>): Prisma__CronJobsClient<$Result.GetResult<Prisma.$CronJobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CronJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsCountArgs} args - Arguments to filter CronJobs to count.
     * @example
     * // Count the number of CronJobs
     * const count = await prisma.cronJobs.count({
     *   where: {
     *     // ... the filter for the CronJobs we want to count
     *   }
     * })
    **/
    count<T extends CronJobsCountArgs>(
      args?: Subset<T, CronJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CronJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CronJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CronJobsAggregateArgs>(args: Subset<T, CronJobsAggregateArgs>): Prisma.PrismaPromise<GetCronJobsAggregateType<T>>

    /**
     * Group by CronJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CronJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CronJobsGroupByArgs['orderBy'] }
        : { orderBy?: CronJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CronJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCronJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CronJobs model
   */
  readonly fields: CronJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CronJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CronJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CronJobs model
   */ 
  interface CronJobsFieldRefs {
    readonly name: FieldRef<"CronJobs", 'String'>
    readonly lastRun: FieldRef<"CronJobs", 'DateTime'>
    readonly jobStartedAt: FieldRef<"CronJobs", 'DateTime'>
    readonly state: FieldRef<"CronJobs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CronJobs findUnique
   */
  export type CronJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * Filter, which CronJobs to fetch.
     */
    where: CronJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs findUniqueOrThrow
   */
  export type CronJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * Filter, which CronJobs to fetch.
     */
    where: CronJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs findFirst
   */
  export type CronJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * Filter, which CronJobs to fetch.
     */
    where?: CronJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobs to fetch.
     */
    orderBy?: CronJobsOrderByWithRelationInput | CronJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronJobs.
     */
    cursor?: CronJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronJobs.
     */
    distinct?: CronJobsScalarFieldEnum | CronJobsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs findFirstOrThrow
   */
  export type CronJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * Filter, which CronJobs to fetch.
     */
    where?: CronJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobs to fetch.
     */
    orderBy?: CronJobsOrderByWithRelationInput | CronJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronJobs.
     */
    cursor?: CronJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronJobs.
     */
    distinct?: CronJobsScalarFieldEnum | CronJobsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs findMany
   */
  export type CronJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * Filter, which CronJobs to fetch.
     */
    where?: CronJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobs to fetch.
     */
    orderBy?: CronJobsOrderByWithRelationInput | CronJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CronJobs.
     */
    cursor?: CronJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobs.
     */
    skip?: number
    distinct?: CronJobsScalarFieldEnum | CronJobsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs create
   */
  export type CronJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * The data needed to create a CronJobs.
     */
    data: XOR<CronJobsCreateInput, CronJobsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs createMany
   */
  export type CronJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CronJobs.
     */
    data: CronJobsCreateManyInput | CronJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronJobs createManyAndReturn
   */
  export type CronJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CronJobs.
     */
    data: CronJobsCreateManyInput | CronJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronJobs update
   */
  export type CronJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * The data needed to update a CronJobs.
     */
    data: XOR<CronJobsUpdateInput, CronJobsUncheckedUpdateInput>
    /**
     * Choose, which CronJobs to update.
     */
    where: CronJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs updateMany
   */
  export type CronJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CronJobs.
     */
    data: XOR<CronJobsUpdateManyMutationInput, CronJobsUncheckedUpdateManyInput>
    /**
     * Filter which CronJobs to update
     */
    where?: CronJobsWhereInput
  }

  /**
   * CronJobs upsert
   */
  export type CronJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * The filter to search for the CronJobs to update in case it exists.
     */
    where: CronJobsWhereUniqueInput
    /**
     * In case the CronJobs found by the `where` argument doesn't exist, create a new CronJobs with this data.
     */
    create: XOR<CronJobsCreateInput, CronJobsUncheckedCreateInput>
    /**
     * In case the CronJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CronJobsUpdateInput, CronJobsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs delete
   */
  export type CronJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
    /**
     * Filter which CronJobs to delete.
     */
    where: CronJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CronJobs deleteMany
   */
  export type CronJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronJobs to delete
     */
    where?: CronJobsWhereInput
  }

  /**
   * CronJobs without action
   */
  export type CronJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobs
     */
    select?: CronJobsSelect<ExtArgs> | null
  }


  /**
   * Model Dataset
   */

  export type AggregateDataset = {
    _count: DatasetCountAggregateOutputType | null
    _min: DatasetMinAggregateOutputType | null
    _max: DatasetMaxAggregateOutputType | null
  }

  export type DatasetMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatasetMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatasetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dataset to aggregate.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Datasets
    **/
    _count?: true | DatasetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetMaxAggregateInputType
  }

  export type GetDatasetAggregateType<T extends DatasetAggregateArgs> = {
        [P in keyof T & keyof AggregateDataset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataset[P]>
      : GetScalarType<T[P], AggregateDataset[P]>
  }




  export type DatasetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetWhereInput
    orderBy?: DatasetOrderByWithAggregationInput | DatasetOrderByWithAggregationInput[]
    by: DatasetScalarFieldEnum[] | DatasetScalarFieldEnum
    having?: DatasetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetCountAggregateInputType | true
    _min?: DatasetMinAggregateInputType
    _max?: DatasetMaxAggregateInputType
  }

  export type DatasetGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DatasetCountAggregateOutputType | null
    _min: DatasetMinAggregateOutputType | null
    _max: DatasetMaxAggregateOutputType | null
  }

  type GetDatasetGroupByPayload<T extends DatasetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetGroupByOutputType[P]>
        }
      >
    >


  export type DatasetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    datasetItems?: boolean | Dataset$datasetItemsArgs<ExtArgs>
    datasetRuns?: boolean | Dataset$datasetRunsArgs<ExtArgs>
    _count?: boolean | DatasetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatasetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    datasetItems?: boolean | Dataset$datasetItemsArgs<ExtArgs>
    datasetRuns?: boolean | Dataset$datasetRunsArgs<ExtArgs>
    _count?: boolean | DatasetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatasetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $DatasetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dataset"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      datasetItems: Prisma.$DatasetItemPayload<ExtArgs>[]
      datasetRuns: Prisma.$DatasetRunsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataset"]>
    composites: {}
  }

  type DatasetGetPayload<S extends boolean | null | undefined | DatasetDefaultArgs> = $Result.GetResult<Prisma.$DatasetPayload, S>

  type DatasetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: DatasetCountAggregateInputType | true
    }

  export interface DatasetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dataset'], meta: { name: 'Dataset' } }
    /**
     * Find zero or one Dataset that matches the filter.
     * @param {DatasetFindUniqueArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetFindUniqueArgs>(args: SelectSubset<T, DatasetFindUniqueArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dataset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetFindUniqueOrThrowArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dataset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindFirstArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetFindFirstArgs>(args?: SelectSubset<T, DatasetFindFirstArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dataset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindFirstOrThrowArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Datasets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datasets
     * const datasets = await prisma.dataset.findMany()
     * 
     * // Get first 10 Datasets
     * const datasets = await prisma.dataset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetWithIdOnly = await prisma.dataset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetFindManyArgs>(args?: SelectSubset<T, DatasetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dataset.
     * @param {DatasetCreateArgs} args - Arguments to create a Dataset.
     * @example
     * // Create one Dataset
     * const Dataset = await prisma.dataset.create({
     *   data: {
     *     // ... data to create a Dataset
     *   }
     * })
     * 
     */
    create<T extends DatasetCreateArgs>(args: SelectSubset<T, DatasetCreateArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Datasets.
     * @param {DatasetCreateManyArgs} args - Arguments to create many Datasets.
     * @example
     * // Create many Datasets
     * const dataset = await prisma.dataset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetCreateManyArgs>(args?: SelectSubset<T, DatasetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Datasets and returns the data saved in the database.
     * @param {DatasetCreateManyAndReturnArgs} args - Arguments to create many Datasets.
     * @example
     * // Create many Datasets
     * const dataset = await prisma.dataset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Datasets and only return the `id`
     * const datasetWithIdOnly = await prisma.dataset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dataset.
     * @param {DatasetDeleteArgs} args - Arguments to delete one Dataset.
     * @example
     * // Delete one Dataset
     * const Dataset = await prisma.dataset.delete({
     *   where: {
     *     // ... filter to delete one Dataset
     *   }
     * })
     * 
     */
    delete<T extends DatasetDeleteArgs>(args: SelectSubset<T, DatasetDeleteArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dataset.
     * @param {DatasetUpdateArgs} args - Arguments to update one Dataset.
     * @example
     * // Update one Dataset
     * const dataset = await prisma.dataset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetUpdateArgs>(args: SelectSubset<T, DatasetUpdateArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Datasets.
     * @param {DatasetDeleteManyArgs} args - Arguments to filter Datasets to delete.
     * @example
     * // Delete a few Datasets
     * const { count } = await prisma.dataset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetDeleteManyArgs>(args?: SelectSubset<T, DatasetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datasets
     * const dataset = await prisma.dataset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetUpdateManyArgs>(args: SelectSubset<T, DatasetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dataset.
     * @param {DatasetUpsertArgs} args - Arguments to update or create a Dataset.
     * @example
     * // Update or create a Dataset
     * const dataset = await prisma.dataset.upsert({
     *   create: {
     *     // ... data to create a Dataset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dataset we want to update
     *   }
     * })
     */
    upsert<T extends DatasetUpsertArgs>(args: SelectSubset<T, DatasetUpsertArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Datasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetCountArgs} args - Arguments to filter Datasets to count.
     * @example
     * // Count the number of Datasets
     * const count = await prisma.dataset.count({
     *   where: {
     *     // ... the filter for the Datasets we want to count
     *   }
     * })
    **/
    count<T extends DatasetCountArgs>(
      args?: Subset<T, DatasetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetAggregateArgs>(args: Subset<T, DatasetAggregateArgs>): Prisma.PrismaPromise<GetDatasetAggregateType<T>>

    /**
     * Group by Dataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetGroupByArgs['orderBy'] }
        : { orderBy?: DatasetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dataset model
   */
  readonly fields: DatasetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dataset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    datasetItems<T extends Dataset$datasetItemsArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$datasetItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findMany"> | Null>
    datasetRuns<T extends Dataset$datasetRunsArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$datasetRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dataset model
   */ 
  interface DatasetFieldRefs {
    readonly id: FieldRef<"Dataset", 'String'>
    readonly projectId: FieldRef<"Dataset", 'String'>
    readonly name: FieldRef<"Dataset", 'String'>
    readonly description: FieldRef<"Dataset", 'String'>
    readonly metadata: FieldRef<"Dataset", 'Json'>
    readonly createdAt: FieldRef<"Dataset", 'DateTime'>
    readonly updatedAt: FieldRef<"Dataset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dataset findUnique
   */
  export type DatasetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where: DatasetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset findUniqueOrThrow
   */
  export type DatasetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where: DatasetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset findFirst
   */
  export type DatasetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Datasets.
     */
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset findFirstOrThrow
   */
  export type DatasetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Datasets.
     */
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset findMany
   */
  export type DatasetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Datasets to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset create
   */
  export type DatasetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The data needed to create a Dataset.
     */
    data: XOR<DatasetCreateInput, DatasetUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset createMany
   */
  export type DatasetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Datasets.
     */
    data: DatasetCreateManyInput | DatasetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dataset createManyAndReturn
   */
  export type DatasetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Datasets.
     */
    data: DatasetCreateManyInput | DatasetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dataset update
   */
  export type DatasetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The data needed to update a Dataset.
     */
    data: XOR<DatasetUpdateInput, DatasetUncheckedUpdateInput>
    /**
     * Choose, which Dataset to update.
     */
    where: DatasetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset updateMany
   */
  export type DatasetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Datasets.
     */
    data: XOR<DatasetUpdateManyMutationInput, DatasetUncheckedUpdateManyInput>
    /**
     * Filter which Datasets to update
     */
    where?: DatasetWhereInput
  }

  /**
   * Dataset upsert
   */
  export type DatasetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The filter to search for the Dataset to update in case it exists.
     */
    where: DatasetWhereUniqueInput
    /**
     * In case the Dataset found by the `where` argument doesn't exist, create a new Dataset with this data.
     */
    create: XOR<DatasetCreateInput, DatasetUncheckedCreateInput>
    /**
     * In case the Dataset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetUpdateInput, DatasetUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset delete
   */
  export type DatasetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter which Dataset to delete.
     */
    where: DatasetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dataset deleteMany
   */
  export type DatasetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Datasets to delete
     */
    where?: DatasetWhereInput
  }

  /**
   * Dataset.datasetItems
   */
  export type Dataset$datasetItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    where?: DatasetItemWhereInput
    orderBy?: DatasetItemOrderByWithRelationInput | DatasetItemOrderByWithRelationInput[]
    cursor?: DatasetItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetItemScalarFieldEnum | DatasetItemScalarFieldEnum[]
  }

  /**
   * Dataset.datasetRuns
   */
  export type Dataset$datasetRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    where?: DatasetRunsWhereInput
    orderBy?: DatasetRunsOrderByWithRelationInput | DatasetRunsOrderByWithRelationInput[]
    cursor?: DatasetRunsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetRunsScalarFieldEnum | DatasetRunsScalarFieldEnum[]
  }

  /**
   * Dataset without action
   */
  export type DatasetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
  }


  /**
   * Model DatasetItem
   */

  export type AggregateDatasetItem = {
    _count: DatasetItemCountAggregateOutputType | null
    _min: DatasetItemMinAggregateOutputType | null
    _max: DatasetItemMaxAggregateOutputType | null
  }

  export type DatasetItemMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    status: $Enums.DatasetStatus | null
    sourceTraceId: string | null
    sourceObservationId: string | null
    datasetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetItemMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    status: $Enums.DatasetStatus | null
    sourceTraceId: string | null
    sourceObservationId: string | null
    datasetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetItemCountAggregateOutputType = {
    id: number
    projectId: number
    status: number
    input: number
    expectedOutput: number
    metadata: number
    sourceTraceId: number
    sourceObservationId: number
    datasetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatasetItemMinAggregateInputType = {
    id?: true
    projectId?: true
    status?: true
    sourceTraceId?: true
    sourceObservationId?: true
    datasetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetItemMaxAggregateInputType = {
    id?: true
    projectId?: true
    status?: true
    sourceTraceId?: true
    sourceObservationId?: true
    datasetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetItemCountAggregateInputType = {
    id?: true
    projectId?: true
    status?: true
    input?: true
    expectedOutput?: true
    metadata?: true
    sourceTraceId?: true
    sourceObservationId?: true
    datasetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatasetItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetItem to aggregate.
     */
    where?: DatasetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetItems to fetch.
     */
    orderBy?: DatasetItemOrderByWithRelationInput | DatasetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatasetItems
    **/
    _count?: true | DatasetItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetItemMaxAggregateInputType
  }

  export type GetDatasetItemAggregateType<T extends DatasetItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasetItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasetItem[P]>
      : GetScalarType<T[P], AggregateDatasetItem[P]>
  }




  export type DatasetItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetItemWhereInput
    orderBy?: DatasetItemOrderByWithAggregationInput | DatasetItemOrderByWithAggregationInput[]
    by: DatasetItemScalarFieldEnum[] | DatasetItemScalarFieldEnum
    having?: DatasetItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetItemCountAggregateInputType | true
    _min?: DatasetItemMinAggregateInputType
    _max?: DatasetItemMaxAggregateInputType
  }

  export type DatasetItemGroupByOutputType = {
    id: string
    projectId: string
    status: $Enums.DatasetStatus
    input: JsonValue | null
    expectedOutput: JsonValue | null
    metadata: JsonValue | null
    sourceTraceId: string | null
    sourceObservationId: string | null
    datasetId: string
    createdAt: Date
    updatedAt: Date
    _count: DatasetItemCountAggregateOutputType | null
    _min: DatasetItemMinAggregateOutputType | null
    _max: DatasetItemMaxAggregateOutputType | null
  }

  type GetDatasetItemGroupByPayload<T extends DatasetItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetItemGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetItemGroupByOutputType[P]>
        }
      >
    >


  export type DatasetItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    status?: boolean
    input?: boolean
    expectedOutput?: boolean
    metadata?: boolean
    sourceTraceId?: boolean
    sourceObservationId?: boolean
    datasetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
    datasetRunItems?: boolean | DatasetItem$datasetRunItemsArgs<ExtArgs>
    _count?: boolean | DatasetItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetItem"]>

  export type DatasetItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    status?: boolean
    input?: boolean
    expectedOutput?: boolean
    metadata?: boolean
    sourceTraceId?: boolean
    sourceObservationId?: boolean
    datasetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetItem"]>

  export type DatasetItemSelectScalar = {
    id?: boolean
    projectId?: boolean
    status?: boolean
    input?: boolean
    expectedOutput?: boolean
    metadata?: boolean
    sourceTraceId?: boolean
    sourceObservationId?: boolean
    datasetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatasetItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
    datasetRunItems?: boolean | DatasetItem$datasetRunItemsArgs<ExtArgs>
    _count?: boolean | DatasetItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatasetItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $DatasetItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatasetItem"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
      datasetRunItems: Prisma.$DatasetRunItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      status: $Enums.DatasetStatus
      input: Prisma.JsonValue | null
      expectedOutput: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      sourceTraceId: string | null
      sourceObservationId: string | null
      datasetId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["datasetItem"]>
    composites: {}
  }

  type DatasetItemGetPayload<S extends boolean | null | undefined | DatasetItemDefaultArgs> = $Result.GetResult<Prisma.$DatasetItemPayload, S>

  type DatasetItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetItemFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: DatasetItemCountAggregateInputType | true
    }

  export interface DatasetItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatasetItem'], meta: { name: 'DatasetItem' } }
    /**
     * Find zero or one DatasetItem that matches the filter.
     * @param {DatasetItemFindUniqueArgs} args - Arguments to find a DatasetItem
     * @example
     * // Get one DatasetItem
     * const datasetItem = await prisma.datasetItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetItemFindUniqueArgs>(args: SelectSubset<T, DatasetItemFindUniqueArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DatasetItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetItemFindUniqueOrThrowArgs} args - Arguments to find a DatasetItem
     * @example
     * // Get one DatasetItem
     * const datasetItem = await prisma.datasetItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetItemFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DatasetItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemFindFirstArgs} args - Arguments to find a DatasetItem
     * @example
     * // Get one DatasetItem
     * const datasetItem = await prisma.datasetItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetItemFindFirstArgs>(args?: SelectSubset<T, DatasetItemFindFirstArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DatasetItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemFindFirstOrThrowArgs} args - Arguments to find a DatasetItem
     * @example
     * // Get one DatasetItem
     * const datasetItem = await prisma.datasetItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetItemFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DatasetItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatasetItems
     * const datasetItems = await prisma.datasetItem.findMany()
     * 
     * // Get first 10 DatasetItems
     * const datasetItems = await prisma.datasetItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetItemWithIdOnly = await prisma.datasetItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetItemFindManyArgs>(args?: SelectSubset<T, DatasetItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DatasetItem.
     * @param {DatasetItemCreateArgs} args - Arguments to create a DatasetItem.
     * @example
     * // Create one DatasetItem
     * const DatasetItem = await prisma.datasetItem.create({
     *   data: {
     *     // ... data to create a DatasetItem
     *   }
     * })
     * 
     */
    create<T extends DatasetItemCreateArgs>(args: SelectSubset<T, DatasetItemCreateArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DatasetItems.
     * @param {DatasetItemCreateManyArgs} args - Arguments to create many DatasetItems.
     * @example
     * // Create many DatasetItems
     * const datasetItem = await prisma.datasetItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetItemCreateManyArgs>(args?: SelectSubset<T, DatasetItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatasetItems and returns the data saved in the database.
     * @param {DatasetItemCreateManyAndReturnArgs} args - Arguments to create many DatasetItems.
     * @example
     * // Create many DatasetItems
     * const datasetItem = await prisma.datasetItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatasetItems and only return the `id`
     * const datasetItemWithIdOnly = await prisma.datasetItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetItemCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DatasetItem.
     * @param {DatasetItemDeleteArgs} args - Arguments to delete one DatasetItem.
     * @example
     * // Delete one DatasetItem
     * const DatasetItem = await prisma.datasetItem.delete({
     *   where: {
     *     // ... filter to delete one DatasetItem
     *   }
     * })
     * 
     */
    delete<T extends DatasetItemDeleteArgs>(args: SelectSubset<T, DatasetItemDeleteArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DatasetItem.
     * @param {DatasetItemUpdateArgs} args - Arguments to update one DatasetItem.
     * @example
     * // Update one DatasetItem
     * const datasetItem = await prisma.datasetItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetItemUpdateArgs>(args: SelectSubset<T, DatasetItemUpdateArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DatasetItems.
     * @param {DatasetItemDeleteManyArgs} args - Arguments to filter DatasetItems to delete.
     * @example
     * // Delete a few DatasetItems
     * const { count } = await prisma.datasetItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetItemDeleteManyArgs>(args?: SelectSubset<T, DatasetItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatasetItems
     * const datasetItem = await prisma.datasetItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetItemUpdateManyArgs>(args: SelectSubset<T, DatasetItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatasetItem.
     * @param {DatasetItemUpsertArgs} args - Arguments to update or create a DatasetItem.
     * @example
     * // Update or create a DatasetItem
     * const datasetItem = await prisma.datasetItem.upsert({
     *   create: {
     *     // ... data to create a DatasetItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatasetItem we want to update
     *   }
     * })
     */
    upsert<T extends DatasetItemUpsertArgs>(args: SelectSubset<T, DatasetItemUpsertArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DatasetItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemCountArgs} args - Arguments to filter DatasetItems to count.
     * @example
     * // Count the number of DatasetItems
     * const count = await prisma.datasetItem.count({
     *   where: {
     *     // ... the filter for the DatasetItems we want to count
     *   }
     * })
    **/
    count<T extends DatasetItemCountArgs>(
      args?: Subset<T, DatasetItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatasetItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetItemAggregateArgs>(args: Subset<T, DatasetItemAggregateArgs>): Prisma.PrismaPromise<GetDatasetItemAggregateType<T>>

    /**
     * Group by DatasetItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetItemGroupByArgs['orderBy'] }
        : { orderBy?: DatasetItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatasetItem model
   */
  readonly fields: DatasetItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatasetItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    datasetRunItems<T extends DatasetItem$datasetRunItemsArgs<ExtArgs> = {}>(args?: Subset<T, DatasetItem$datasetRunItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatasetItem model
   */ 
  interface DatasetItemFieldRefs {
    readonly id: FieldRef<"DatasetItem", 'String'>
    readonly projectId: FieldRef<"DatasetItem", 'String'>
    readonly status: FieldRef<"DatasetItem", 'DatasetStatus'>
    readonly input: FieldRef<"DatasetItem", 'Json'>
    readonly expectedOutput: FieldRef<"DatasetItem", 'Json'>
    readonly metadata: FieldRef<"DatasetItem", 'Json'>
    readonly sourceTraceId: FieldRef<"DatasetItem", 'String'>
    readonly sourceObservationId: FieldRef<"DatasetItem", 'String'>
    readonly datasetId: FieldRef<"DatasetItem", 'String'>
    readonly createdAt: FieldRef<"DatasetItem", 'DateTime'>
    readonly updatedAt: FieldRef<"DatasetItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatasetItem findUnique
   */
  export type DatasetItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * Filter, which DatasetItem to fetch.
     */
    where: DatasetItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem findUniqueOrThrow
   */
  export type DatasetItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * Filter, which DatasetItem to fetch.
     */
    where: DatasetItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem findFirst
   */
  export type DatasetItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * Filter, which DatasetItem to fetch.
     */
    where?: DatasetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetItems to fetch.
     */
    orderBy?: DatasetItemOrderByWithRelationInput | DatasetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetItems.
     */
    cursor?: DatasetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetItems.
     */
    distinct?: DatasetItemScalarFieldEnum | DatasetItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem findFirstOrThrow
   */
  export type DatasetItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * Filter, which DatasetItem to fetch.
     */
    where?: DatasetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetItems to fetch.
     */
    orderBy?: DatasetItemOrderByWithRelationInput | DatasetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetItems.
     */
    cursor?: DatasetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetItems.
     */
    distinct?: DatasetItemScalarFieldEnum | DatasetItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem findMany
   */
  export type DatasetItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * Filter, which DatasetItems to fetch.
     */
    where?: DatasetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetItems to fetch.
     */
    orderBy?: DatasetItemOrderByWithRelationInput | DatasetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatasetItems.
     */
    cursor?: DatasetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetItems.
     */
    skip?: number
    distinct?: DatasetItemScalarFieldEnum | DatasetItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem create
   */
  export type DatasetItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * The data needed to create a DatasetItem.
     */
    data: XOR<DatasetItemCreateInput, DatasetItemUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem createMany
   */
  export type DatasetItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatasetItems.
     */
    data: DatasetItemCreateManyInput | DatasetItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatasetItem createManyAndReturn
   */
  export type DatasetItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DatasetItems.
     */
    data: DatasetItemCreateManyInput | DatasetItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetItem update
   */
  export type DatasetItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * The data needed to update a DatasetItem.
     */
    data: XOR<DatasetItemUpdateInput, DatasetItemUncheckedUpdateInput>
    /**
     * Choose, which DatasetItem to update.
     */
    where: DatasetItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem updateMany
   */
  export type DatasetItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatasetItems.
     */
    data: XOR<DatasetItemUpdateManyMutationInput, DatasetItemUncheckedUpdateManyInput>
    /**
     * Filter which DatasetItems to update
     */
    where?: DatasetItemWhereInput
  }

  /**
   * DatasetItem upsert
   */
  export type DatasetItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * The filter to search for the DatasetItem to update in case it exists.
     */
    where: DatasetItemWhereUniqueInput
    /**
     * In case the DatasetItem found by the `where` argument doesn't exist, create a new DatasetItem with this data.
     */
    create: XOR<DatasetItemCreateInput, DatasetItemUncheckedCreateInput>
    /**
     * In case the DatasetItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetItemUpdateInput, DatasetItemUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem delete
   */
  export type DatasetItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
    /**
     * Filter which DatasetItem to delete.
     */
    where: DatasetItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetItem deleteMany
   */
  export type DatasetItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetItems to delete
     */
    where?: DatasetItemWhereInput
  }

  /**
   * DatasetItem.datasetRunItems
   */
  export type DatasetItem$datasetRunItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    where?: DatasetRunItemsWhereInput
    orderBy?: DatasetRunItemsOrderByWithRelationInput | DatasetRunItemsOrderByWithRelationInput[]
    cursor?: DatasetRunItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetRunItemsScalarFieldEnum | DatasetRunItemsScalarFieldEnum[]
  }

  /**
   * DatasetItem without action
   */
  export type DatasetItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetItem
     */
    select?: DatasetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetItemInclude<ExtArgs> | null
  }


  /**
   * Model DatasetRuns
   */

  export type AggregateDatasetRuns = {
    _count: DatasetRunsCountAggregateOutputType | null
    _min: DatasetRunsMinAggregateOutputType | null
    _max: DatasetRunsMaxAggregateOutputType | null
  }

  export type DatasetRunsMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    datasetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetRunsMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    datasetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetRunsCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    metadata: number
    datasetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatasetRunsMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    datasetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetRunsMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    datasetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetRunsCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    metadata?: true
    datasetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatasetRunsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetRuns to aggregate.
     */
    where?: DatasetRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRuns to fetch.
     */
    orderBy?: DatasetRunsOrderByWithRelationInput | DatasetRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatasetRuns
    **/
    _count?: true | DatasetRunsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetRunsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetRunsMaxAggregateInputType
  }

  export type GetDatasetRunsAggregateType<T extends DatasetRunsAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasetRuns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasetRuns[P]>
      : GetScalarType<T[P], AggregateDatasetRuns[P]>
  }




  export type DatasetRunsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetRunsWhereInput
    orderBy?: DatasetRunsOrderByWithAggregationInput | DatasetRunsOrderByWithAggregationInput[]
    by: DatasetRunsScalarFieldEnum[] | DatasetRunsScalarFieldEnum
    having?: DatasetRunsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetRunsCountAggregateInputType | true
    _min?: DatasetRunsMinAggregateInputType
    _max?: DatasetRunsMaxAggregateInputType
  }

  export type DatasetRunsGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    metadata: JsonValue | null
    datasetId: string
    createdAt: Date
    updatedAt: Date
    _count: DatasetRunsCountAggregateOutputType | null
    _min: DatasetRunsMinAggregateOutputType | null
    _max: DatasetRunsMaxAggregateOutputType | null
  }

  type GetDatasetRunsGroupByPayload<T extends DatasetRunsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetRunsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetRunsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetRunsGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetRunsGroupByOutputType[P]>
        }
      >
    >


  export type DatasetRunsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    metadata?: boolean
    datasetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
    datasetRunItems?: boolean | DatasetRuns$datasetRunItemsArgs<ExtArgs>
    _count?: boolean | DatasetRunsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetRuns"]>

  export type DatasetRunsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    metadata?: boolean
    datasetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetRuns"]>

  export type DatasetRunsSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    metadata?: boolean
    datasetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatasetRunsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
    datasetRunItems?: boolean | DatasetRuns$datasetRunItemsArgs<ExtArgs>
    _count?: boolean | DatasetRunsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatasetRunsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $DatasetRunsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatasetRuns"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
      datasetRunItems: Prisma.$DatasetRunItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      metadata: Prisma.JsonValue | null
      datasetId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["datasetRuns"]>
    composites: {}
  }

  type DatasetRunsGetPayload<S extends boolean | null | undefined | DatasetRunsDefaultArgs> = $Result.GetResult<Prisma.$DatasetRunsPayload, S>

  type DatasetRunsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetRunsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: DatasetRunsCountAggregateInputType | true
    }

  export interface DatasetRunsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatasetRuns'], meta: { name: 'DatasetRuns' } }
    /**
     * Find zero or one DatasetRuns that matches the filter.
     * @param {DatasetRunsFindUniqueArgs} args - Arguments to find a DatasetRuns
     * @example
     * // Get one DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetRunsFindUniqueArgs>(args: SelectSubset<T, DatasetRunsFindUniqueArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DatasetRuns that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetRunsFindUniqueOrThrowArgs} args - Arguments to find a DatasetRuns
     * @example
     * // Get one DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetRunsFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetRunsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DatasetRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsFindFirstArgs} args - Arguments to find a DatasetRuns
     * @example
     * // Get one DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetRunsFindFirstArgs>(args?: SelectSubset<T, DatasetRunsFindFirstArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DatasetRuns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsFindFirstOrThrowArgs} args - Arguments to find a DatasetRuns
     * @example
     * // Get one DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetRunsFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetRunsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DatasetRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.findMany()
     * 
     * // Get first 10 DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetRunsWithIdOnly = await prisma.datasetRuns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetRunsFindManyArgs>(args?: SelectSubset<T, DatasetRunsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DatasetRuns.
     * @param {DatasetRunsCreateArgs} args - Arguments to create a DatasetRuns.
     * @example
     * // Create one DatasetRuns
     * const DatasetRuns = await prisma.datasetRuns.create({
     *   data: {
     *     // ... data to create a DatasetRuns
     *   }
     * })
     * 
     */
    create<T extends DatasetRunsCreateArgs>(args: SelectSubset<T, DatasetRunsCreateArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DatasetRuns.
     * @param {DatasetRunsCreateManyArgs} args - Arguments to create many DatasetRuns.
     * @example
     * // Create many DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetRunsCreateManyArgs>(args?: SelectSubset<T, DatasetRunsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatasetRuns and returns the data saved in the database.
     * @param {DatasetRunsCreateManyAndReturnArgs} args - Arguments to create many DatasetRuns.
     * @example
     * // Create many DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatasetRuns and only return the `id`
     * const datasetRunsWithIdOnly = await prisma.datasetRuns.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetRunsCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetRunsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DatasetRuns.
     * @param {DatasetRunsDeleteArgs} args - Arguments to delete one DatasetRuns.
     * @example
     * // Delete one DatasetRuns
     * const DatasetRuns = await prisma.datasetRuns.delete({
     *   where: {
     *     // ... filter to delete one DatasetRuns
     *   }
     * })
     * 
     */
    delete<T extends DatasetRunsDeleteArgs>(args: SelectSubset<T, DatasetRunsDeleteArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DatasetRuns.
     * @param {DatasetRunsUpdateArgs} args - Arguments to update one DatasetRuns.
     * @example
     * // Update one DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetRunsUpdateArgs>(args: SelectSubset<T, DatasetRunsUpdateArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DatasetRuns.
     * @param {DatasetRunsDeleteManyArgs} args - Arguments to filter DatasetRuns to delete.
     * @example
     * // Delete a few DatasetRuns
     * const { count } = await prisma.datasetRuns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetRunsDeleteManyArgs>(args?: SelectSubset<T, DatasetRunsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetRunsUpdateManyArgs>(args: SelectSubset<T, DatasetRunsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatasetRuns.
     * @param {DatasetRunsUpsertArgs} args - Arguments to update or create a DatasetRuns.
     * @example
     * // Update or create a DatasetRuns
     * const datasetRuns = await prisma.datasetRuns.upsert({
     *   create: {
     *     // ... data to create a DatasetRuns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatasetRuns we want to update
     *   }
     * })
     */
    upsert<T extends DatasetRunsUpsertArgs>(args: SelectSubset<T, DatasetRunsUpsertArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DatasetRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsCountArgs} args - Arguments to filter DatasetRuns to count.
     * @example
     * // Count the number of DatasetRuns
     * const count = await prisma.datasetRuns.count({
     *   where: {
     *     // ... the filter for the DatasetRuns we want to count
     *   }
     * })
    **/
    count<T extends DatasetRunsCountArgs>(
      args?: Subset<T, DatasetRunsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetRunsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatasetRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetRunsAggregateArgs>(args: Subset<T, DatasetRunsAggregateArgs>): Prisma.PrismaPromise<GetDatasetRunsAggregateType<T>>

    /**
     * Group by DatasetRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetRunsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetRunsGroupByArgs['orderBy'] }
        : { orderBy?: DatasetRunsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetRunsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetRunsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatasetRuns model
   */
  readonly fields: DatasetRunsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatasetRuns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetRunsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    datasetRunItems<T extends DatasetRuns$datasetRunItemsArgs<ExtArgs> = {}>(args?: Subset<T, DatasetRuns$datasetRunItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatasetRuns model
   */ 
  interface DatasetRunsFieldRefs {
    readonly id: FieldRef<"DatasetRuns", 'String'>
    readonly projectId: FieldRef<"DatasetRuns", 'String'>
    readonly name: FieldRef<"DatasetRuns", 'String'>
    readonly description: FieldRef<"DatasetRuns", 'String'>
    readonly metadata: FieldRef<"DatasetRuns", 'Json'>
    readonly datasetId: FieldRef<"DatasetRuns", 'String'>
    readonly createdAt: FieldRef<"DatasetRuns", 'DateTime'>
    readonly updatedAt: FieldRef<"DatasetRuns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatasetRuns findUnique
   */
  export type DatasetRunsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRuns to fetch.
     */
    where: DatasetRunsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns findUniqueOrThrow
   */
  export type DatasetRunsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRuns to fetch.
     */
    where: DatasetRunsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns findFirst
   */
  export type DatasetRunsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRuns to fetch.
     */
    where?: DatasetRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRuns to fetch.
     */
    orderBy?: DatasetRunsOrderByWithRelationInput | DatasetRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetRuns.
     */
    cursor?: DatasetRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetRuns.
     */
    distinct?: DatasetRunsScalarFieldEnum | DatasetRunsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns findFirstOrThrow
   */
  export type DatasetRunsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRuns to fetch.
     */
    where?: DatasetRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRuns to fetch.
     */
    orderBy?: DatasetRunsOrderByWithRelationInput | DatasetRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetRuns.
     */
    cursor?: DatasetRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetRuns.
     */
    distinct?: DatasetRunsScalarFieldEnum | DatasetRunsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns findMany
   */
  export type DatasetRunsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRuns to fetch.
     */
    where?: DatasetRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRuns to fetch.
     */
    orderBy?: DatasetRunsOrderByWithRelationInput | DatasetRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatasetRuns.
     */
    cursor?: DatasetRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRuns.
     */
    skip?: number
    distinct?: DatasetRunsScalarFieldEnum | DatasetRunsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns create
   */
  export type DatasetRunsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * The data needed to create a DatasetRuns.
     */
    data: XOR<DatasetRunsCreateInput, DatasetRunsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns createMany
   */
  export type DatasetRunsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatasetRuns.
     */
    data: DatasetRunsCreateManyInput | DatasetRunsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatasetRuns createManyAndReturn
   */
  export type DatasetRunsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DatasetRuns.
     */
    data: DatasetRunsCreateManyInput | DatasetRunsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetRuns update
   */
  export type DatasetRunsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * The data needed to update a DatasetRuns.
     */
    data: XOR<DatasetRunsUpdateInput, DatasetRunsUncheckedUpdateInput>
    /**
     * Choose, which DatasetRuns to update.
     */
    where: DatasetRunsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns updateMany
   */
  export type DatasetRunsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatasetRuns.
     */
    data: XOR<DatasetRunsUpdateManyMutationInput, DatasetRunsUncheckedUpdateManyInput>
    /**
     * Filter which DatasetRuns to update
     */
    where?: DatasetRunsWhereInput
  }

  /**
   * DatasetRuns upsert
   */
  export type DatasetRunsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * The filter to search for the DatasetRuns to update in case it exists.
     */
    where: DatasetRunsWhereUniqueInput
    /**
     * In case the DatasetRuns found by the `where` argument doesn't exist, create a new DatasetRuns with this data.
     */
    create: XOR<DatasetRunsCreateInput, DatasetRunsUncheckedCreateInput>
    /**
     * In case the DatasetRuns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetRunsUpdateInput, DatasetRunsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns delete
   */
  export type DatasetRunsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
    /**
     * Filter which DatasetRuns to delete.
     */
    where: DatasetRunsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRuns deleteMany
   */
  export type DatasetRunsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetRuns to delete
     */
    where?: DatasetRunsWhereInput
  }

  /**
   * DatasetRuns.datasetRunItems
   */
  export type DatasetRuns$datasetRunItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    where?: DatasetRunItemsWhereInput
    orderBy?: DatasetRunItemsOrderByWithRelationInput | DatasetRunItemsOrderByWithRelationInput[]
    cursor?: DatasetRunItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetRunItemsScalarFieldEnum | DatasetRunItemsScalarFieldEnum[]
  }

  /**
   * DatasetRuns without action
   */
  export type DatasetRunsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRuns
     */
    select?: DatasetRunsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunsInclude<ExtArgs> | null
  }


  /**
   * Model DatasetRunItems
   */

  export type AggregateDatasetRunItems = {
    _count: DatasetRunItemsCountAggregateOutputType | null
    _min: DatasetRunItemsMinAggregateOutputType | null
    _max: DatasetRunItemsMaxAggregateOutputType | null
  }

  export type DatasetRunItemsMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    datasetRunId: string | null
    datasetItemId: string | null
    traceId: string | null
    observationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetRunItemsMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    datasetRunId: string | null
    datasetItemId: string | null
    traceId: string | null
    observationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetRunItemsCountAggregateOutputType = {
    id: number
    projectId: number
    datasetRunId: number
    datasetItemId: number
    traceId: number
    observationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatasetRunItemsMinAggregateInputType = {
    id?: true
    projectId?: true
    datasetRunId?: true
    datasetItemId?: true
    traceId?: true
    observationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetRunItemsMaxAggregateInputType = {
    id?: true
    projectId?: true
    datasetRunId?: true
    datasetItemId?: true
    traceId?: true
    observationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetRunItemsCountAggregateInputType = {
    id?: true
    projectId?: true
    datasetRunId?: true
    datasetItemId?: true
    traceId?: true
    observationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatasetRunItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetRunItems to aggregate.
     */
    where?: DatasetRunItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRunItems to fetch.
     */
    orderBy?: DatasetRunItemsOrderByWithRelationInput | DatasetRunItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetRunItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRunItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRunItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatasetRunItems
    **/
    _count?: true | DatasetRunItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetRunItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetRunItemsMaxAggregateInputType
  }

  export type GetDatasetRunItemsAggregateType<T extends DatasetRunItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasetRunItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasetRunItems[P]>
      : GetScalarType<T[P], AggregateDatasetRunItems[P]>
  }




  export type DatasetRunItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetRunItemsWhereInput
    orderBy?: DatasetRunItemsOrderByWithAggregationInput | DatasetRunItemsOrderByWithAggregationInput[]
    by: DatasetRunItemsScalarFieldEnum[] | DatasetRunItemsScalarFieldEnum
    having?: DatasetRunItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetRunItemsCountAggregateInputType | true
    _min?: DatasetRunItemsMinAggregateInputType
    _max?: DatasetRunItemsMaxAggregateInputType
  }

  export type DatasetRunItemsGroupByOutputType = {
    id: string
    projectId: string
    datasetRunId: string
    datasetItemId: string
    traceId: string
    observationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DatasetRunItemsCountAggregateOutputType | null
    _min: DatasetRunItemsMinAggregateOutputType | null
    _max: DatasetRunItemsMaxAggregateOutputType | null
  }

  type GetDatasetRunItemsGroupByPayload<T extends DatasetRunItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetRunItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetRunItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetRunItemsGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetRunItemsGroupByOutputType[P]>
        }
      >
    >


  export type DatasetRunItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    datasetRunId?: boolean
    datasetItemId?: boolean
    traceId?: boolean
    observationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    datasetRun?: boolean | DatasetRunsDefaultArgs<ExtArgs>
    datasetItem?: boolean | DatasetItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetRunItems"]>

  export type DatasetRunItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    datasetRunId?: boolean
    datasetItemId?: boolean
    traceId?: boolean
    observationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    datasetRun?: boolean | DatasetRunsDefaultArgs<ExtArgs>
    datasetItem?: boolean | DatasetItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetRunItems"]>

  export type DatasetRunItemsSelectScalar = {
    id?: boolean
    projectId?: boolean
    datasetRunId?: boolean
    datasetItemId?: boolean
    traceId?: boolean
    observationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatasetRunItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasetRun?: boolean | DatasetRunsDefaultArgs<ExtArgs>
    datasetItem?: boolean | DatasetItemDefaultArgs<ExtArgs>
  }
  export type DatasetRunItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasetRun?: boolean | DatasetRunsDefaultArgs<ExtArgs>
    datasetItem?: boolean | DatasetItemDefaultArgs<ExtArgs>
  }

  export type $DatasetRunItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatasetRunItems"
    objects: {
      datasetRun: Prisma.$DatasetRunsPayload<ExtArgs>
      datasetItem: Prisma.$DatasetItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      datasetRunId: string
      datasetItemId: string
      traceId: string
      observationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["datasetRunItems"]>
    composites: {}
  }

  type DatasetRunItemsGetPayload<S extends boolean | null | undefined | DatasetRunItemsDefaultArgs> = $Result.GetResult<Prisma.$DatasetRunItemsPayload, S>

  type DatasetRunItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetRunItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: DatasetRunItemsCountAggregateInputType | true
    }

  export interface DatasetRunItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatasetRunItems'], meta: { name: 'DatasetRunItems' } }
    /**
     * Find zero or one DatasetRunItems that matches the filter.
     * @param {DatasetRunItemsFindUniqueArgs} args - Arguments to find a DatasetRunItems
     * @example
     * // Get one DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetRunItemsFindUniqueArgs>(args: SelectSubset<T, DatasetRunItemsFindUniqueArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DatasetRunItems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetRunItemsFindUniqueOrThrowArgs} args - Arguments to find a DatasetRunItems
     * @example
     * // Get one DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetRunItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetRunItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DatasetRunItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsFindFirstArgs} args - Arguments to find a DatasetRunItems
     * @example
     * // Get one DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetRunItemsFindFirstArgs>(args?: SelectSubset<T, DatasetRunItemsFindFirstArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DatasetRunItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsFindFirstOrThrowArgs} args - Arguments to find a DatasetRunItems
     * @example
     * // Get one DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetRunItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetRunItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DatasetRunItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.findMany()
     * 
     * // Get first 10 DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetRunItemsWithIdOnly = await prisma.datasetRunItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetRunItemsFindManyArgs>(args?: SelectSubset<T, DatasetRunItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DatasetRunItems.
     * @param {DatasetRunItemsCreateArgs} args - Arguments to create a DatasetRunItems.
     * @example
     * // Create one DatasetRunItems
     * const DatasetRunItems = await prisma.datasetRunItems.create({
     *   data: {
     *     // ... data to create a DatasetRunItems
     *   }
     * })
     * 
     */
    create<T extends DatasetRunItemsCreateArgs>(args: SelectSubset<T, DatasetRunItemsCreateArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DatasetRunItems.
     * @param {DatasetRunItemsCreateManyArgs} args - Arguments to create many DatasetRunItems.
     * @example
     * // Create many DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetRunItemsCreateManyArgs>(args?: SelectSubset<T, DatasetRunItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatasetRunItems and returns the data saved in the database.
     * @param {DatasetRunItemsCreateManyAndReturnArgs} args - Arguments to create many DatasetRunItems.
     * @example
     * // Create many DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatasetRunItems and only return the `id`
     * const datasetRunItemsWithIdOnly = await prisma.datasetRunItems.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetRunItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetRunItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DatasetRunItems.
     * @param {DatasetRunItemsDeleteArgs} args - Arguments to delete one DatasetRunItems.
     * @example
     * // Delete one DatasetRunItems
     * const DatasetRunItems = await prisma.datasetRunItems.delete({
     *   where: {
     *     // ... filter to delete one DatasetRunItems
     *   }
     * })
     * 
     */
    delete<T extends DatasetRunItemsDeleteArgs>(args: SelectSubset<T, DatasetRunItemsDeleteArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DatasetRunItems.
     * @param {DatasetRunItemsUpdateArgs} args - Arguments to update one DatasetRunItems.
     * @example
     * // Update one DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetRunItemsUpdateArgs>(args: SelectSubset<T, DatasetRunItemsUpdateArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DatasetRunItems.
     * @param {DatasetRunItemsDeleteManyArgs} args - Arguments to filter DatasetRunItems to delete.
     * @example
     * // Delete a few DatasetRunItems
     * const { count } = await prisma.datasetRunItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetRunItemsDeleteManyArgs>(args?: SelectSubset<T, DatasetRunItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetRunItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetRunItemsUpdateManyArgs>(args: SelectSubset<T, DatasetRunItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatasetRunItems.
     * @param {DatasetRunItemsUpsertArgs} args - Arguments to update or create a DatasetRunItems.
     * @example
     * // Update or create a DatasetRunItems
     * const datasetRunItems = await prisma.datasetRunItems.upsert({
     *   create: {
     *     // ... data to create a DatasetRunItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatasetRunItems we want to update
     *   }
     * })
     */
    upsert<T extends DatasetRunItemsUpsertArgs>(args: SelectSubset<T, DatasetRunItemsUpsertArgs<ExtArgs>>): Prisma__DatasetRunItemsClient<$Result.GetResult<Prisma.$DatasetRunItemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DatasetRunItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsCountArgs} args - Arguments to filter DatasetRunItems to count.
     * @example
     * // Count the number of DatasetRunItems
     * const count = await prisma.datasetRunItems.count({
     *   where: {
     *     // ... the filter for the DatasetRunItems we want to count
     *   }
     * })
    **/
    count<T extends DatasetRunItemsCountArgs>(
      args?: Subset<T, DatasetRunItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetRunItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatasetRunItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetRunItemsAggregateArgs>(args: Subset<T, DatasetRunItemsAggregateArgs>): Prisma.PrismaPromise<GetDatasetRunItemsAggregateType<T>>

    /**
     * Group by DatasetRunItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetRunItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetRunItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetRunItemsGroupByArgs['orderBy'] }
        : { orderBy?: DatasetRunItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetRunItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetRunItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatasetRunItems model
   */
  readonly fields: DatasetRunItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatasetRunItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetRunItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    datasetRun<T extends DatasetRunsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetRunsDefaultArgs<ExtArgs>>): Prisma__DatasetRunsClient<$Result.GetResult<Prisma.$DatasetRunsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    datasetItem<T extends DatasetItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetItemDefaultArgs<ExtArgs>>): Prisma__DatasetItemClient<$Result.GetResult<Prisma.$DatasetItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatasetRunItems model
   */ 
  interface DatasetRunItemsFieldRefs {
    readonly id: FieldRef<"DatasetRunItems", 'String'>
    readonly projectId: FieldRef<"DatasetRunItems", 'String'>
    readonly datasetRunId: FieldRef<"DatasetRunItems", 'String'>
    readonly datasetItemId: FieldRef<"DatasetRunItems", 'String'>
    readonly traceId: FieldRef<"DatasetRunItems", 'String'>
    readonly observationId: FieldRef<"DatasetRunItems", 'String'>
    readonly createdAt: FieldRef<"DatasetRunItems", 'DateTime'>
    readonly updatedAt: FieldRef<"DatasetRunItems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatasetRunItems findUnique
   */
  export type DatasetRunItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRunItems to fetch.
     */
    where: DatasetRunItemsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems findUniqueOrThrow
   */
  export type DatasetRunItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRunItems to fetch.
     */
    where: DatasetRunItemsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems findFirst
   */
  export type DatasetRunItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRunItems to fetch.
     */
    where?: DatasetRunItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRunItems to fetch.
     */
    orderBy?: DatasetRunItemsOrderByWithRelationInput | DatasetRunItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetRunItems.
     */
    cursor?: DatasetRunItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRunItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRunItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetRunItems.
     */
    distinct?: DatasetRunItemsScalarFieldEnum | DatasetRunItemsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems findFirstOrThrow
   */
  export type DatasetRunItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRunItems to fetch.
     */
    where?: DatasetRunItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRunItems to fetch.
     */
    orderBy?: DatasetRunItemsOrderByWithRelationInput | DatasetRunItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetRunItems.
     */
    cursor?: DatasetRunItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRunItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRunItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetRunItems.
     */
    distinct?: DatasetRunItemsScalarFieldEnum | DatasetRunItemsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems findMany
   */
  export type DatasetRunItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * Filter, which DatasetRunItems to fetch.
     */
    where?: DatasetRunItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetRunItems to fetch.
     */
    orderBy?: DatasetRunItemsOrderByWithRelationInput | DatasetRunItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatasetRunItems.
     */
    cursor?: DatasetRunItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetRunItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetRunItems.
     */
    skip?: number
    distinct?: DatasetRunItemsScalarFieldEnum | DatasetRunItemsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems create
   */
  export type DatasetRunItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a DatasetRunItems.
     */
    data: XOR<DatasetRunItemsCreateInput, DatasetRunItemsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems createMany
   */
  export type DatasetRunItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatasetRunItems.
     */
    data: DatasetRunItemsCreateManyInput | DatasetRunItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatasetRunItems createManyAndReturn
   */
  export type DatasetRunItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DatasetRunItems.
     */
    data: DatasetRunItemsCreateManyInput | DatasetRunItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetRunItems update
   */
  export type DatasetRunItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a DatasetRunItems.
     */
    data: XOR<DatasetRunItemsUpdateInput, DatasetRunItemsUncheckedUpdateInput>
    /**
     * Choose, which DatasetRunItems to update.
     */
    where: DatasetRunItemsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems updateMany
   */
  export type DatasetRunItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatasetRunItems.
     */
    data: XOR<DatasetRunItemsUpdateManyMutationInput, DatasetRunItemsUncheckedUpdateManyInput>
    /**
     * Filter which DatasetRunItems to update
     */
    where?: DatasetRunItemsWhereInput
  }

  /**
   * DatasetRunItems upsert
   */
  export type DatasetRunItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the DatasetRunItems to update in case it exists.
     */
    where: DatasetRunItemsWhereUniqueInput
    /**
     * In case the DatasetRunItems found by the `where` argument doesn't exist, create a new DatasetRunItems with this data.
     */
    create: XOR<DatasetRunItemsCreateInput, DatasetRunItemsUncheckedCreateInput>
    /**
     * In case the DatasetRunItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetRunItemsUpdateInput, DatasetRunItemsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems delete
   */
  export type DatasetRunItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
    /**
     * Filter which DatasetRunItems to delete.
     */
    where: DatasetRunItemsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DatasetRunItems deleteMany
   */
  export type DatasetRunItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetRunItems to delete
     */
    where?: DatasetRunItemsWhereInput
  }

  /**
   * DatasetRunItems without action
   */
  export type DatasetRunItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetRunItems
     */
    select?: DatasetRunItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetRunItemsInclude<ExtArgs> | null
  }


  /**
   * Model Events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    url: string | null
    method: string | null
  }

  export type EventsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    url: string | null
    method: string | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    data: number
    headers: number
    url: number
    method: number
    _all: number
  }


  export type EventsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    url?: true
    method?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    url?: true
    method?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    data?: true
    headers?: true
    url?: true
    method?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to aggregate.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithAggregationInput | EventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    data: JsonValue
    headers: JsonValue
    url: string | null
    method: string | null
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    data?: boolean
    headers?: boolean
    url?: boolean
    method?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    data?: boolean
    headers?: boolean
    url?: boolean
    method?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    data?: boolean
    headers?: boolean
    url?: boolean
    method?: boolean
  }

  export type EventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type EventsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $EventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Events"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      data: Prisma.JsonValue
      headers: Prisma.JsonValue
      url: string | null
      method: string | null
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type EventsGetPayload<S extends boolean | null | undefined | EventsDefaultArgs> = $Result.GetResult<Prisma.$EventsPayload, S>

  type EventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface EventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Events'], meta: { name: 'Events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsFindUniqueArgs>(args: SelectSubset<T, EventsFindUniqueArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsFindFirstArgs>(args?: SelectSubset<T, EventsFindFirstArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventsFindManyArgs>(args?: SelectSubset<T, EventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends EventsCreateArgs>(args: SelectSubset<T, EventsCreateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsCreateManyArgs>(args?: SelectSubset<T, EventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventsCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends EventsDeleteArgs>(args: SelectSubset<T, EventsDeleteArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsUpdateArgs>(args: SelectSubset<T, EventsUpdateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsDeleteManyArgs>(args?: SelectSubset<T, EventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsUpdateManyArgs>(args: SelectSubset<T, EventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends EventsUpsertArgs>(args: SelectSubset<T, EventsUpsertArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Events model
   */
  readonly fields: EventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Events model
   */ 
  interface EventsFieldRefs {
    readonly id: FieldRef<"Events", 'String'>
    readonly createdAt: FieldRef<"Events", 'DateTime'>
    readonly updatedAt: FieldRef<"Events", 'DateTime'>
    readonly projectId: FieldRef<"Events", 'String'>
    readonly data: FieldRef<"Events", 'Json'>
    readonly headers: FieldRef<"Events", 'Json'>
    readonly url: FieldRef<"Events", 'String'>
    readonly method: FieldRef<"Events", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events findMany
   */
  export type EventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events create
   */
  export type EventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to create a Events.
     */
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events createMany
   */
  export type EventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Events createManyAndReturn
   */
  export type EventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Events update
   */
  export type EventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to update a Events.
     */
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     */
    where: EventsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
  }

  /**
   * Events upsert
   */
  export type EventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The filter to search for the Events to update in case it exists.
     */
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     */
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events delete
   */
  export type EventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter which Events to delete.
     */
    where: EventsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventsWhereInput
  }

  /**
   * Events without action
   */
  export type EventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    objectType: $Enums.CommentObjectType | null
    objectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    authorUserId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    objectType: $Enums.CommentObjectType | null
    objectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    authorUserId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    projectId: number
    objectType: number
    objectId: number
    createdAt: number
    updatedAt: number
    content: number
    authorUserId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    projectId?: true
    objectType?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    authorUserId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    projectId?: true
    objectType?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    authorUserId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    projectId?: true
    objectType?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    authorUserId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    projectId: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt: Date
    updatedAt: Date
    content: string
    authorUserId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    objectType?: boolean
    objectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    authorUserId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    objectType?: boolean
    objectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    authorUserId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    projectId?: boolean
    objectType?: boolean
    objectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    authorUserId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      objectType: $Enums.CommentObjectType
      objectId: string
      createdAt: Date
      updatedAt: Date
      content: string
      authorUserId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly projectId: FieldRef<"Comment", 'String'>
    readonly objectType: FieldRef<"Comment", 'CommentObjectType'>
    readonly objectId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly authorUserId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Prompt
   */

  export type AggregatePrompt = {
    _count: PromptCountAggregateOutputType | null
    _avg: PromptAvgAggregateOutputType | null
    _sum: PromptSumAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  export type PromptAvgAggregateOutputType = {
    version: number | null
  }

  export type PromptSumAggregateOutputType = {
    version: number | null
  }

  export type PromptMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
    name: string | null
    version: number | null
    type: string | null
    isActive: boolean | null
  }

  export type PromptMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
    name: string | null
    version: number | null
    type: string | null
    isActive: boolean | null
  }

  export type PromptCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    createdBy: number
    prompt: number
    name: number
    version: number
    type: number
    isActive: number
    config: number
    tags: number
    labels: number
    _all: number
  }


  export type PromptAvgAggregateInputType = {
    version?: true
  }

  export type PromptSumAggregateInputType = {
    version?: true
  }

  export type PromptMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    name?: true
    version?: true
    type?: true
    isActive?: true
  }

  export type PromptMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    name?: true
    version?: true
    type?: true
    isActive?: true
  }

  export type PromptCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    prompt?: true
    name?: true
    version?: true
    type?: true
    isActive?: true
    config?: true
    tags?: true
    labels?: true
    _all?: true
  }

  export type PromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompt to aggregate.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prompts
    **/
    _count?: true | PromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptMaxAggregateInputType
  }

  export type GetPromptAggregateType<T extends PromptAggregateArgs> = {
        [P in keyof T & keyof AggregatePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrompt[P]>
      : GetScalarType<T[P], AggregatePrompt[P]>
  }




  export type PromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithAggregationInput | PromptOrderByWithAggregationInput[]
    by: PromptScalarFieldEnum[] | PromptScalarFieldEnum
    having?: PromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptCountAggregateInputType | true
    _avg?: PromptAvgAggregateInputType
    _sum?: PromptSumAggregateInputType
    _min?: PromptMinAggregateInputType
    _max?: PromptMaxAggregateInputType
  }

  export type PromptGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    createdBy: string
    prompt: JsonValue
    name: string
    version: number
    type: string
    isActive: boolean | null
    config: JsonValue
    tags: string[]
    labels: string[]
    _count: PromptCountAggregateOutputType | null
    _avg: PromptAvgAggregateOutputType | null
    _sum: PromptSumAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  type GetPromptGroupByPayload<T extends PromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptGroupByOutputType[P]>
            : GetScalarType<T[P], PromptGroupByOutputType[P]>
        }
      >
    >


  export type PromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    prompt?: boolean
    name?: boolean
    version?: boolean
    type?: boolean
    isActive?: boolean
    config?: boolean
    tags?: boolean
    labels?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    prompt?: boolean
    name?: boolean
    version?: boolean
    type?: boolean
    isActive?: boolean
    config?: boolean
    tags?: boolean
    labels?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    prompt?: boolean
    name?: boolean
    version?: boolean
    type?: boolean
    isActive?: boolean
    config?: boolean
    tags?: boolean
    labels?: boolean
  }

  export type PromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prompt"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      createdBy: string
      prompt: Prisma.JsonValue
      name: string
      version: number
      type: string
      isActive: boolean | null
      config: Prisma.JsonValue
      tags: string[]
      labels: string[]
    }, ExtArgs["result"]["prompt"]>
    composites: {}
  }

  type PromptGetPayload<S extends boolean | null | undefined | PromptDefaultArgs> = $Result.GetResult<Prisma.$PromptPayload, S>

  type PromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromptFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PromptCountAggregateInputType | true
    }

  export interface PromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prompt'], meta: { name: 'Prompt' } }
    /**
     * Find zero or one Prompt that matches the filter.
     * @param {PromptFindUniqueArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptFindUniqueArgs>(args: SelectSubset<T, PromptFindUniqueArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromptFindUniqueOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptFindFirstArgs>(args?: SelectSubset<T, PromptFindFirstArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prompts
     * const prompts = await prisma.prompt.findMany()
     * 
     * // Get first 10 Prompts
     * const prompts = await prisma.prompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptWithIdOnly = await prisma.prompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptFindManyArgs>(args?: SelectSubset<T, PromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prompt.
     * @param {PromptCreateArgs} args - Arguments to create a Prompt.
     * @example
     * // Create one Prompt
     * const Prompt = await prisma.prompt.create({
     *   data: {
     *     // ... data to create a Prompt
     *   }
     * })
     * 
     */
    create<T extends PromptCreateArgs>(args: SelectSubset<T, PromptCreateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prompts.
     * @param {PromptCreateManyArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptCreateManyArgs>(args?: SelectSubset<T, PromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prompts and returns the data saved in the database.
     * @param {PromptCreateManyAndReturnArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prompts and only return the `id`
     * const promptWithIdOnly = await prisma.prompt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prompt.
     * @param {PromptDeleteArgs} args - Arguments to delete one Prompt.
     * @example
     * // Delete one Prompt
     * const Prompt = await prisma.prompt.delete({
     *   where: {
     *     // ... filter to delete one Prompt
     *   }
     * })
     * 
     */
    delete<T extends PromptDeleteArgs>(args: SelectSubset<T, PromptDeleteArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prompt.
     * @param {PromptUpdateArgs} args - Arguments to update one Prompt.
     * @example
     * // Update one Prompt
     * const prompt = await prisma.prompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptUpdateArgs>(args: SelectSubset<T, PromptUpdateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prompts.
     * @param {PromptDeleteManyArgs} args - Arguments to filter Prompts to delete.
     * @example
     * // Delete a few Prompts
     * const { count } = await prisma.prompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptDeleteManyArgs>(args?: SelectSubset<T, PromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prompts
     * const prompt = await prisma.prompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptUpdateManyArgs>(args: SelectSubset<T, PromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prompt.
     * @param {PromptUpsertArgs} args - Arguments to update or create a Prompt.
     * @example
     * // Update or create a Prompt
     * const prompt = await prisma.prompt.upsert({
     *   create: {
     *     // ... data to create a Prompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prompt we want to update
     *   }
     * })
     */
    upsert<T extends PromptUpsertArgs>(args: SelectSubset<T, PromptUpsertArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCountArgs} args - Arguments to filter Prompts to count.
     * @example
     * // Count the number of Prompts
     * const count = await prisma.prompt.count({
     *   where: {
     *     // ... the filter for the Prompts we want to count
     *   }
     * })
    **/
    count<T extends PromptCountArgs>(
      args?: Subset<T, PromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptAggregateArgs>(args: Subset<T, PromptAggregateArgs>): Prisma.PrismaPromise<GetPromptAggregateType<T>>

    /**
     * Group by Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptGroupByArgs['orderBy'] }
        : { orderBy?: PromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prompt model
   */
  readonly fields: PromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prompt model
   */ 
  interface PromptFieldRefs {
    readonly id: FieldRef<"Prompt", 'String'>
    readonly createdAt: FieldRef<"Prompt", 'DateTime'>
    readonly updatedAt: FieldRef<"Prompt", 'DateTime'>
    readonly projectId: FieldRef<"Prompt", 'String'>
    readonly createdBy: FieldRef<"Prompt", 'String'>
    readonly prompt: FieldRef<"Prompt", 'Json'>
    readonly name: FieldRef<"Prompt", 'String'>
    readonly version: FieldRef<"Prompt", 'Int'>
    readonly type: FieldRef<"Prompt", 'String'>
    readonly isActive: FieldRef<"Prompt", 'Boolean'>
    readonly config: FieldRef<"Prompt", 'Json'>
    readonly tags: FieldRef<"Prompt", 'String[]'>
    readonly labels: FieldRef<"Prompt", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Prompt findUnique
   */
  export type PromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findUniqueOrThrow
   */
  export type PromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findFirst
   */
  export type PromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findFirstOrThrow
   */
  export type PromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findMany
   */
  export type PromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompts to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt create
   */
  export type PromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to create a Prompt.
     */
    data: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt createMany
   */
  export type PromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prompt createManyAndReturn
   */
  export type PromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prompt update
   */
  export type PromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to update a Prompt.
     */
    data: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    /**
     * Choose, which Prompt to update.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt updateMany
   */
  export type PromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prompts.
     */
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyInput>
    /**
     * Filter which Prompts to update
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt upsert
   */
  export type PromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The filter to search for the Prompt to update in case it exists.
     */
    where: PromptWhereUniqueInput
    /**
     * In case the Prompt found by the `where` argument doesn't exist, create a new Prompt with this data.
     */
    create: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    /**
     * In case the Prompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt delete
   */
  export type PromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter which Prompt to delete.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt deleteMany
   */
  export type PromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompts to delete
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt without action
   */
  export type PromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelAvgAggregateOutputType = {
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type ModelSumAggregateOutputType = {
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    modelName: string | null
    matchPattern: string | null
    startDate: Date | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    unit: string | null
    tokenizerId: string | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    modelName: string | null
    matchPattern: string | null
    startDate: Date | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    unit: string | null
    tokenizerId: string | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    modelName: number
    matchPattern: number
    startDate: number
    inputPrice: number
    outputPrice: number
    totalPrice: number
    unit: number
    tokenizerId: number
    tokenizerConfig: number
    _all: number
  }


  export type ModelAvgAggregateInputType = {
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
  }

  export type ModelSumAggregateInputType = {
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
  }

  export type ModelMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    modelName?: true
    matchPattern?: true
    startDate?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    unit?: true
    tokenizerId?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    modelName?: true
    matchPattern?: true
    startDate?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    unit?: true
    tokenizerId?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    modelName?: true
    matchPattern?: true
    startDate?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    unit?: true
    tokenizerId?: true
    tokenizerConfig?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _avg?: ModelAvgAggregateInputType
    _sum?: ModelSumAggregateInputType
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string | null
    modelName: string
    matchPattern: string
    startDate: Date | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    unit: string | null
    tokenizerId: string | null
    tokenizerConfig: JsonValue | null
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    modelName?: boolean
    matchPattern?: boolean
    startDate?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    totalPrice?: boolean
    unit?: boolean
    tokenizerId?: boolean
    tokenizerConfig?: boolean
    project?: boolean | Model$projectArgs<ExtArgs>
    Price?: boolean | Model$PriceArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    modelName?: boolean
    matchPattern?: boolean
    startDate?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    totalPrice?: boolean
    unit?: boolean
    tokenizerId?: boolean
    tokenizerConfig?: boolean
    project?: boolean | Model$projectArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    modelName?: boolean
    matchPattern?: boolean
    startDate?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    totalPrice?: boolean
    unit?: boolean
    tokenizerId?: boolean
    tokenizerConfig?: boolean
  }

  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Model$projectArgs<ExtArgs>
    Price?: boolean | Model$PriceArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Model$projectArgs<ExtArgs>
  }

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      Price: Prisma.$PricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string | null
      modelName: string
      matchPattern: string
      startDate: Date | null
      inputPrice: Prisma.Decimal | null
      outputPrice: Prisma.Decimal | null
      totalPrice: Prisma.Decimal | null
      unit: string | null
      tokenizerId: string | null
      tokenizerConfig: Prisma.JsonValue | null
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Models and returns the data saved in the database.
     * @param {ModelCreateManyAndReturnArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Model$projectArgs<ExtArgs> = {}>(args?: Subset<T, Model$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Price<T extends Model$PriceArgs<ExtArgs> = {}>(args?: Subset<T, Model$PriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */ 
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'String'>
    readonly createdAt: FieldRef<"Model", 'DateTime'>
    readonly updatedAt: FieldRef<"Model", 'DateTime'>
    readonly projectId: FieldRef<"Model", 'String'>
    readonly modelName: FieldRef<"Model", 'String'>
    readonly matchPattern: FieldRef<"Model", 'String'>
    readonly startDate: FieldRef<"Model", 'DateTime'>
    readonly inputPrice: FieldRef<"Model", 'Decimal'>
    readonly outputPrice: FieldRef<"Model", 'Decimal'>
    readonly totalPrice: FieldRef<"Model", 'Decimal'>
    readonly unit: FieldRef<"Model", 'String'>
    readonly tokenizerId: FieldRef<"Model", 'String'>
    readonly tokenizerConfig: FieldRef<"Model", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model createManyAndReturn
   */
  export type ModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
  }

  /**
   * Model.project
   */
  export type Model$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Model.Price
   */
  export type Model$PriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    where?: PriceWhereInput
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    cursor?: PriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model Price
   */

  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type PriceSumAggregateOutputType = {
    price: Decimal | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    modelId: string | null
    usageType: string | null
    price: Decimal | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    modelId: string | null
    usageType: string | null
    price: Decimal | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    modelId: number
    usageType: number
    price: number
    _all: number
  }


  export type PriceAvgAggregateInputType = {
    price?: true
  }

  export type PriceSumAggregateInputType = {
    price?: true
  }

  export type PriceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    modelId?: true
    usageType?: true
    price?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    modelId?: true
    usageType?: true
    price?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    modelId?: true
    usageType?: true
    price?: true
    _all?: true
  }

  export type PriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Price to aggregate.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
    orderBy?: PriceOrderByWithAggregationInput | PriceOrderByWithAggregationInput[]
    by: PriceScalarFieldEnum[] | PriceScalarFieldEnum
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _avg?: PriceAvgAggregateInputType
    _sum?: PriceSumAggregateInputType
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }

  export type PriceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    modelId: string
    usageType: string
    price: Decimal
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modelId?: boolean
    usageType?: boolean
    price?: boolean
    Model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["price"]>

  export type PriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modelId?: boolean
    usageType?: boolean
    price?: boolean
    Model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["price"]>

  export type PriceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modelId?: boolean
    usageType?: boolean
    price?: boolean
  }

  export type PriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Model?: boolean | ModelDefaultArgs<ExtArgs>
  }
  export type PriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Model?: boolean | ModelDefaultArgs<ExtArgs>
  }

  export type $PricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Price"
    objects: {
      Model: Prisma.$ModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      modelId: string
      usageType: string
      price: Prisma.Decimal
    }, ExtArgs["result"]["price"]>
    composites: {}
  }

  type PriceGetPayload<S extends boolean | null | undefined | PriceDefaultArgs> = $Result.GetResult<Prisma.$PricePayload, S>

  type PriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PriceCountAggregateInputType | true
    }

  export interface PriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Price'], meta: { name: 'Price' } }
    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceFindUniqueArgs>(args: SelectSubset<T, PriceFindUniqueArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Price that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceFindUniqueOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceFindFirstArgs>(args?: SelectSubset<T, PriceFindFirstArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Price that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceFindManyArgs>(args?: SelectSubset<T, PriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
     */
    create<T extends PriceCreateArgs>(args: SelectSubset<T, PriceCreateArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prices.
     * @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     * @example
     * // Create many Prices
     * const price = await prisma.price.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceCreateManyArgs>(args?: SelectSubset<T, PriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prices and returns the data saved in the database.
     * @param {PriceCreateManyAndReturnArgs} args - Arguments to create many Prices.
     * @example
     * // Create many Prices
     * const price = await prisma.price.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prices and only return the `id`
     * const priceWithIdOnly = await prisma.price.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
     */
    delete<T extends PriceDeleteArgs>(args: SelectSubset<T, PriceDeleteArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceUpdateArgs>(args: SelectSubset<T, PriceUpdateArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceDeleteManyArgs>(args?: SelectSubset<T, PriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceUpdateManyArgs>(args: SelectSubset<T, PriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
     */
    upsert<T extends PriceUpsertArgs>(args: SelectSubset<T, PriceUpsertArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): Prisma.PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Price model
   */
  readonly fields: PriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Price model
   */ 
  interface PriceFieldRefs {
    readonly id: FieldRef<"Price", 'String'>
    readonly createdAt: FieldRef<"Price", 'DateTime'>
    readonly updatedAt: FieldRef<"Price", 'DateTime'>
    readonly modelId: FieldRef<"Price", 'String'>
    readonly usageType: FieldRef<"Price", 'String'>
    readonly price: FieldRef<"Price", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Price findUnique
   */
  export type PriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price findUniqueOrThrow
   */
  export type PriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price findFirst
   */
  export type PriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price findFirstOrThrow
   */
  export type PriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price findMany
   */
  export type PriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price create
   */
  export type PriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The data needed to create a Price.
     */
    data: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price createMany
   */
  export type PriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prices.
     */
    data: PriceCreateManyInput | PriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Price createManyAndReturn
   */
  export type PriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prices.
     */
    data: PriceCreateManyInput | PriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Price update
   */
  export type PriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The data needed to update a Price.
     */
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     */
    where: PriceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PriceWhereInput
  }

  /**
   * Price upsert
   */
  export type PriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The filter to search for the Price to update in case it exists.
     */
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     */
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price delete
   */
  export type PriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter which Price to delete.
     */
    where: PriceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prices to delete
     */
    where?: PriceWhereInput
  }

  /**
   * Price without action
   */
  export type PriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    orgId: string | null
    userOrgRole: string | null
    projectId: string | null
    userProjectRole: string | null
    resourceType: string | null
    resourceId: string | null
    action: string | null
    before: string | null
    after: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    orgId: string | null
    userOrgRole: string | null
    projectId: string | null
    userProjectRole: string | null
    resourceType: string | null
    resourceId: string | null
    action: string | null
    before: string | null
    after: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    orgId: number
    userOrgRole: number
    projectId: number
    userProjectRole: number
    resourceType: number
    resourceId: number
    action: number
    before: number
    after: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    orgId?: true
    userOrgRole?: true
    projectId?: true
    userProjectRole?: true
    resourceType?: true
    resourceId?: true
    action?: true
    before?: true
    after?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    orgId?: true
    userOrgRole?: true
    projectId?: true
    userProjectRole?: true
    resourceType?: true
    resourceId?: true
    action?: true
    before?: true
    after?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    orgId?: true
    userOrgRole?: true
    projectId?: true
    userProjectRole?: true
    resourceType?: true
    resourceId?: true
    action?: true
    before?: true
    after?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    orgId: string
    userOrgRole: string
    projectId: string | null
    userProjectRole: string | null
    resourceType: string
    resourceId: string
    action: string
    before: string | null
    after: string | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    orgId?: boolean
    userOrgRole?: boolean
    projectId?: boolean
    userProjectRole?: boolean
    resourceType?: boolean
    resourceId?: boolean
    action?: boolean
    before?: boolean
    after?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    orgId?: boolean
    userOrgRole?: boolean
    projectId?: boolean
    userProjectRole?: boolean
    resourceType?: boolean
    resourceId?: boolean
    action?: boolean
    before?: boolean
    after?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    orgId?: boolean
    userOrgRole?: boolean
    projectId?: boolean
    userProjectRole?: boolean
    resourceType?: boolean
    resourceId?: boolean
    action?: boolean
    before?: boolean
    after?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      orgId: string
      userOrgRole: string
      projectId: string | null
      userProjectRole: string | null
      resourceType: string
      resourceId: string
      action: string
      before: string | null
      after: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditLog", 'DateTime'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly orgId: FieldRef<"AuditLog", 'String'>
    readonly userOrgRole: FieldRef<"AuditLog", 'String'>
    readonly projectId: FieldRef<"AuditLog", 'String'>
    readonly userProjectRole: FieldRef<"AuditLog", 'String'>
    readonly resourceType: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly before: FieldRef<"AuditLog", 'String'>
    readonly after: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model EvalTemplate
   */

  export type AggregateEvalTemplate = {
    _count: EvalTemplateCountAggregateOutputType | null
    _avg: EvalTemplateAvgAggregateOutputType | null
    _sum: EvalTemplateSumAggregateOutputType | null
    _min: EvalTemplateMinAggregateOutputType | null
    _max: EvalTemplateMaxAggregateOutputType | null
  }

  export type EvalTemplateAvgAggregateOutputType = {
    version: number | null
  }

  export type EvalTemplateSumAggregateOutputType = {
    version: number | null
  }

  export type EvalTemplateMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    name: string | null
    version: number | null
    prompt: string | null
    model: string | null
    provider: string | null
  }

  export type EvalTemplateMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    name: string | null
    version: number | null
    prompt: string | null
    model: string | null
    provider: string | null
  }

  export type EvalTemplateCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    name: number
    version: number
    prompt: number
    model: number
    provider: number
    modelParams: number
    vars: number
    outputSchema: number
    _all: number
  }


  export type EvalTemplateAvgAggregateInputType = {
    version?: true
  }

  export type EvalTemplateSumAggregateInputType = {
    version?: true
  }

  export type EvalTemplateMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    name?: true
    version?: true
    prompt?: true
    model?: true
    provider?: true
  }

  export type EvalTemplateMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    name?: true
    version?: true
    prompt?: true
    model?: true
    provider?: true
  }

  export type EvalTemplateCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    name?: true
    version?: true
    prompt?: true
    model?: true
    provider?: true
    modelParams?: true
    vars?: true
    outputSchema?: true
    _all?: true
  }

  export type EvalTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvalTemplate to aggregate.
     */
    where?: EvalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvalTemplates to fetch.
     */
    orderBy?: EvalTemplateOrderByWithRelationInput | EvalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvalTemplates
    **/
    _count?: true | EvalTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvalTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvalTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvalTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvalTemplateMaxAggregateInputType
  }

  export type GetEvalTemplateAggregateType<T extends EvalTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEvalTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvalTemplate[P]>
      : GetScalarType<T[P], AggregateEvalTemplate[P]>
  }




  export type EvalTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvalTemplateWhereInput
    orderBy?: EvalTemplateOrderByWithAggregationInput | EvalTemplateOrderByWithAggregationInput[]
    by: EvalTemplateScalarFieldEnum[] | EvalTemplateScalarFieldEnum
    having?: EvalTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvalTemplateCountAggregateInputType | true
    _avg?: EvalTemplateAvgAggregateInputType
    _sum?: EvalTemplateSumAggregateInputType
    _min?: EvalTemplateMinAggregateInputType
    _max?: EvalTemplateMaxAggregateInputType
  }

  export type EvalTemplateGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonValue
    vars: string[]
    outputSchema: JsonValue
    _count: EvalTemplateCountAggregateOutputType | null
    _avg: EvalTemplateAvgAggregateOutputType | null
    _sum: EvalTemplateSumAggregateOutputType | null
    _min: EvalTemplateMinAggregateOutputType | null
    _max: EvalTemplateMaxAggregateOutputType | null
  }

  type GetEvalTemplateGroupByPayload<T extends EvalTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvalTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvalTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvalTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EvalTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EvalTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    name?: boolean
    version?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    modelParams?: boolean
    vars?: boolean
    outputSchema?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    JobConfiguration?: boolean | EvalTemplate$JobConfigurationArgs<ExtArgs>
    _count?: boolean | EvalTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evalTemplate"]>

  export type EvalTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    name?: boolean
    version?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    modelParams?: boolean
    vars?: boolean
    outputSchema?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evalTemplate"]>

  export type EvalTemplateSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    name?: boolean
    version?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    modelParams?: boolean
    vars?: boolean
    outputSchema?: boolean
  }

  export type EvalTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    JobConfiguration?: boolean | EvalTemplate$JobConfigurationArgs<ExtArgs>
    _count?: boolean | EvalTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvalTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $EvalTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvalTemplate"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      JobConfiguration: Prisma.$JobConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      name: string
      version: number
      prompt: string
      model: string
      provider: string
      modelParams: Prisma.JsonValue
      vars: string[]
      outputSchema: Prisma.JsonValue
    }, ExtArgs["result"]["evalTemplate"]>
    composites: {}
  }

  type EvalTemplateGetPayload<S extends boolean | null | undefined | EvalTemplateDefaultArgs> = $Result.GetResult<Prisma.$EvalTemplatePayload, S>

  type EvalTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvalTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: EvalTemplateCountAggregateInputType | true
    }

  export interface EvalTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvalTemplate'], meta: { name: 'EvalTemplate' } }
    /**
     * Find zero or one EvalTemplate that matches the filter.
     * @param {EvalTemplateFindUniqueArgs} args - Arguments to find a EvalTemplate
     * @example
     * // Get one EvalTemplate
     * const evalTemplate = await prisma.evalTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvalTemplateFindUniqueArgs>(args: SelectSubset<T, EvalTemplateFindUniqueArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvalTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvalTemplateFindUniqueOrThrowArgs} args - Arguments to find a EvalTemplate
     * @example
     * // Get one EvalTemplate
     * const evalTemplate = await prisma.evalTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvalTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EvalTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvalTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateFindFirstArgs} args - Arguments to find a EvalTemplate
     * @example
     * // Get one EvalTemplate
     * const evalTemplate = await prisma.evalTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvalTemplateFindFirstArgs>(args?: SelectSubset<T, EvalTemplateFindFirstArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvalTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateFindFirstOrThrowArgs} args - Arguments to find a EvalTemplate
     * @example
     * // Get one EvalTemplate
     * const evalTemplate = await prisma.evalTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvalTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EvalTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvalTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvalTemplates
     * const evalTemplates = await prisma.evalTemplate.findMany()
     * 
     * // Get first 10 EvalTemplates
     * const evalTemplates = await prisma.evalTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evalTemplateWithIdOnly = await prisma.evalTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvalTemplateFindManyArgs>(args?: SelectSubset<T, EvalTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvalTemplate.
     * @param {EvalTemplateCreateArgs} args - Arguments to create a EvalTemplate.
     * @example
     * // Create one EvalTemplate
     * const EvalTemplate = await prisma.evalTemplate.create({
     *   data: {
     *     // ... data to create a EvalTemplate
     *   }
     * })
     * 
     */
    create<T extends EvalTemplateCreateArgs>(args: SelectSubset<T, EvalTemplateCreateArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvalTemplates.
     * @param {EvalTemplateCreateManyArgs} args - Arguments to create many EvalTemplates.
     * @example
     * // Create many EvalTemplates
     * const evalTemplate = await prisma.evalTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvalTemplateCreateManyArgs>(args?: SelectSubset<T, EvalTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvalTemplates and returns the data saved in the database.
     * @param {EvalTemplateCreateManyAndReturnArgs} args - Arguments to create many EvalTemplates.
     * @example
     * // Create many EvalTemplates
     * const evalTemplate = await prisma.evalTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvalTemplates and only return the `id`
     * const evalTemplateWithIdOnly = await prisma.evalTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvalTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EvalTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvalTemplate.
     * @param {EvalTemplateDeleteArgs} args - Arguments to delete one EvalTemplate.
     * @example
     * // Delete one EvalTemplate
     * const EvalTemplate = await prisma.evalTemplate.delete({
     *   where: {
     *     // ... filter to delete one EvalTemplate
     *   }
     * })
     * 
     */
    delete<T extends EvalTemplateDeleteArgs>(args: SelectSubset<T, EvalTemplateDeleteArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvalTemplate.
     * @param {EvalTemplateUpdateArgs} args - Arguments to update one EvalTemplate.
     * @example
     * // Update one EvalTemplate
     * const evalTemplate = await prisma.evalTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvalTemplateUpdateArgs>(args: SelectSubset<T, EvalTemplateUpdateArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvalTemplates.
     * @param {EvalTemplateDeleteManyArgs} args - Arguments to filter EvalTemplates to delete.
     * @example
     * // Delete a few EvalTemplates
     * const { count } = await prisma.evalTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvalTemplateDeleteManyArgs>(args?: SelectSubset<T, EvalTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvalTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvalTemplates
     * const evalTemplate = await prisma.evalTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvalTemplateUpdateManyArgs>(args: SelectSubset<T, EvalTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvalTemplate.
     * @param {EvalTemplateUpsertArgs} args - Arguments to update or create a EvalTemplate.
     * @example
     * // Update or create a EvalTemplate
     * const evalTemplate = await prisma.evalTemplate.upsert({
     *   create: {
     *     // ... data to create a EvalTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvalTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EvalTemplateUpsertArgs>(args: SelectSubset<T, EvalTemplateUpsertArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvalTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateCountArgs} args - Arguments to filter EvalTemplates to count.
     * @example
     * // Count the number of EvalTemplates
     * const count = await prisma.evalTemplate.count({
     *   where: {
     *     // ... the filter for the EvalTemplates we want to count
     *   }
     * })
    **/
    count<T extends EvalTemplateCountArgs>(
      args?: Subset<T, EvalTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvalTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvalTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvalTemplateAggregateArgs>(args: Subset<T, EvalTemplateAggregateArgs>): Prisma.PrismaPromise<GetEvalTemplateAggregateType<T>>

    /**
     * Group by EvalTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvalTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvalTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvalTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EvalTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvalTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvalTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvalTemplate model
   */
  readonly fields: EvalTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvalTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvalTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    JobConfiguration<T extends EvalTemplate$JobConfigurationArgs<ExtArgs> = {}>(args?: Subset<T, EvalTemplate$JobConfigurationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvalTemplate model
   */ 
  interface EvalTemplateFieldRefs {
    readonly id: FieldRef<"EvalTemplate", 'String'>
    readonly createdAt: FieldRef<"EvalTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EvalTemplate", 'DateTime'>
    readonly projectId: FieldRef<"EvalTemplate", 'String'>
    readonly name: FieldRef<"EvalTemplate", 'String'>
    readonly version: FieldRef<"EvalTemplate", 'Int'>
    readonly prompt: FieldRef<"EvalTemplate", 'String'>
    readonly model: FieldRef<"EvalTemplate", 'String'>
    readonly provider: FieldRef<"EvalTemplate", 'String'>
    readonly modelParams: FieldRef<"EvalTemplate", 'Json'>
    readonly vars: FieldRef<"EvalTemplate", 'String[]'>
    readonly outputSchema: FieldRef<"EvalTemplate", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EvalTemplate findUnique
   */
  export type EvalTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EvalTemplate to fetch.
     */
    where: EvalTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate findUniqueOrThrow
   */
  export type EvalTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EvalTemplate to fetch.
     */
    where: EvalTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate findFirst
   */
  export type EvalTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EvalTemplate to fetch.
     */
    where?: EvalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvalTemplates to fetch.
     */
    orderBy?: EvalTemplateOrderByWithRelationInput | EvalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvalTemplates.
     */
    cursor?: EvalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvalTemplates.
     */
    distinct?: EvalTemplateScalarFieldEnum | EvalTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate findFirstOrThrow
   */
  export type EvalTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EvalTemplate to fetch.
     */
    where?: EvalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvalTemplates to fetch.
     */
    orderBy?: EvalTemplateOrderByWithRelationInput | EvalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvalTemplates.
     */
    cursor?: EvalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvalTemplates.
     */
    distinct?: EvalTemplateScalarFieldEnum | EvalTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate findMany
   */
  export type EvalTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EvalTemplates to fetch.
     */
    where?: EvalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvalTemplates to fetch.
     */
    orderBy?: EvalTemplateOrderByWithRelationInput | EvalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvalTemplates.
     */
    cursor?: EvalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvalTemplates.
     */
    skip?: number
    distinct?: EvalTemplateScalarFieldEnum | EvalTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate create
   */
  export type EvalTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EvalTemplate.
     */
    data: XOR<EvalTemplateCreateInput, EvalTemplateUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate createMany
   */
  export type EvalTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvalTemplates.
     */
    data: EvalTemplateCreateManyInput | EvalTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvalTemplate createManyAndReturn
   */
  export type EvalTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvalTemplates.
     */
    data: EvalTemplateCreateManyInput | EvalTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvalTemplate update
   */
  export type EvalTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EvalTemplate.
     */
    data: XOR<EvalTemplateUpdateInput, EvalTemplateUncheckedUpdateInput>
    /**
     * Choose, which EvalTemplate to update.
     */
    where: EvalTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate updateMany
   */
  export type EvalTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvalTemplates.
     */
    data: XOR<EvalTemplateUpdateManyMutationInput, EvalTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EvalTemplates to update
     */
    where?: EvalTemplateWhereInput
  }

  /**
   * EvalTemplate upsert
   */
  export type EvalTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EvalTemplate to update in case it exists.
     */
    where: EvalTemplateWhereUniqueInput
    /**
     * In case the EvalTemplate found by the `where` argument doesn't exist, create a new EvalTemplate with this data.
     */
    create: XOR<EvalTemplateCreateInput, EvalTemplateUncheckedCreateInput>
    /**
     * In case the EvalTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvalTemplateUpdateInput, EvalTemplateUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate delete
   */
  export type EvalTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    /**
     * Filter which EvalTemplate to delete.
     */
    where: EvalTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EvalTemplate deleteMany
   */
  export type EvalTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvalTemplates to delete
     */
    where?: EvalTemplateWhereInput
  }

  /**
   * EvalTemplate.JobConfiguration
   */
  export type EvalTemplate$JobConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    where?: JobConfigurationWhereInput
    orderBy?: JobConfigurationOrderByWithRelationInput | JobConfigurationOrderByWithRelationInput[]
    cursor?: JobConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobConfigurationScalarFieldEnum | JobConfigurationScalarFieldEnum[]
  }

  /**
   * EvalTemplate without action
   */
  export type EvalTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
  }


  /**
   * Model JobConfiguration
   */

  export type AggregateJobConfiguration = {
    _count: JobConfigurationCountAggregateOutputType | null
    _avg: JobConfigurationAvgAggregateOutputType | null
    _sum: JobConfigurationSumAggregateOutputType | null
    _min: JobConfigurationMinAggregateOutputType | null
    _max: JobConfigurationMaxAggregateOutputType | null
  }

  export type JobConfigurationAvgAggregateOutputType = {
    sampling: Decimal | null
    delay: number | null
  }

  export type JobConfigurationSumAggregateOutputType = {
    sampling: Decimal | null
    delay: number | null
  }

  export type JobConfigurationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    jobType: $Enums.JobType | null
    status: $Enums.JobConfigState | null
    evalTemplateId: string | null
    scoreName: string | null
    targetObject: string | null
    sampling: Decimal | null
    delay: number | null
  }

  export type JobConfigurationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    jobType: $Enums.JobType | null
    status: $Enums.JobConfigState | null
    evalTemplateId: string | null
    scoreName: string | null
    targetObject: string | null
    sampling: Decimal | null
    delay: number | null
  }

  export type JobConfigurationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    jobType: number
    status: number
    evalTemplateId: number
    scoreName: number
    filter: number
    targetObject: number
    variableMapping: number
    sampling: number
    delay: number
    _all: number
  }


  export type JobConfigurationAvgAggregateInputType = {
    sampling?: true
    delay?: true
  }

  export type JobConfigurationSumAggregateInputType = {
    sampling?: true
    delay?: true
  }

  export type JobConfigurationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    jobType?: true
    status?: true
    evalTemplateId?: true
    scoreName?: true
    targetObject?: true
    sampling?: true
    delay?: true
  }

  export type JobConfigurationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    jobType?: true
    status?: true
    evalTemplateId?: true
    scoreName?: true
    targetObject?: true
    sampling?: true
    delay?: true
  }

  export type JobConfigurationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    jobType?: true
    status?: true
    evalTemplateId?: true
    scoreName?: true
    filter?: true
    targetObject?: true
    variableMapping?: true
    sampling?: true
    delay?: true
    _all?: true
  }

  export type JobConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobConfiguration to aggregate.
     */
    where?: JobConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobConfigurations to fetch.
     */
    orderBy?: JobConfigurationOrderByWithRelationInput | JobConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobConfigurations
    **/
    _count?: true | JobConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobConfigurationMaxAggregateInputType
  }

  export type GetJobConfigurationAggregateType<T extends JobConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobConfiguration[P]>
      : GetScalarType<T[P], AggregateJobConfiguration[P]>
  }




  export type JobConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobConfigurationWhereInput
    orderBy?: JobConfigurationOrderByWithAggregationInput | JobConfigurationOrderByWithAggregationInput[]
    by: JobConfigurationScalarFieldEnum[] | JobConfigurationScalarFieldEnum
    having?: JobConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobConfigurationCountAggregateInputType | true
    _avg?: JobConfigurationAvgAggregateInputType
    _sum?: JobConfigurationSumAggregateInputType
    _min?: JobConfigurationMinAggregateInputType
    _max?: JobConfigurationMaxAggregateInputType
  }

  export type JobConfigurationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    jobType: $Enums.JobType
    status: $Enums.JobConfigState
    evalTemplateId: string | null
    scoreName: string
    filter: JsonValue
    targetObject: string
    variableMapping: JsonValue
    sampling: Decimal
    delay: number
    _count: JobConfigurationCountAggregateOutputType | null
    _avg: JobConfigurationAvgAggregateOutputType | null
    _sum: JobConfigurationSumAggregateOutputType | null
    _min: JobConfigurationMinAggregateOutputType | null
    _max: JobConfigurationMaxAggregateOutputType | null
  }

  type GetJobConfigurationGroupByPayload<T extends JobConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], JobConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type JobConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    jobType?: boolean
    status?: boolean
    evalTemplateId?: boolean
    scoreName?: boolean
    filter?: boolean
    targetObject?: boolean
    variableMapping?: boolean
    sampling?: boolean
    delay?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    evalTemplate?: boolean | JobConfiguration$evalTemplateArgs<ExtArgs>
    JobExecution?: boolean | JobConfiguration$JobExecutionArgs<ExtArgs>
    _count?: boolean | JobConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobConfiguration"]>

  export type JobConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    jobType?: boolean
    status?: boolean
    evalTemplateId?: boolean
    scoreName?: boolean
    filter?: boolean
    targetObject?: boolean
    variableMapping?: boolean
    sampling?: boolean
    delay?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    evalTemplate?: boolean | JobConfiguration$evalTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["jobConfiguration"]>

  export type JobConfigurationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    jobType?: boolean
    status?: boolean
    evalTemplateId?: boolean
    scoreName?: boolean
    filter?: boolean
    targetObject?: boolean
    variableMapping?: boolean
    sampling?: boolean
    delay?: boolean
  }

  export type JobConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    evalTemplate?: boolean | JobConfiguration$evalTemplateArgs<ExtArgs>
    JobExecution?: boolean | JobConfiguration$JobExecutionArgs<ExtArgs>
    _count?: boolean | JobConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    evalTemplate?: boolean | JobConfiguration$evalTemplateArgs<ExtArgs>
  }

  export type $JobConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobConfiguration"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      evalTemplate: Prisma.$EvalTemplatePayload<ExtArgs> | null
      JobExecution: Prisma.$JobExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      jobType: $Enums.JobType
      status: $Enums.JobConfigState
      evalTemplateId: string | null
      scoreName: string
      filter: Prisma.JsonValue
      targetObject: string
      variableMapping: Prisma.JsonValue
      sampling: Prisma.Decimal
      delay: number
    }, ExtArgs["result"]["jobConfiguration"]>
    composites: {}
  }

  type JobConfigurationGetPayload<S extends boolean | null | undefined | JobConfigurationDefaultArgs> = $Result.GetResult<Prisma.$JobConfigurationPayload, S>

  type JobConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: JobConfigurationCountAggregateInputType | true
    }

  export interface JobConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobConfiguration'], meta: { name: 'JobConfiguration' } }
    /**
     * Find zero or one JobConfiguration that matches the filter.
     * @param {JobConfigurationFindUniqueArgs} args - Arguments to find a JobConfiguration
     * @example
     * // Get one JobConfiguration
     * const jobConfiguration = await prisma.jobConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobConfigurationFindUniqueArgs>(args: SelectSubset<T, JobConfigurationFindUniqueArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobConfiguration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobConfigurationFindUniqueOrThrowArgs} args - Arguments to find a JobConfiguration
     * @example
     * // Get one JobConfiguration
     * const jobConfiguration = await prisma.jobConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, JobConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationFindFirstArgs} args - Arguments to find a JobConfiguration
     * @example
     * // Get one JobConfiguration
     * const jobConfiguration = await prisma.jobConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobConfigurationFindFirstArgs>(args?: SelectSubset<T, JobConfigurationFindFirstArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationFindFirstOrThrowArgs} args - Arguments to find a JobConfiguration
     * @example
     * // Get one JobConfiguration
     * const jobConfiguration = await prisma.jobConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, JobConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobConfigurations
     * const jobConfigurations = await prisma.jobConfiguration.findMany()
     * 
     * // Get first 10 JobConfigurations
     * const jobConfigurations = await prisma.jobConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobConfigurationWithIdOnly = await prisma.jobConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobConfigurationFindManyArgs>(args?: SelectSubset<T, JobConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobConfiguration.
     * @param {JobConfigurationCreateArgs} args - Arguments to create a JobConfiguration.
     * @example
     * // Create one JobConfiguration
     * const JobConfiguration = await prisma.jobConfiguration.create({
     *   data: {
     *     // ... data to create a JobConfiguration
     *   }
     * })
     * 
     */
    create<T extends JobConfigurationCreateArgs>(args: SelectSubset<T, JobConfigurationCreateArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobConfigurations.
     * @param {JobConfigurationCreateManyArgs} args - Arguments to create many JobConfigurations.
     * @example
     * // Create many JobConfigurations
     * const jobConfiguration = await prisma.jobConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobConfigurationCreateManyArgs>(args?: SelectSubset<T, JobConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobConfigurations and returns the data saved in the database.
     * @param {JobConfigurationCreateManyAndReturnArgs} args - Arguments to create many JobConfigurations.
     * @example
     * // Create many JobConfigurations
     * const jobConfiguration = await prisma.jobConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobConfigurations and only return the `id`
     * const jobConfigurationWithIdOnly = await prisma.jobConfiguration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, JobConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobConfiguration.
     * @param {JobConfigurationDeleteArgs} args - Arguments to delete one JobConfiguration.
     * @example
     * // Delete one JobConfiguration
     * const JobConfiguration = await prisma.jobConfiguration.delete({
     *   where: {
     *     // ... filter to delete one JobConfiguration
     *   }
     * })
     * 
     */
    delete<T extends JobConfigurationDeleteArgs>(args: SelectSubset<T, JobConfigurationDeleteArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobConfiguration.
     * @param {JobConfigurationUpdateArgs} args - Arguments to update one JobConfiguration.
     * @example
     * // Update one JobConfiguration
     * const jobConfiguration = await prisma.jobConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobConfigurationUpdateArgs>(args: SelectSubset<T, JobConfigurationUpdateArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobConfigurations.
     * @param {JobConfigurationDeleteManyArgs} args - Arguments to filter JobConfigurations to delete.
     * @example
     * // Delete a few JobConfigurations
     * const { count } = await prisma.jobConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobConfigurationDeleteManyArgs>(args?: SelectSubset<T, JobConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobConfigurations
     * const jobConfiguration = await prisma.jobConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobConfigurationUpdateManyArgs>(args: SelectSubset<T, JobConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobConfiguration.
     * @param {JobConfigurationUpsertArgs} args - Arguments to update or create a JobConfiguration.
     * @example
     * // Update or create a JobConfiguration
     * const jobConfiguration = await prisma.jobConfiguration.upsert({
     *   create: {
     *     // ... data to create a JobConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends JobConfigurationUpsertArgs>(args: SelectSubset<T, JobConfigurationUpsertArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationCountArgs} args - Arguments to filter JobConfigurations to count.
     * @example
     * // Count the number of JobConfigurations
     * const count = await prisma.jobConfiguration.count({
     *   where: {
     *     // ... the filter for the JobConfigurations we want to count
     *   }
     * })
    **/
    count<T extends JobConfigurationCountArgs>(
      args?: Subset<T, JobConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobConfigurationAggregateArgs>(args: Subset<T, JobConfigurationAggregateArgs>): Prisma.PrismaPromise<GetJobConfigurationAggregateType<T>>

    /**
     * Group by JobConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: JobConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobConfiguration model
   */
  readonly fields: JobConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evalTemplate<T extends JobConfiguration$evalTemplateArgs<ExtArgs> = {}>(args?: Subset<T, JobConfiguration$evalTemplateArgs<ExtArgs>>): Prisma__EvalTemplateClient<$Result.GetResult<Prisma.$EvalTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    JobExecution<T extends JobConfiguration$JobExecutionArgs<ExtArgs> = {}>(args?: Subset<T, JobConfiguration$JobExecutionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobConfiguration model
   */ 
  interface JobConfigurationFieldRefs {
    readonly id: FieldRef<"JobConfiguration", 'String'>
    readonly createdAt: FieldRef<"JobConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"JobConfiguration", 'DateTime'>
    readonly projectId: FieldRef<"JobConfiguration", 'String'>
    readonly jobType: FieldRef<"JobConfiguration", 'JobType'>
    readonly status: FieldRef<"JobConfiguration", 'JobConfigState'>
    readonly evalTemplateId: FieldRef<"JobConfiguration", 'String'>
    readonly scoreName: FieldRef<"JobConfiguration", 'String'>
    readonly filter: FieldRef<"JobConfiguration", 'Json'>
    readonly targetObject: FieldRef<"JobConfiguration", 'String'>
    readonly variableMapping: FieldRef<"JobConfiguration", 'Json'>
    readonly sampling: FieldRef<"JobConfiguration", 'Decimal'>
    readonly delay: FieldRef<"JobConfiguration", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * JobConfiguration findUnique
   */
  export type JobConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which JobConfiguration to fetch.
     */
    where: JobConfigurationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration findUniqueOrThrow
   */
  export type JobConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which JobConfiguration to fetch.
     */
    where: JobConfigurationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration findFirst
   */
  export type JobConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which JobConfiguration to fetch.
     */
    where?: JobConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobConfigurations to fetch.
     */
    orderBy?: JobConfigurationOrderByWithRelationInput | JobConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobConfigurations.
     */
    cursor?: JobConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobConfigurations.
     */
    distinct?: JobConfigurationScalarFieldEnum | JobConfigurationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration findFirstOrThrow
   */
  export type JobConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which JobConfiguration to fetch.
     */
    where?: JobConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobConfigurations to fetch.
     */
    orderBy?: JobConfigurationOrderByWithRelationInput | JobConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobConfigurations.
     */
    cursor?: JobConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobConfigurations.
     */
    distinct?: JobConfigurationScalarFieldEnum | JobConfigurationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration findMany
   */
  export type JobConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which JobConfigurations to fetch.
     */
    where?: JobConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobConfigurations to fetch.
     */
    orderBy?: JobConfigurationOrderByWithRelationInput | JobConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobConfigurations.
     */
    cursor?: JobConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobConfigurations.
     */
    skip?: number
    distinct?: JobConfigurationScalarFieldEnum | JobConfigurationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration create
   */
  export type JobConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobConfiguration.
     */
    data: XOR<JobConfigurationCreateInput, JobConfigurationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration createMany
   */
  export type JobConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobConfigurations.
     */
    data: JobConfigurationCreateManyInput | JobConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobConfiguration createManyAndReturn
   */
  export type JobConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobConfigurations.
     */
    data: JobConfigurationCreateManyInput | JobConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobConfiguration update
   */
  export type JobConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobConfiguration.
     */
    data: XOR<JobConfigurationUpdateInput, JobConfigurationUncheckedUpdateInput>
    /**
     * Choose, which JobConfiguration to update.
     */
    where: JobConfigurationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration updateMany
   */
  export type JobConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobConfigurations.
     */
    data: XOR<JobConfigurationUpdateManyMutationInput, JobConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which JobConfigurations to update
     */
    where?: JobConfigurationWhereInput
  }

  /**
   * JobConfiguration upsert
   */
  export type JobConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobConfiguration to update in case it exists.
     */
    where: JobConfigurationWhereUniqueInput
    /**
     * In case the JobConfiguration found by the `where` argument doesn't exist, create a new JobConfiguration with this data.
     */
    create: XOR<JobConfigurationCreateInput, JobConfigurationUncheckedCreateInput>
    /**
     * In case the JobConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobConfigurationUpdateInput, JobConfigurationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration delete
   */
  export type JobConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
    /**
     * Filter which JobConfiguration to delete.
     */
    where: JobConfigurationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobConfiguration deleteMany
   */
  export type JobConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobConfigurations to delete
     */
    where?: JobConfigurationWhereInput
  }

  /**
   * JobConfiguration.evalTemplate
   */
  export type JobConfiguration$evalTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvalTemplate
     */
    select?: EvalTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvalTemplateInclude<ExtArgs> | null
    where?: EvalTemplateWhereInput
  }

  /**
   * JobConfiguration.JobExecution
   */
  export type JobConfiguration$JobExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    where?: JobExecutionWhereInput
    orderBy?: JobExecutionOrderByWithRelationInput | JobExecutionOrderByWithRelationInput[]
    cursor?: JobExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobExecutionScalarFieldEnum | JobExecutionScalarFieldEnum[]
  }

  /**
   * JobConfiguration without action
   */
  export type JobConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobConfiguration
     */
    select?: JobConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model JobExecution
   */

  export type AggregateJobExecution = {
    _count: JobExecutionCountAggregateOutputType | null
    _min: JobExecutionMinAggregateOutputType | null
    _max: JobExecutionMaxAggregateOutputType | null
  }

  export type JobExecutionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    jobConfigurationId: string | null
    status: $Enums.JobExecutionStatus | null
    startTime: Date | null
    endTime: Date | null
    error: string | null
    jobInputTraceId: string | null
    jobInputObservationId: string | null
    jobInputDatasetItemId: string | null
    jobOutputScoreId: string | null
  }

  export type JobExecutionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    jobConfigurationId: string | null
    status: $Enums.JobExecutionStatus | null
    startTime: Date | null
    endTime: Date | null
    error: string | null
    jobInputTraceId: string | null
    jobInputObservationId: string | null
    jobInputDatasetItemId: string | null
    jobOutputScoreId: string | null
  }

  export type JobExecutionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    jobConfigurationId: number
    status: number
    startTime: number
    endTime: number
    error: number
    jobInputTraceId: number
    jobInputObservationId: number
    jobInputDatasetItemId: number
    jobOutputScoreId: number
    _all: number
  }


  export type JobExecutionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    jobConfigurationId?: true
    status?: true
    startTime?: true
    endTime?: true
    error?: true
    jobInputTraceId?: true
    jobInputObservationId?: true
    jobInputDatasetItemId?: true
    jobOutputScoreId?: true
  }

  export type JobExecutionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    jobConfigurationId?: true
    status?: true
    startTime?: true
    endTime?: true
    error?: true
    jobInputTraceId?: true
    jobInputObservationId?: true
    jobInputDatasetItemId?: true
    jobOutputScoreId?: true
  }

  export type JobExecutionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    jobConfigurationId?: true
    status?: true
    startTime?: true
    endTime?: true
    error?: true
    jobInputTraceId?: true
    jobInputObservationId?: true
    jobInputDatasetItemId?: true
    jobOutputScoreId?: true
    _all?: true
  }

  export type JobExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobExecution to aggregate.
     */
    where?: JobExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobExecutions to fetch.
     */
    orderBy?: JobExecutionOrderByWithRelationInput | JobExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobExecutions
    **/
    _count?: true | JobExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobExecutionMaxAggregateInputType
  }

  export type GetJobExecutionAggregateType<T extends JobExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateJobExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobExecution[P]>
      : GetScalarType<T[P], AggregateJobExecution[P]>
  }




  export type JobExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobExecutionWhereInput
    orderBy?: JobExecutionOrderByWithAggregationInput | JobExecutionOrderByWithAggregationInput[]
    by: JobExecutionScalarFieldEnum[] | JobExecutionScalarFieldEnum
    having?: JobExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobExecutionCountAggregateInputType | true
    _min?: JobExecutionMinAggregateInputType
    _max?: JobExecutionMaxAggregateInputType
  }

  export type JobExecutionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    jobConfigurationId: string
    status: $Enums.JobExecutionStatus
    startTime: Date | null
    endTime: Date | null
    error: string | null
    jobInputTraceId: string | null
    jobInputObservationId: string | null
    jobInputDatasetItemId: string | null
    jobOutputScoreId: string | null
    _count: JobExecutionCountAggregateOutputType | null
    _min: JobExecutionMinAggregateOutputType | null
    _max: JobExecutionMaxAggregateOutputType | null
  }

  type GetJobExecutionGroupByPayload<T extends JobExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], JobExecutionGroupByOutputType[P]>
        }
      >
    >


  export type JobExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    jobConfigurationId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    error?: boolean
    jobInputTraceId?: boolean
    jobInputObservationId?: boolean
    jobInputDatasetItemId?: boolean
    jobOutputScoreId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    jobConfiguration?: boolean | JobConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobExecution"]>

  export type JobExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    jobConfigurationId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    error?: boolean
    jobInputTraceId?: boolean
    jobInputObservationId?: boolean
    jobInputDatasetItemId?: boolean
    jobOutputScoreId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    jobConfiguration?: boolean | JobConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobExecution"]>

  export type JobExecutionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    jobConfigurationId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    error?: boolean
    jobInputTraceId?: boolean
    jobInputObservationId?: boolean
    jobInputDatasetItemId?: boolean
    jobOutputScoreId?: boolean
  }

  export type JobExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    jobConfiguration?: boolean | JobConfigurationDefaultArgs<ExtArgs>
  }
  export type JobExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    jobConfiguration?: boolean | JobConfigurationDefaultArgs<ExtArgs>
  }

  export type $JobExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobExecution"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      jobConfiguration: Prisma.$JobConfigurationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      jobConfigurationId: string
      status: $Enums.JobExecutionStatus
      startTime: Date | null
      endTime: Date | null
      error: string | null
      jobInputTraceId: string | null
      jobInputObservationId: string | null
      jobInputDatasetItemId: string | null
      jobOutputScoreId: string | null
    }, ExtArgs["result"]["jobExecution"]>
    composites: {}
  }

  type JobExecutionGetPayload<S extends boolean | null | undefined | JobExecutionDefaultArgs> = $Result.GetResult<Prisma.$JobExecutionPayload, S>

  type JobExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: JobExecutionCountAggregateInputType | true
    }

  export interface JobExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobExecution'], meta: { name: 'JobExecution' } }
    /**
     * Find zero or one JobExecution that matches the filter.
     * @param {JobExecutionFindUniqueArgs} args - Arguments to find a JobExecution
     * @example
     * // Get one JobExecution
     * const jobExecution = await prisma.jobExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobExecutionFindUniqueArgs>(args: SelectSubset<T, JobExecutionFindUniqueArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobExecutionFindUniqueOrThrowArgs} args - Arguments to find a JobExecution
     * @example
     * // Get one JobExecution
     * const jobExecution = await prisma.jobExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, JobExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionFindFirstArgs} args - Arguments to find a JobExecution
     * @example
     * // Get one JobExecution
     * const jobExecution = await prisma.jobExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobExecutionFindFirstArgs>(args?: SelectSubset<T, JobExecutionFindFirstArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionFindFirstOrThrowArgs} args - Arguments to find a JobExecution
     * @example
     * // Get one JobExecution
     * const jobExecution = await prisma.jobExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, JobExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobExecutions
     * const jobExecutions = await prisma.jobExecution.findMany()
     * 
     * // Get first 10 JobExecutions
     * const jobExecutions = await prisma.jobExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobExecutionWithIdOnly = await prisma.jobExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobExecutionFindManyArgs>(args?: SelectSubset<T, JobExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobExecution.
     * @param {JobExecutionCreateArgs} args - Arguments to create a JobExecution.
     * @example
     * // Create one JobExecution
     * const JobExecution = await prisma.jobExecution.create({
     *   data: {
     *     // ... data to create a JobExecution
     *   }
     * })
     * 
     */
    create<T extends JobExecutionCreateArgs>(args: SelectSubset<T, JobExecutionCreateArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobExecutions.
     * @param {JobExecutionCreateManyArgs} args - Arguments to create many JobExecutions.
     * @example
     * // Create many JobExecutions
     * const jobExecution = await prisma.jobExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobExecutionCreateManyArgs>(args?: SelectSubset<T, JobExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobExecutions and returns the data saved in the database.
     * @param {JobExecutionCreateManyAndReturnArgs} args - Arguments to create many JobExecutions.
     * @example
     * // Create many JobExecutions
     * const jobExecution = await prisma.jobExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobExecutions and only return the `id`
     * const jobExecutionWithIdOnly = await prisma.jobExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, JobExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobExecution.
     * @param {JobExecutionDeleteArgs} args - Arguments to delete one JobExecution.
     * @example
     * // Delete one JobExecution
     * const JobExecution = await prisma.jobExecution.delete({
     *   where: {
     *     // ... filter to delete one JobExecution
     *   }
     * })
     * 
     */
    delete<T extends JobExecutionDeleteArgs>(args: SelectSubset<T, JobExecutionDeleteArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobExecution.
     * @param {JobExecutionUpdateArgs} args - Arguments to update one JobExecution.
     * @example
     * // Update one JobExecution
     * const jobExecution = await prisma.jobExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobExecutionUpdateArgs>(args: SelectSubset<T, JobExecutionUpdateArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobExecutions.
     * @param {JobExecutionDeleteManyArgs} args - Arguments to filter JobExecutions to delete.
     * @example
     * // Delete a few JobExecutions
     * const { count } = await prisma.jobExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobExecutionDeleteManyArgs>(args?: SelectSubset<T, JobExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobExecutions
     * const jobExecution = await prisma.jobExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobExecutionUpdateManyArgs>(args: SelectSubset<T, JobExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobExecution.
     * @param {JobExecutionUpsertArgs} args - Arguments to update or create a JobExecution.
     * @example
     * // Update or create a JobExecution
     * const jobExecution = await prisma.jobExecution.upsert({
     *   create: {
     *     // ... data to create a JobExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobExecution we want to update
     *   }
     * })
     */
    upsert<T extends JobExecutionUpsertArgs>(args: SelectSubset<T, JobExecutionUpsertArgs<ExtArgs>>): Prisma__JobExecutionClient<$Result.GetResult<Prisma.$JobExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionCountArgs} args - Arguments to filter JobExecutions to count.
     * @example
     * // Count the number of JobExecutions
     * const count = await prisma.jobExecution.count({
     *   where: {
     *     // ... the filter for the JobExecutions we want to count
     *   }
     * })
    **/
    count<T extends JobExecutionCountArgs>(
      args?: Subset<T, JobExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobExecutionAggregateArgs>(args: Subset<T, JobExecutionAggregateArgs>): Prisma.PrismaPromise<GetJobExecutionAggregateType<T>>

    /**
     * Group by JobExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobExecutionGroupByArgs['orderBy'] }
        : { orderBy?: JobExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobExecution model
   */
  readonly fields: JobExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jobConfiguration<T extends JobConfigurationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobConfigurationDefaultArgs<ExtArgs>>): Prisma__JobConfigurationClient<$Result.GetResult<Prisma.$JobConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobExecution model
   */ 
  interface JobExecutionFieldRefs {
    readonly id: FieldRef<"JobExecution", 'String'>
    readonly createdAt: FieldRef<"JobExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"JobExecution", 'DateTime'>
    readonly projectId: FieldRef<"JobExecution", 'String'>
    readonly jobConfigurationId: FieldRef<"JobExecution", 'String'>
    readonly status: FieldRef<"JobExecution", 'JobExecutionStatus'>
    readonly startTime: FieldRef<"JobExecution", 'DateTime'>
    readonly endTime: FieldRef<"JobExecution", 'DateTime'>
    readonly error: FieldRef<"JobExecution", 'String'>
    readonly jobInputTraceId: FieldRef<"JobExecution", 'String'>
    readonly jobInputObservationId: FieldRef<"JobExecution", 'String'>
    readonly jobInputDatasetItemId: FieldRef<"JobExecution", 'String'>
    readonly jobOutputScoreId: FieldRef<"JobExecution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobExecution findUnique
   */
  export type JobExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * Filter, which JobExecution to fetch.
     */
    where: JobExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution findUniqueOrThrow
   */
  export type JobExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * Filter, which JobExecution to fetch.
     */
    where: JobExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution findFirst
   */
  export type JobExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * Filter, which JobExecution to fetch.
     */
    where?: JobExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobExecutions to fetch.
     */
    orderBy?: JobExecutionOrderByWithRelationInput | JobExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobExecutions.
     */
    cursor?: JobExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobExecutions.
     */
    distinct?: JobExecutionScalarFieldEnum | JobExecutionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution findFirstOrThrow
   */
  export type JobExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * Filter, which JobExecution to fetch.
     */
    where?: JobExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobExecutions to fetch.
     */
    orderBy?: JobExecutionOrderByWithRelationInput | JobExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobExecutions.
     */
    cursor?: JobExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobExecutions.
     */
    distinct?: JobExecutionScalarFieldEnum | JobExecutionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution findMany
   */
  export type JobExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * Filter, which JobExecutions to fetch.
     */
    where?: JobExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobExecutions to fetch.
     */
    orderBy?: JobExecutionOrderByWithRelationInput | JobExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobExecutions.
     */
    cursor?: JobExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobExecutions.
     */
    skip?: number
    distinct?: JobExecutionScalarFieldEnum | JobExecutionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution create
   */
  export type JobExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a JobExecution.
     */
    data: XOR<JobExecutionCreateInput, JobExecutionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution createMany
   */
  export type JobExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobExecutions.
     */
    data: JobExecutionCreateManyInput | JobExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobExecution createManyAndReturn
   */
  export type JobExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobExecutions.
     */
    data: JobExecutionCreateManyInput | JobExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobExecution update
   */
  export type JobExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a JobExecution.
     */
    data: XOR<JobExecutionUpdateInput, JobExecutionUncheckedUpdateInput>
    /**
     * Choose, which JobExecution to update.
     */
    where: JobExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution updateMany
   */
  export type JobExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobExecutions.
     */
    data: XOR<JobExecutionUpdateManyMutationInput, JobExecutionUncheckedUpdateManyInput>
    /**
     * Filter which JobExecutions to update
     */
    where?: JobExecutionWhereInput
  }

  /**
   * JobExecution upsert
   */
  export type JobExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the JobExecution to update in case it exists.
     */
    where: JobExecutionWhereUniqueInput
    /**
     * In case the JobExecution found by the `where` argument doesn't exist, create a new JobExecution with this data.
     */
    create: XOR<JobExecutionCreateInput, JobExecutionUncheckedCreateInput>
    /**
     * In case the JobExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobExecutionUpdateInput, JobExecutionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution delete
   */
  export type JobExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
    /**
     * Filter which JobExecution to delete.
     */
    where: JobExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JobExecution deleteMany
   */
  export type JobExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobExecutions to delete
     */
    where?: JobExecutionWhereInput
  }

  /**
   * JobExecution without action
   */
  export type JobExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobExecution
     */
    select?: JobExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobExecutionInclude<ExtArgs> | null
  }


  /**
   * Model SsoConfig
   */

  export type AggregateSsoConfig = {
    _count: SsoConfigCountAggregateOutputType | null
    _min: SsoConfigMinAggregateOutputType | null
    _max: SsoConfigMaxAggregateOutputType | null
  }

  export type SsoConfigMinAggregateOutputType = {
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authProvider: string | null
  }

  export type SsoConfigMaxAggregateOutputType = {
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authProvider: string | null
  }

  export type SsoConfigCountAggregateOutputType = {
    domain: number
    createdAt: number
    updatedAt: number
    authProvider: number
    authConfig: number
    _all: number
  }


  export type SsoConfigMinAggregateInputType = {
    domain?: true
    createdAt?: true
    updatedAt?: true
    authProvider?: true
  }

  export type SsoConfigMaxAggregateInputType = {
    domain?: true
    createdAt?: true
    updatedAt?: true
    authProvider?: true
  }

  export type SsoConfigCountAggregateInputType = {
    domain?: true
    createdAt?: true
    updatedAt?: true
    authProvider?: true
    authConfig?: true
    _all?: true
  }

  export type SsoConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SsoConfig to aggregate.
     */
    where?: SsoConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigs to fetch.
     */
    orderBy?: SsoConfigOrderByWithRelationInput | SsoConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SsoConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SsoConfigs
    **/
    _count?: true | SsoConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SsoConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SsoConfigMaxAggregateInputType
  }

  export type GetSsoConfigAggregateType<T extends SsoConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSsoConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSsoConfig[P]>
      : GetScalarType<T[P], AggregateSsoConfig[P]>
  }




  export type SsoConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SsoConfigWhereInput
    orderBy?: SsoConfigOrderByWithAggregationInput | SsoConfigOrderByWithAggregationInput[]
    by: SsoConfigScalarFieldEnum[] | SsoConfigScalarFieldEnum
    having?: SsoConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SsoConfigCountAggregateInputType | true
    _min?: SsoConfigMinAggregateInputType
    _max?: SsoConfigMaxAggregateInputType
  }

  export type SsoConfigGroupByOutputType = {
    domain: string
    createdAt: Date
    updatedAt: Date
    authProvider: string
    authConfig: JsonValue | null
    _count: SsoConfigCountAggregateOutputType | null
    _min: SsoConfigMinAggregateOutputType | null
    _max: SsoConfigMaxAggregateOutputType | null
  }

  type GetSsoConfigGroupByPayload<T extends SsoConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SsoConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SsoConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SsoConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SsoConfigGroupByOutputType[P]>
        }
      >
    >


  export type SsoConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    authConfig?: boolean
  }, ExtArgs["result"]["ssoConfig"]>

  export type SsoConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    authConfig?: boolean
  }, ExtArgs["result"]["ssoConfig"]>

  export type SsoConfigSelectScalar = {
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    authConfig?: boolean
  }


  export type $SsoConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SsoConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      domain: string
      createdAt: Date
      updatedAt: Date
      authProvider: string
      authConfig: Prisma.JsonValue | null
    }, ExtArgs["result"]["ssoConfig"]>
    composites: {}
  }

  type SsoConfigGetPayload<S extends boolean | null | undefined | SsoConfigDefaultArgs> = $Result.GetResult<Prisma.$SsoConfigPayload, S>

  type SsoConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SsoConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: SsoConfigCountAggregateInputType | true
    }

  export interface SsoConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SsoConfig'], meta: { name: 'SsoConfig' } }
    /**
     * Find zero or one SsoConfig that matches the filter.
     * @param {SsoConfigFindUniqueArgs} args - Arguments to find a SsoConfig
     * @example
     * // Get one SsoConfig
     * const ssoConfig = await prisma.ssoConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SsoConfigFindUniqueArgs>(args: SelectSubset<T, SsoConfigFindUniqueArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SsoConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SsoConfigFindUniqueOrThrowArgs} args - Arguments to find a SsoConfig
     * @example
     * // Get one SsoConfig
     * const ssoConfig = await prisma.ssoConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SsoConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SsoConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SsoConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigFindFirstArgs} args - Arguments to find a SsoConfig
     * @example
     * // Get one SsoConfig
     * const ssoConfig = await prisma.ssoConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SsoConfigFindFirstArgs>(args?: SelectSubset<T, SsoConfigFindFirstArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SsoConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigFindFirstOrThrowArgs} args - Arguments to find a SsoConfig
     * @example
     * // Get one SsoConfig
     * const ssoConfig = await prisma.ssoConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SsoConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SsoConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SsoConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SsoConfigs
     * const ssoConfigs = await prisma.ssoConfig.findMany()
     * 
     * // Get first 10 SsoConfigs
     * const ssoConfigs = await prisma.ssoConfig.findMany({ take: 10 })
     * 
     * // Only select the `domain`
     * const ssoConfigWithDomainOnly = await prisma.ssoConfig.findMany({ select: { domain: true } })
     * 
     */
    findMany<T extends SsoConfigFindManyArgs>(args?: SelectSubset<T, SsoConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SsoConfig.
     * @param {SsoConfigCreateArgs} args - Arguments to create a SsoConfig.
     * @example
     * // Create one SsoConfig
     * const SsoConfig = await prisma.ssoConfig.create({
     *   data: {
     *     // ... data to create a SsoConfig
     *   }
     * })
     * 
     */
    create<T extends SsoConfigCreateArgs>(args: SelectSubset<T, SsoConfigCreateArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SsoConfigs.
     * @param {SsoConfigCreateManyArgs} args - Arguments to create many SsoConfigs.
     * @example
     * // Create many SsoConfigs
     * const ssoConfig = await prisma.ssoConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SsoConfigCreateManyArgs>(args?: SelectSubset<T, SsoConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SsoConfigs and returns the data saved in the database.
     * @param {SsoConfigCreateManyAndReturnArgs} args - Arguments to create many SsoConfigs.
     * @example
     * // Create many SsoConfigs
     * const ssoConfig = await prisma.ssoConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SsoConfigs and only return the `domain`
     * const ssoConfigWithDomainOnly = await prisma.ssoConfig.createManyAndReturn({ 
     *   select: { domain: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SsoConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SsoConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SsoConfig.
     * @param {SsoConfigDeleteArgs} args - Arguments to delete one SsoConfig.
     * @example
     * // Delete one SsoConfig
     * const SsoConfig = await prisma.ssoConfig.delete({
     *   where: {
     *     // ... filter to delete one SsoConfig
     *   }
     * })
     * 
     */
    delete<T extends SsoConfigDeleteArgs>(args: SelectSubset<T, SsoConfigDeleteArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SsoConfig.
     * @param {SsoConfigUpdateArgs} args - Arguments to update one SsoConfig.
     * @example
     * // Update one SsoConfig
     * const ssoConfig = await prisma.ssoConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SsoConfigUpdateArgs>(args: SelectSubset<T, SsoConfigUpdateArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SsoConfigs.
     * @param {SsoConfigDeleteManyArgs} args - Arguments to filter SsoConfigs to delete.
     * @example
     * // Delete a few SsoConfigs
     * const { count } = await prisma.ssoConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SsoConfigDeleteManyArgs>(args?: SelectSubset<T, SsoConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SsoConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SsoConfigs
     * const ssoConfig = await prisma.ssoConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SsoConfigUpdateManyArgs>(args: SelectSubset<T, SsoConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SsoConfig.
     * @param {SsoConfigUpsertArgs} args - Arguments to update or create a SsoConfig.
     * @example
     * // Update or create a SsoConfig
     * const ssoConfig = await prisma.ssoConfig.upsert({
     *   create: {
     *     // ... data to create a SsoConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SsoConfig we want to update
     *   }
     * })
     */
    upsert<T extends SsoConfigUpsertArgs>(args: SelectSubset<T, SsoConfigUpsertArgs<ExtArgs>>): Prisma__SsoConfigClient<$Result.GetResult<Prisma.$SsoConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SsoConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigCountArgs} args - Arguments to filter SsoConfigs to count.
     * @example
     * // Count the number of SsoConfigs
     * const count = await prisma.ssoConfig.count({
     *   where: {
     *     // ... the filter for the SsoConfigs we want to count
     *   }
     * })
    **/
    count<T extends SsoConfigCountArgs>(
      args?: Subset<T, SsoConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SsoConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SsoConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SsoConfigAggregateArgs>(args: Subset<T, SsoConfigAggregateArgs>): Prisma.PrismaPromise<GetSsoConfigAggregateType<T>>

    /**
     * Group by SsoConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SsoConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SsoConfigGroupByArgs['orderBy'] }
        : { orderBy?: SsoConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SsoConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSsoConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SsoConfig model
   */
  readonly fields: SsoConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SsoConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SsoConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SsoConfig model
   */ 
  interface SsoConfigFieldRefs {
    readonly domain: FieldRef<"SsoConfig", 'String'>
    readonly createdAt: FieldRef<"SsoConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SsoConfig", 'DateTime'>
    readonly authProvider: FieldRef<"SsoConfig", 'String'>
    readonly authConfig: FieldRef<"SsoConfig", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SsoConfig findUnique
   */
  export type SsoConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * Filter, which SsoConfig to fetch.
     */
    where: SsoConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig findUniqueOrThrow
   */
  export type SsoConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * Filter, which SsoConfig to fetch.
     */
    where: SsoConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig findFirst
   */
  export type SsoConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * Filter, which SsoConfig to fetch.
     */
    where?: SsoConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigs to fetch.
     */
    orderBy?: SsoConfigOrderByWithRelationInput | SsoConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SsoConfigs.
     */
    cursor?: SsoConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SsoConfigs.
     */
    distinct?: SsoConfigScalarFieldEnum | SsoConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig findFirstOrThrow
   */
  export type SsoConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * Filter, which SsoConfig to fetch.
     */
    where?: SsoConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigs to fetch.
     */
    orderBy?: SsoConfigOrderByWithRelationInput | SsoConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SsoConfigs.
     */
    cursor?: SsoConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SsoConfigs.
     */
    distinct?: SsoConfigScalarFieldEnum | SsoConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig findMany
   */
  export type SsoConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * Filter, which SsoConfigs to fetch.
     */
    where?: SsoConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigs to fetch.
     */
    orderBy?: SsoConfigOrderByWithRelationInput | SsoConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SsoConfigs.
     */
    cursor?: SsoConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigs.
     */
    skip?: number
    distinct?: SsoConfigScalarFieldEnum | SsoConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig create
   */
  export type SsoConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SsoConfig.
     */
    data: XOR<SsoConfigCreateInput, SsoConfigUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig createMany
   */
  export type SsoConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SsoConfigs.
     */
    data: SsoConfigCreateManyInput | SsoConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SsoConfig createManyAndReturn
   */
  export type SsoConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SsoConfigs.
     */
    data: SsoConfigCreateManyInput | SsoConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SsoConfig update
   */
  export type SsoConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SsoConfig.
     */
    data: XOR<SsoConfigUpdateInput, SsoConfigUncheckedUpdateInput>
    /**
     * Choose, which SsoConfig to update.
     */
    where: SsoConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig updateMany
   */
  export type SsoConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SsoConfigs.
     */
    data: XOR<SsoConfigUpdateManyMutationInput, SsoConfigUncheckedUpdateManyInput>
    /**
     * Filter which SsoConfigs to update
     */
    where?: SsoConfigWhereInput
  }

  /**
   * SsoConfig upsert
   */
  export type SsoConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SsoConfig to update in case it exists.
     */
    where: SsoConfigWhereUniqueInput
    /**
     * In case the SsoConfig found by the `where` argument doesn't exist, create a new SsoConfig with this data.
     */
    create: XOR<SsoConfigCreateInput, SsoConfigUncheckedCreateInput>
    /**
     * In case the SsoConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SsoConfigUpdateInput, SsoConfigUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig delete
   */
  export type SsoConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
    /**
     * Filter which SsoConfig to delete.
     */
    where: SsoConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SsoConfig deleteMany
   */
  export type SsoConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SsoConfigs to delete
     */
    where?: SsoConfigWhereInput
  }

  /**
   * SsoConfig without action
   */
  export type SsoConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfig
     */
    select?: SsoConfigSelect<ExtArgs> | null
  }


  /**
   * Model PosthogIntegration
   */

  export type AggregatePosthogIntegration = {
    _count: PosthogIntegrationCountAggregateOutputType | null
    _min: PosthogIntegrationMinAggregateOutputType | null
    _max: PosthogIntegrationMaxAggregateOutputType | null
  }

  export type PosthogIntegrationMinAggregateOutputType = {
    projectId: string | null
    encryptedPosthogApiKey: string | null
    posthogHostName: string | null
    lastSyncAt: Date | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type PosthogIntegrationMaxAggregateOutputType = {
    projectId: string | null
    encryptedPosthogApiKey: string | null
    posthogHostName: string | null
    lastSyncAt: Date | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type PosthogIntegrationCountAggregateOutputType = {
    projectId: number
    encryptedPosthogApiKey: number
    posthogHostName: number
    lastSyncAt: number
    enabled: number
    createdAt: number
    _all: number
  }


  export type PosthogIntegrationMinAggregateInputType = {
    projectId?: true
    encryptedPosthogApiKey?: true
    posthogHostName?: true
    lastSyncAt?: true
    enabled?: true
    createdAt?: true
  }

  export type PosthogIntegrationMaxAggregateInputType = {
    projectId?: true
    encryptedPosthogApiKey?: true
    posthogHostName?: true
    lastSyncAt?: true
    enabled?: true
    createdAt?: true
  }

  export type PosthogIntegrationCountAggregateInputType = {
    projectId?: true
    encryptedPosthogApiKey?: true
    posthogHostName?: true
    lastSyncAt?: true
    enabled?: true
    createdAt?: true
    _all?: true
  }

  export type PosthogIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosthogIntegration to aggregate.
     */
    where?: PosthogIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosthogIntegrations to fetch.
     */
    orderBy?: PosthogIntegrationOrderByWithRelationInput | PosthogIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosthogIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosthogIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosthogIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosthogIntegrations
    **/
    _count?: true | PosthogIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosthogIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosthogIntegrationMaxAggregateInputType
  }

  export type GetPosthogIntegrationAggregateType<T extends PosthogIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregatePosthogIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosthogIntegration[P]>
      : GetScalarType<T[P], AggregatePosthogIntegration[P]>
  }




  export type PosthogIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosthogIntegrationWhereInput
    orderBy?: PosthogIntegrationOrderByWithAggregationInput | PosthogIntegrationOrderByWithAggregationInput[]
    by: PosthogIntegrationScalarFieldEnum[] | PosthogIntegrationScalarFieldEnum
    having?: PosthogIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosthogIntegrationCountAggregateInputType | true
    _min?: PosthogIntegrationMinAggregateInputType
    _max?: PosthogIntegrationMaxAggregateInputType
  }

  export type PosthogIntegrationGroupByOutputType = {
    projectId: string
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt: Date | null
    enabled: boolean
    createdAt: Date
    _count: PosthogIntegrationCountAggregateOutputType | null
    _min: PosthogIntegrationMinAggregateOutputType | null
    _max: PosthogIntegrationMaxAggregateOutputType | null
  }

  type GetPosthogIntegrationGroupByPayload<T extends PosthogIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosthogIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosthogIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosthogIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], PosthogIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type PosthogIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    encryptedPosthogApiKey?: boolean
    posthogHostName?: boolean
    lastSyncAt?: boolean
    enabled?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posthogIntegration"]>

  export type PosthogIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    encryptedPosthogApiKey?: boolean
    posthogHostName?: boolean
    lastSyncAt?: boolean
    enabled?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posthogIntegration"]>

  export type PosthogIntegrationSelectScalar = {
    projectId?: boolean
    encryptedPosthogApiKey?: boolean
    posthogHostName?: boolean
    lastSyncAt?: boolean
    enabled?: boolean
    createdAt?: boolean
  }

  export type PosthogIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PosthogIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PosthogIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosthogIntegration"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      encryptedPosthogApiKey: string
      posthogHostName: string
      lastSyncAt: Date | null
      enabled: boolean
      createdAt: Date
    }, ExtArgs["result"]["posthogIntegration"]>
    composites: {}
  }

  type PosthogIntegrationGetPayload<S extends boolean | null | undefined | PosthogIntegrationDefaultArgs> = $Result.GetResult<Prisma.$PosthogIntegrationPayload, S>

  type PosthogIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PosthogIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PosthogIntegrationCountAggregateInputType | true
    }

  export interface PosthogIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosthogIntegration'], meta: { name: 'PosthogIntegration' } }
    /**
     * Find zero or one PosthogIntegration that matches the filter.
     * @param {PosthogIntegrationFindUniqueArgs} args - Arguments to find a PosthogIntegration
     * @example
     * // Get one PosthogIntegration
     * const posthogIntegration = await prisma.posthogIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosthogIntegrationFindUniqueArgs>(args: SelectSubset<T, PosthogIntegrationFindUniqueArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PosthogIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PosthogIntegrationFindUniqueOrThrowArgs} args - Arguments to find a PosthogIntegration
     * @example
     * // Get one PosthogIntegration
     * const posthogIntegration = await prisma.posthogIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosthogIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, PosthogIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PosthogIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationFindFirstArgs} args - Arguments to find a PosthogIntegration
     * @example
     * // Get one PosthogIntegration
     * const posthogIntegration = await prisma.posthogIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosthogIntegrationFindFirstArgs>(args?: SelectSubset<T, PosthogIntegrationFindFirstArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PosthogIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationFindFirstOrThrowArgs} args - Arguments to find a PosthogIntegration
     * @example
     * // Get one PosthogIntegration
     * const posthogIntegration = await prisma.posthogIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosthogIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, PosthogIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PosthogIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosthogIntegrations
     * const posthogIntegrations = await prisma.posthogIntegration.findMany()
     * 
     * // Get first 10 PosthogIntegrations
     * const posthogIntegrations = await prisma.posthogIntegration.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const posthogIntegrationWithProjectIdOnly = await prisma.posthogIntegration.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends PosthogIntegrationFindManyArgs>(args?: SelectSubset<T, PosthogIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PosthogIntegration.
     * @param {PosthogIntegrationCreateArgs} args - Arguments to create a PosthogIntegration.
     * @example
     * // Create one PosthogIntegration
     * const PosthogIntegration = await prisma.posthogIntegration.create({
     *   data: {
     *     // ... data to create a PosthogIntegration
     *   }
     * })
     * 
     */
    create<T extends PosthogIntegrationCreateArgs>(args: SelectSubset<T, PosthogIntegrationCreateArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PosthogIntegrations.
     * @param {PosthogIntegrationCreateManyArgs} args - Arguments to create many PosthogIntegrations.
     * @example
     * // Create many PosthogIntegrations
     * const posthogIntegration = await prisma.posthogIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosthogIntegrationCreateManyArgs>(args?: SelectSubset<T, PosthogIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosthogIntegrations and returns the data saved in the database.
     * @param {PosthogIntegrationCreateManyAndReturnArgs} args - Arguments to create many PosthogIntegrations.
     * @example
     * // Create many PosthogIntegrations
     * const posthogIntegration = await prisma.posthogIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosthogIntegrations and only return the `projectId`
     * const posthogIntegrationWithProjectIdOnly = await prisma.posthogIntegration.createManyAndReturn({ 
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosthogIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, PosthogIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PosthogIntegration.
     * @param {PosthogIntegrationDeleteArgs} args - Arguments to delete one PosthogIntegration.
     * @example
     * // Delete one PosthogIntegration
     * const PosthogIntegration = await prisma.posthogIntegration.delete({
     *   where: {
     *     // ... filter to delete one PosthogIntegration
     *   }
     * })
     * 
     */
    delete<T extends PosthogIntegrationDeleteArgs>(args: SelectSubset<T, PosthogIntegrationDeleteArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PosthogIntegration.
     * @param {PosthogIntegrationUpdateArgs} args - Arguments to update one PosthogIntegration.
     * @example
     * // Update one PosthogIntegration
     * const posthogIntegration = await prisma.posthogIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosthogIntegrationUpdateArgs>(args: SelectSubset<T, PosthogIntegrationUpdateArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PosthogIntegrations.
     * @param {PosthogIntegrationDeleteManyArgs} args - Arguments to filter PosthogIntegrations to delete.
     * @example
     * // Delete a few PosthogIntegrations
     * const { count } = await prisma.posthogIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosthogIntegrationDeleteManyArgs>(args?: SelectSubset<T, PosthogIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosthogIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosthogIntegrations
     * const posthogIntegration = await prisma.posthogIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosthogIntegrationUpdateManyArgs>(args: SelectSubset<T, PosthogIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PosthogIntegration.
     * @param {PosthogIntegrationUpsertArgs} args - Arguments to update or create a PosthogIntegration.
     * @example
     * // Update or create a PosthogIntegration
     * const posthogIntegration = await prisma.posthogIntegration.upsert({
     *   create: {
     *     // ... data to create a PosthogIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosthogIntegration we want to update
     *   }
     * })
     */
    upsert<T extends PosthogIntegrationUpsertArgs>(args: SelectSubset<T, PosthogIntegrationUpsertArgs<ExtArgs>>): Prisma__PosthogIntegrationClient<$Result.GetResult<Prisma.$PosthogIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PosthogIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationCountArgs} args - Arguments to filter PosthogIntegrations to count.
     * @example
     * // Count the number of PosthogIntegrations
     * const count = await prisma.posthogIntegration.count({
     *   where: {
     *     // ... the filter for the PosthogIntegrations we want to count
     *   }
     * })
    **/
    count<T extends PosthogIntegrationCountArgs>(
      args?: Subset<T, PosthogIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosthogIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosthogIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosthogIntegrationAggregateArgs>(args: Subset<T, PosthogIntegrationAggregateArgs>): Prisma.PrismaPromise<GetPosthogIntegrationAggregateType<T>>

    /**
     * Group by PosthogIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosthogIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosthogIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosthogIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: PosthogIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosthogIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosthogIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosthogIntegration model
   */
  readonly fields: PosthogIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosthogIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosthogIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosthogIntegration model
   */ 
  interface PosthogIntegrationFieldRefs {
    readonly projectId: FieldRef<"PosthogIntegration", 'String'>
    readonly encryptedPosthogApiKey: FieldRef<"PosthogIntegration", 'String'>
    readonly posthogHostName: FieldRef<"PosthogIntegration", 'String'>
    readonly lastSyncAt: FieldRef<"PosthogIntegration", 'DateTime'>
    readonly enabled: FieldRef<"PosthogIntegration", 'Boolean'>
    readonly createdAt: FieldRef<"PosthogIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PosthogIntegration findUnique
   */
  export type PosthogIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which PosthogIntegration to fetch.
     */
    where: PosthogIntegrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration findUniqueOrThrow
   */
  export type PosthogIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which PosthogIntegration to fetch.
     */
    where: PosthogIntegrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration findFirst
   */
  export type PosthogIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which PosthogIntegration to fetch.
     */
    where?: PosthogIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosthogIntegrations to fetch.
     */
    orderBy?: PosthogIntegrationOrderByWithRelationInput | PosthogIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosthogIntegrations.
     */
    cursor?: PosthogIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosthogIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosthogIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosthogIntegrations.
     */
    distinct?: PosthogIntegrationScalarFieldEnum | PosthogIntegrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration findFirstOrThrow
   */
  export type PosthogIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which PosthogIntegration to fetch.
     */
    where?: PosthogIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosthogIntegrations to fetch.
     */
    orderBy?: PosthogIntegrationOrderByWithRelationInput | PosthogIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosthogIntegrations.
     */
    cursor?: PosthogIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosthogIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosthogIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosthogIntegrations.
     */
    distinct?: PosthogIntegrationScalarFieldEnum | PosthogIntegrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration findMany
   */
  export type PosthogIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which PosthogIntegrations to fetch.
     */
    where?: PosthogIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosthogIntegrations to fetch.
     */
    orderBy?: PosthogIntegrationOrderByWithRelationInput | PosthogIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosthogIntegrations.
     */
    cursor?: PosthogIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosthogIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosthogIntegrations.
     */
    skip?: number
    distinct?: PosthogIntegrationScalarFieldEnum | PosthogIntegrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration create
   */
  export type PosthogIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a PosthogIntegration.
     */
    data: XOR<PosthogIntegrationCreateInput, PosthogIntegrationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration createMany
   */
  export type PosthogIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosthogIntegrations.
     */
    data: PosthogIntegrationCreateManyInput | PosthogIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosthogIntegration createManyAndReturn
   */
  export type PosthogIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PosthogIntegrations.
     */
    data: PosthogIntegrationCreateManyInput | PosthogIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosthogIntegration update
   */
  export type PosthogIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a PosthogIntegration.
     */
    data: XOR<PosthogIntegrationUpdateInput, PosthogIntegrationUncheckedUpdateInput>
    /**
     * Choose, which PosthogIntegration to update.
     */
    where: PosthogIntegrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration updateMany
   */
  export type PosthogIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosthogIntegrations.
     */
    data: XOR<PosthogIntegrationUpdateManyMutationInput, PosthogIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which PosthogIntegrations to update
     */
    where?: PosthogIntegrationWhereInput
  }

  /**
   * PosthogIntegration upsert
   */
  export type PosthogIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the PosthogIntegration to update in case it exists.
     */
    where: PosthogIntegrationWhereUniqueInput
    /**
     * In case the PosthogIntegration found by the `where` argument doesn't exist, create a new PosthogIntegration with this data.
     */
    create: XOR<PosthogIntegrationCreateInput, PosthogIntegrationUncheckedCreateInput>
    /**
     * In case the PosthogIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosthogIntegrationUpdateInput, PosthogIntegrationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration delete
   */
  export type PosthogIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
    /**
     * Filter which PosthogIntegration to delete.
     */
    where: PosthogIntegrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PosthogIntegration deleteMany
   */
  export type PosthogIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosthogIntegrations to delete
     */
    where?: PosthogIntegrationWhereInput
  }

  /**
   * PosthogIntegration without action
   */
  export type PosthogIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosthogIntegration
     */
    select?: PosthogIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosthogIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model BatchExport
   */

  export type AggregateBatchExport = {
    _count: BatchExportCountAggregateOutputType | null
    _min: BatchExportMinAggregateOutputType | null
    _max: BatchExportMaxAggregateOutputType | null
  }

  export type BatchExportMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
    finishedAt: Date | null
    expiresAt: Date | null
    name: string | null
    status: string | null
    format: string | null
    url: string | null
    log: string | null
  }

  export type BatchExportMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
    finishedAt: Date | null
    expiresAt: Date | null
    name: string | null
    status: string | null
    format: string | null
    url: string | null
    log: string | null
  }

  export type BatchExportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    userId: number
    finishedAt: number
    expiresAt: number
    name: number
    status: number
    query: number
    format: number
    url: number
    log: number
    _all: number
  }


  export type BatchExportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    finishedAt?: true
    expiresAt?: true
    name?: true
    status?: true
    format?: true
    url?: true
    log?: true
  }

  export type BatchExportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    finishedAt?: true
    expiresAt?: true
    name?: true
    status?: true
    format?: true
    url?: true
    log?: true
  }

  export type BatchExportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    finishedAt?: true
    expiresAt?: true
    name?: true
    status?: true
    query?: true
    format?: true
    url?: true
    log?: true
    _all?: true
  }

  export type BatchExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchExport to aggregate.
     */
    where?: BatchExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchExports to fetch.
     */
    orderBy?: BatchExportOrderByWithRelationInput | BatchExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchExports
    **/
    _count?: true | BatchExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchExportMaxAggregateInputType
  }

  export type GetBatchExportAggregateType<T extends BatchExportAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchExport[P]>
      : GetScalarType<T[P], AggregateBatchExport[P]>
  }




  export type BatchExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchExportWhereInput
    orderBy?: BatchExportOrderByWithAggregationInput | BatchExportOrderByWithAggregationInput[]
    by: BatchExportScalarFieldEnum[] | BatchExportScalarFieldEnum
    having?: BatchExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchExportCountAggregateInputType | true
    _min?: BatchExportMinAggregateInputType
    _max?: BatchExportMaxAggregateInputType
  }

  export type BatchExportGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    userId: string
    finishedAt: Date | null
    expiresAt: Date | null
    name: string
    status: string
    query: JsonValue
    format: string
    url: string | null
    log: string | null
    _count: BatchExportCountAggregateOutputType | null
    _min: BatchExportMinAggregateOutputType | null
    _max: BatchExportMaxAggregateOutputType | null
  }

  type GetBatchExportGroupByPayload<T extends BatchExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchExportGroupByOutputType[P]>
            : GetScalarType<T[P], BatchExportGroupByOutputType[P]>
        }
      >
    >


  export type BatchExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    finishedAt?: boolean
    expiresAt?: boolean
    name?: boolean
    status?: boolean
    query?: boolean
    format?: boolean
    url?: boolean
    log?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchExport"]>

  export type BatchExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    finishedAt?: boolean
    expiresAt?: boolean
    name?: boolean
    status?: boolean
    query?: boolean
    format?: boolean
    url?: boolean
    log?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchExport"]>

  export type BatchExportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    finishedAt?: boolean
    expiresAt?: boolean
    name?: boolean
    status?: boolean
    query?: boolean
    format?: boolean
    url?: boolean
    log?: boolean
  }

  export type BatchExportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type BatchExportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BatchExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchExport"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      userId: string
      finishedAt: Date | null
      expiresAt: Date | null
      name: string
      status: string
      query: Prisma.JsonValue
      format: string
      url: string | null
      log: string | null
    }, ExtArgs["result"]["batchExport"]>
    composites: {}
  }

  type BatchExportGetPayload<S extends boolean | null | undefined | BatchExportDefaultArgs> = $Result.GetResult<Prisma.$BatchExportPayload, S>

  type BatchExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BatchExportFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: BatchExportCountAggregateInputType | true
    }

  export interface BatchExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchExport'], meta: { name: 'BatchExport' } }
    /**
     * Find zero or one BatchExport that matches the filter.
     * @param {BatchExportFindUniqueArgs} args - Arguments to find a BatchExport
     * @example
     * // Get one BatchExport
     * const batchExport = await prisma.batchExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchExportFindUniqueArgs>(args: SelectSubset<T, BatchExportFindUniqueArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BatchExport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BatchExportFindUniqueOrThrowArgs} args - Arguments to find a BatchExport
     * @example
     * // Get one BatchExport
     * const batchExport = await prisma.batchExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchExportFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BatchExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportFindFirstArgs} args - Arguments to find a BatchExport
     * @example
     * // Get one BatchExport
     * const batchExport = await prisma.batchExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchExportFindFirstArgs>(args?: SelectSubset<T, BatchExportFindFirstArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BatchExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportFindFirstOrThrowArgs} args - Arguments to find a BatchExport
     * @example
     * // Get one BatchExport
     * const batchExport = await prisma.batchExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchExportFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BatchExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchExports
     * const batchExports = await prisma.batchExport.findMany()
     * 
     * // Get first 10 BatchExports
     * const batchExports = await prisma.batchExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchExportWithIdOnly = await prisma.batchExport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchExportFindManyArgs>(args?: SelectSubset<T, BatchExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BatchExport.
     * @param {BatchExportCreateArgs} args - Arguments to create a BatchExport.
     * @example
     * // Create one BatchExport
     * const BatchExport = await prisma.batchExport.create({
     *   data: {
     *     // ... data to create a BatchExport
     *   }
     * })
     * 
     */
    create<T extends BatchExportCreateArgs>(args: SelectSubset<T, BatchExportCreateArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BatchExports.
     * @param {BatchExportCreateManyArgs} args - Arguments to create many BatchExports.
     * @example
     * // Create many BatchExports
     * const batchExport = await prisma.batchExport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchExportCreateManyArgs>(args?: SelectSubset<T, BatchExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchExports and returns the data saved in the database.
     * @param {BatchExportCreateManyAndReturnArgs} args - Arguments to create many BatchExports.
     * @example
     * // Create many BatchExports
     * const batchExport = await prisma.batchExport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchExports and only return the `id`
     * const batchExportWithIdOnly = await prisma.batchExport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchExportCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BatchExport.
     * @param {BatchExportDeleteArgs} args - Arguments to delete one BatchExport.
     * @example
     * // Delete one BatchExport
     * const BatchExport = await prisma.batchExport.delete({
     *   where: {
     *     // ... filter to delete one BatchExport
     *   }
     * })
     * 
     */
    delete<T extends BatchExportDeleteArgs>(args: SelectSubset<T, BatchExportDeleteArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BatchExport.
     * @param {BatchExportUpdateArgs} args - Arguments to update one BatchExport.
     * @example
     * // Update one BatchExport
     * const batchExport = await prisma.batchExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchExportUpdateArgs>(args: SelectSubset<T, BatchExportUpdateArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BatchExports.
     * @param {BatchExportDeleteManyArgs} args - Arguments to filter BatchExports to delete.
     * @example
     * // Delete a few BatchExports
     * const { count } = await prisma.batchExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchExportDeleteManyArgs>(args?: SelectSubset<T, BatchExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchExports
     * const batchExport = await prisma.batchExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchExportUpdateManyArgs>(args: SelectSubset<T, BatchExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BatchExport.
     * @param {BatchExportUpsertArgs} args - Arguments to update or create a BatchExport.
     * @example
     * // Update or create a BatchExport
     * const batchExport = await prisma.batchExport.upsert({
     *   create: {
     *     // ... data to create a BatchExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchExport we want to update
     *   }
     * })
     */
    upsert<T extends BatchExportUpsertArgs>(args: SelectSubset<T, BatchExportUpsertArgs<ExtArgs>>): Prisma__BatchExportClient<$Result.GetResult<Prisma.$BatchExportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BatchExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportCountArgs} args - Arguments to filter BatchExports to count.
     * @example
     * // Count the number of BatchExports
     * const count = await prisma.batchExport.count({
     *   where: {
     *     // ... the filter for the BatchExports we want to count
     *   }
     * })
    **/
    count<T extends BatchExportCountArgs>(
      args?: Subset<T, BatchExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchExportAggregateArgs>(args: Subset<T, BatchExportAggregateArgs>): Prisma.PrismaPromise<GetBatchExportAggregateType<T>>

    /**
     * Group by BatchExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchExportGroupByArgs['orderBy'] }
        : { orderBy?: BatchExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchExport model
   */
  readonly fields: BatchExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchExport model
   */ 
  interface BatchExportFieldRefs {
    readonly id: FieldRef<"BatchExport", 'String'>
    readonly createdAt: FieldRef<"BatchExport", 'DateTime'>
    readonly updatedAt: FieldRef<"BatchExport", 'DateTime'>
    readonly projectId: FieldRef<"BatchExport", 'String'>
    readonly userId: FieldRef<"BatchExport", 'String'>
    readonly finishedAt: FieldRef<"BatchExport", 'DateTime'>
    readonly expiresAt: FieldRef<"BatchExport", 'DateTime'>
    readonly name: FieldRef<"BatchExport", 'String'>
    readonly status: FieldRef<"BatchExport", 'String'>
    readonly query: FieldRef<"BatchExport", 'Json'>
    readonly format: FieldRef<"BatchExport", 'String'>
    readonly url: FieldRef<"BatchExport", 'String'>
    readonly log: FieldRef<"BatchExport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BatchExport findUnique
   */
  export type BatchExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * Filter, which BatchExport to fetch.
     */
    where: BatchExportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport findUniqueOrThrow
   */
  export type BatchExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * Filter, which BatchExport to fetch.
     */
    where: BatchExportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport findFirst
   */
  export type BatchExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * Filter, which BatchExport to fetch.
     */
    where?: BatchExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchExports to fetch.
     */
    orderBy?: BatchExportOrderByWithRelationInput | BatchExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchExports.
     */
    cursor?: BatchExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchExports.
     */
    distinct?: BatchExportScalarFieldEnum | BatchExportScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport findFirstOrThrow
   */
  export type BatchExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * Filter, which BatchExport to fetch.
     */
    where?: BatchExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchExports to fetch.
     */
    orderBy?: BatchExportOrderByWithRelationInput | BatchExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchExports.
     */
    cursor?: BatchExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchExports.
     */
    distinct?: BatchExportScalarFieldEnum | BatchExportScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport findMany
   */
  export type BatchExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * Filter, which BatchExports to fetch.
     */
    where?: BatchExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchExports to fetch.
     */
    orderBy?: BatchExportOrderByWithRelationInput | BatchExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchExports.
     */
    cursor?: BatchExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchExports.
     */
    skip?: number
    distinct?: BatchExportScalarFieldEnum | BatchExportScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport create
   */
  export type BatchExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchExport.
     */
    data: XOR<BatchExportCreateInput, BatchExportUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport createMany
   */
  export type BatchExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchExports.
     */
    data: BatchExportCreateManyInput | BatchExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchExport createManyAndReturn
   */
  export type BatchExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BatchExports.
     */
    data: BatchExportCreateManyInput | BatchExportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchExport update
   */
  export type BatchExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchExport.
     */
    data: XOR<BatchExportUpdateInput, BatchExportUncheckedUpdateInput>
    /**
     * Choose, which BatchExport to update.
     */
    where: BatchExportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport updateMany
   */
  export type BatchExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchExports.
     */
    data: XOR<BatchExportUpdateManyMutationInput, BatchExportUncheckedUpdateManyInput>
    /**
     * Filter which BatchExports to update
     */
    where?: BatchExportWhereInput
  }

  /**
   * BatchExport upsert
   */
  export type BatchExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchExport to update in case it exists.
     */
    where: BatchExportWhereUniqueInput
    /**
     * In case the BatchExport found by the `where` argument doesn't exist, create a new BatchExport with this data.
     */
    create: XOR<BatchExportCreateInput, BatchExportUncheckedCreateInput>
    /**
     * In case the BatchExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchExportUpdateInput, BatchExportUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport delete
   */
  export type BatchExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
    /**
     * Filter which BatchExport to delete.
     */
    where: BatchExportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BatchExport deleteMany
   */
  export type BatchExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchExports to delete
     */
    where?: BatchExportWhereInput
  }

  /**
   * BatchExport without action
   */
  export type BatchExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchExport
     */
    select?: BatchExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchExportInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    uploadHttpStatus: number | null
    contentLength: number | null
  }

  export type MediaSumAggregateOutputType = {
    uploadHttpStatus: number | null
    contentLength: bigint | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    sha256Hash: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uploadedAt: Date | null
    uploadHttpStatus: number | null
    uploadHttpError: string | null
    bucketPath: string | null
    bucketName: string | null
    contentType: string | null
    contentLength: bigint | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    sha256Hash: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uploadedAt: Date | null
    uploadHttpStatus: number | null
    uploadHttpError: string | null
    bucketPath: string | null
    bucketName: string | null
    contentType: string | null
    contentLength: bigint | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    sha256Hash: number
    projectId: number
    createdAt: number
    updatedAt: number
    uploadedAt: number
    uploadHttpStatus: number
    uploadHttpError: number
    bucketPath: number
    bucketName: number
    contentType: number
    contentLength: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    uploadHttpStatus?: true
    contentLength?: true
  }

  export type MediaSumAggregateInputType = {
    uploadHttpStatus?: true
    contentLength?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    sha256Hash?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    uploadedAt?: true
    uploadHttpStatus?: true
    uploadHttpError?: true
    bucketPath?: true
    bucketName?: true
    contentType?: true
    contentLength?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    sha256Hash?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    uploadedAt?: true
    uploadHttpStatus?: true
    uploadHttpError?: true
    bucketPath?: true
    bucketName?: true
    contentType?: true
    contentLength?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    sha256Hash?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    uploadedAt?: true
    uploadHttpStatus?: true
    uploadHttpError?: true
    bucketPath?: true
    bucketName?: true
    contentType?: true
    contentLength?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    sha256Hash: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    uploadedAt: Date | null
    uploadHttpStatus: number | null
    uploadHttpError: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sha256Hash?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedAt?: boolean
    uploadHttpStatus?: boolean
    uploadHttpError?: boolean
    bucketPath?: boolean
    bucketName?: boolean
    contentType?: boolean
    contentLength?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    TraceMedia?: boolean | Media$TraceMediaArgs<ExtArgs>
    ObservationMedia?: boolean | Media$ObservationMediaArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sha256Hash?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedAt?: boolean
    uploadHttpStatus?: boolean
    uploadHttpError?: boolean
    bucketPath?: boolean
    bucketName?: boolean
    contentType?: boolean
    contentLength?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    sha256Hash?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedAt?: boolean
    uploadHttpStatus?: boolean
    uploadHttpError?: boolean
    bucketPath?: boolean
    bucketName?: boolean
    contentType?: boolean
    contentLength?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    TraceMedia?: boolean | Media$TraceMediaArgs<ExtArgs>
    ObservationMedia?: boolean | Media$ObservationMediaArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      TraceMedia: Prisma.$TraceMediaPayload<ExtArgs>[]
      ObservationMedia: Prisma.$ObservationMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sha256Hash: string
      projectId: string
      createdAt: Date
      updatedAt: Date
      uploadedAt: Date | null
      uploadHttpStatus: number | null
      uploadHttpError: string | null
      bucketPath: string
      bucketName: string
      contentType: string
      contentLength: bigint
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    TraceMedia<T extends Media$TraceMediaArgs<ExtArgs> = {}>(args?: Subset<T, Media$TraceMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findMany"> | Null>
    ObservationMedia<T extends Media$ObservationMediaArgs<ExtArgs> = {}>(args?: Subset<T, Media$ObservationMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly sha256Hash: FieldRef<"Media", 'String'>
    readonly projectId: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
    readonly uploadedAt: FieldRef<"Media", 'DateTime'>
    readonly uploadHttpStatus: FieldRef<"Media", 'Int'>
    readonly uploadHttpError: FieldRef<"Media", 'String'>
    readonly bucketPath: FieldRef<"Media", 'String'>
    readonly bucketName: FieldRef<"Media", 'String'>
    readonly contentType: FieldRef<"Media", 'String'>
    readonly contentLength: FieldRef<"Media", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media.TraceMedia
   */
  export type Media$TraceMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    where?: TraceMediaWhereInput
    orderBy?: TraceMediaOrderByWithRelationInput | TraceMediaOrderByWithRelationInput[]
    cursor?: TraceMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraceMediaScalarFieldEnum | TraceMediaScalarFieldEnum[]
  }

  /**
   * Media.ObservationMedia
   */
  export type Media$ObservationMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    where?: ObservationMediaWhereInput
    orderBy?: ObservationMediaOrderByWithRelationInput | ObservationMediaOrderByWithRelationInput[]
    cursor?: ObservationMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationMediaScalarFieldEnum | ObservationMediaScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model TraceMedia
   */

  export type AggregateTraceMedia = {
    _count: TraceMediaCountAggregateOutputType | null
    _min: TraceMediaMinAggregateOutputType | null
    _max: TraceMediaMaxAggregateOutputType | null
  }

  export type TraceMediaMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaId: string | null
    traceId: string | null
    field: string | null
  }

  export type TraceMediaMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaId: string | null
    traceId: string | null
    field: string | null
  }

  export type TraceMediaCountAggregateOutputType = {
    id: number
    projectId: number
    createdAt: number
    updatedAt: number
    mediaId: number
    traceId: number
    field: number
    _all: number
  }


  export type TraceMediaMinAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    mediaId?: true
    traceId?: true
    field?: true
  }

  export type TraceMediaMaxAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    mediaId?: true
    traceId?: true
    field?: true
  }

  export type TraceMediaCountAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    mediaId?: true
    traceId?: true
    field?: true
    _all?: true
  }

  export type TraceMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceMedia to aggregate.
     */
    where?: TraceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceMedias to fetch.
     */
    orderBy?: TraceMediaOrderByWithRelationInput | TraceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraceMedias
    **/
    _count?: true | TraceMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceMediaMaxAggregateInputType
  }

  export type GetTraceMediaAggregateType<T extends TraceMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateTraceMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraceMedia[P]>
      : GetScalarType<T[P], AggregateTraceMedia[P]>
  }




  export type TraceMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceMediaWhereInput
    orderBy?: TraceMediaOrderByWithAggregationInput | TraceMediaOrderByWithAggregationInput[]
    by: TraceMediaScalarFieldEnum[] | TraceMediaScalarFieldEnum
    having?: TraceMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceMediaCountAggregateInputType | true
    _min?: TraceMediaMinAggregateInputType
    _max?: TraceMediaMaxAggregateInputType
  }

  export type TraceMediaGroupByOutputType = {
    id: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    mediaId: string
    traceId: string
    field: string
    _count: TraceMediaCountAggregateOutputType | null
    _min: TraceMediaMinAggregateOutputType | null
    _max: TraceMediaMaxAggregateOutputType | null
  }

  type GetTraceMediaGroupByPayload<T extends TraceMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraceMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceMediaGroupByOutputType[P]>
            : GetScalarType<T[P], TraceMediaGroupByOutputType[P]>
        }
      >
    >


  export type TraceMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaId?: boolean
    traceId?: boolean
    field?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traceMedia"]>

  export type TraceMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaId?: boolean
    traceId?: boolean
    field?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traceMedia"]>

  export type TraceMediaSelectScalar = {
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaId?: boolean
    traceId?: boolean
    field?: boolean
  }

  export type TraceMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type TraceMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $TraceMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraceMedia"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      createdAt: Date
      updatedAt: Date
      mediaId: string
      traceId: string
      field: string
    }, ExtArgs["result"]["traceMedia"]>
    composites: {}
  }

  type TraceMediaGetPayload<S extends boolean | null | undefined | TraceMediaDefaultArgs> = $Result.GetResult<Prisma.$TraceMediaPayload, S>

  type TraceMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TraceMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TraceMediaCountAggregateInputType | true
    }

  export interface TraceMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraceMedia'], meta: { name: 'TraceMedia' } }
    /**
     * Find zero or one TraceMedia that matches the filter.
     * @param {TraceMediaFindUniqueArgs} args - Arguments to find a TraceMedia
     * @example
     * // Get one TraceMedia
     * const traceMedia = await prisma.traceMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraceMediaFindUniqueArgs>(args: SelectSubset<T, TraceMediaFindUniqueArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TraceMedia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TraceMediaFindUniqueOrThrowArgs} args - Arguments to find a TraceMedia
     * @example
     * // Get one TraceMedia
     * const traceMedia = await prisma.traceMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraceMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, TraceMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TraceMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaFindFirstArgs} args - Arguments to find a TraceMedia
     * @example
     * // Get one TraceMedia
     * const traceMedia = await prisma.traceMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraceMediaFindFirstArgs>(args?: SelectSubset<T, TraceMediaFindFirstArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TraceMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaFindFirstOrThrowArgs} args - Arguments to find a TraceMedia
     * @example
     * // Get one TraceMedia
     * const traceMedia = await prisma.traceMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraceMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, TraceMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TraceMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraceMedias
     * const traceMedias = await prisma.traceMedia.findMany()
     * 
     * // Get first 10 TraceMedias
     * const traceMedias = await prisma.traceMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traceMediaWithIdOnly = await prisma.traceMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraceMediaFindManyArgs>(args?: SelectSubset<T, TraceMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TraceMedia.
     * @param {TraceMediaCreateArgs} args - Arguments to create a TraceMedia.
     * @example
     * // Create one TraceMedia
     * const TraceMedia = await prisma.traceMedia.create({
     *   data: {
     *     // ... data to create a TraceMedia
     *   }
     * })
     * 
     */
    create<T extends TraceMediaCreateArgs>(args: SelectSubset<T, TraceMediaCreateArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TraceMedias.
     * @param {TraceMediaCreateManyArgs} args - Arguments to create many TraceMedias.
     * @example
     * // Create many TraceMedias
     * const traceMedia = await prisma.traceMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraceMediaCreateManyArgs>(args?: SelectSubset<T, TraceMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TraceMedias and returns the data saved in the database.
     * @param {TraceMediaCreateManyAndReturnArgs} args - Arguments to create many TraceMedias.
     * @example
     * // Create many TraceMedias
     * const traceMedia = await prisma.traceMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TraceMedias and only return the `id`
     * const traceMediaWithIdOnly = await prisma.traceMedia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraceMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, TraceMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TraceMedia.
     * @param {TraceMediaDeleteArgs} args - Arguments to delete one TraceMedia.
     * @example
     * // Delete one TraceMedia
     * const TraceMedia = await prisma.traceMedia.delete({
     *   where: {
     *     // ... filter to delete one TraceMedia
     *   }
     * })
     * 
     */
    delete<T extends TraceMediaDeleteArgs>(args: SelectSubset<T, TraceMediaDeleteArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TraceMedia.
     * @param {TraceMediaUpdateArgs} args - Arguments to update one TraceMedia.
     * @example
     * // Update one TraceMedia
     * const traceMedia = await prisma.traceMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraceMediaUpdateArgs>(args: SelectSubset<T, TraceMediaUpdateArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TraceMedias.
     * @param {TraceMediaDeleteManyArgs} args - Arguments to filter TraceMedias to delete.
     * @example
     * // Delete a few TraceMedias
     * const { count } = await prisma.traceMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraceMediaDeleteManyArgs>(args?: SelectSubset<T, TraceMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraceMedias
     * const traceMedia = await prisma.traceMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraceMediaUpdateManyArgs>(args: SelectSubset<T, TraceMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TraceMedia.
     * @param {TraceMediaUpsertArgs} args - Arguments to update or create a TraceMedia.
     * @example
     * // Update or create a TraceMedia
     * const traceMedia = await prisma.traceMedia.upsert({
     *   create: {
     *     // ... data to create a TraceMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraceMedia we want to update
     *   }
     * })
     */
    upsert<T extends TraceMediaUpsertArgs>(args: SelectSubset<T, TraceMediaUpsertArgs<ExtArgs>>): Prisma__TraceMediaClient<$Result.GetResult<Prisma.$TraceMediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TraceMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaCountArgs} args - Arguments to filter TraceMedias to count.
     * @example
     * // Count the number of TraceMedias
     * const count = await prisma.traceMedia.count({
     *   where: {
     *     // ... the filter for the TraceMedias we want to count
     *   }
     * })
    **/
    count<T extends TraceMediaCountArgs>(
      args?: Subset<T, TraceMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraceMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceMediaAggregateArgs>(args: Subset<T, TraceMediaAggregateArgs>): Prisma.PrismaPromise<GetTraceMediaAggregateType<T>>

    /**
     * Group by TraceMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceMediaGroupByArgs['orderBy'] }
        : { orderBy?: TraceMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraceMedia model
   */
  readonly fields: TraceMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraceMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraceMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraceMedia model
   */ 
  interface TraceMediaFieldRefs {
    readonly id: FieldRef<"TraceMedia", 'String'>
    readonly projectId: FieldRef<"TraceMedia", 'String'>
    readonly createdAt: FieldRef<"TraceMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"TraceMedia", 'DateTime'>
    readonly mediaId: FieldRef<"TraceMedia", 'String'>
    readonly traceId: FieldRef<"TraceMedia", 'String'>
    readonly field: FieldRef<"TraceMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TraceMedia findUnique
   */
  export type TraceMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * Filter, which TraceMedia to fetch.
     */
    where: TraceMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia findUniqueOrThrow
   */
  export type TraceMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * Filter, which TraceMedia to fetch.
     */
    where: TraceMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia findFirst
   */
  export type TraceMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * Filter, which TraceMedia to fetch.
     */
    where?: TraceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceMedias to fetch.
     */
    orderBy?: TraceMediaOrderByWithRelationInput | TraceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceMedias.
     */
    cursor?: TraceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceMedias.
     */
    distinct?: TraceMediaScalarFieldEnum | TraceMediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia findFirstOrThrow
   */
  export type TraceMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * Filter, which TraceMedia to fetch.
     */
    where?: TraceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceMedias to fetch.
     */
    orderBy?: TraceMediaOrderByWithRelationInput | TraceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceMedias.
     */
    cursor?: TraceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceMedias.
     */
    distinct?: TraceMediaScalarFieldEnum | TraceMediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia findMany
   */
  export type TraceMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * Filter, which TraceMedias to fetch.
     */
    where?: TraceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceMedias to fetch.
     */
    orderBy?: TraceMediaOrderByWithRelationInput | TraceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraceMedias.
     */
    cursor?: TraceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceMedias.
     */
    skip?: number
    distinct?: TraceMediaScalarFieldEnum | TraceMediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia create
   */
  export type TraceMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a TraceMedia.
     */
    data: XOR<TraceMediaCreateInput, TraceMediaUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia createMany
   */
  export type TraceMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraceMedias.
     */
    data: TraceMediaCreateManyInput | TraceMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraceMedia createManyAndReturn
   */
  export type TraceMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TraceMedias.
     */
    data: TraceMediaCreateManyInput | TraceMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TraceMedia update
   */
  export type TraceMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a TraceMedia.
     */
    data: XOR<TraceMediaUpdateInput, TraceMediaUncheckedUpdateInput>
    /**
     * Choose, which TraceMedia to update.
     */
    where: TraceMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia updateMany
   */
  export type TraceMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraceMedias.
     */
    data: XOR<TraceMediaUpdateManyMutationInput, TraceMediaUncheckedUpdateManyInput>
    /**
     * Filter which TraceMedias to update
     */
    where?: TraceMediaWhereInput
  }

  /**
   * TraceMedia upsert
   */
  export type TraceMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the TraceMedia to update in case it exists.
     */
    where: TraceMediaWhereUniqueInput
    /**
     * In case the TraceMedia found by the `where` argument doesn't exist, create a new TraceMedia with this data.
     */
    create: XOR<TraceMediaCreateInput, TraceMediaUncheckedCreateInput>
    /**
     * In case the TraceMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraceMediaUpdateInput, TraceMediaUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia delete
   */
  export type TraceMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
    /**
     * Filter which TraceMedia to delete.
     */
    where: TraceMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceMedia deleteMany
   */
  export type TraceMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceMedias to delete
     */
    where?: TraceMediaWhereInput
  }

  /**
   * TraceMedia without action
   */
  export type TraceMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceMedia
     */
    select?: TraceMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraceMediaInclude<ExtArgs> | null
  }


  /**
   * Model ObservationMedia
   */

  export type AggregateObservationMedia = {
    _count: ObservationMediaCountAggregateOutputType | null
    _min: ObservationMediaMinAggregateOutputType | null
    _max: ObservationMediaMaxAggregateOutputType | null
  }

  export type ObservationMediaMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaId: string | null
    traceId: string | null
    observationId: string | null
    field: string | null
  }

  export type ObservationMediaMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaId: string | null
    traceId: string | null
    observationId: string | null
    field: string | null
  }

  export type ObservationMediaCountAggregateOutputType = {
    id: number
    projectId: number
    createdAt: number
    updatedAt: number
    mediaId: number
    traceId: number
    observationId: number
    field: number
    _all: number
  }


  export type ObservationMediaMinAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    mediaId?: true
    traceId?: true
    observationId?: true
    field?: true
  }

  export type ObservationMediaMaxAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    mediaId?: true
    traceId?: true
    observationId?: true
    field?: true
  }

  export type ObservationMediaCountAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    mediaId?: true
    traceId?: true
    observationId?: true
    field?: true
    _all?: true
  }

  export type ObservationMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObservationMedia to aggregate.
     */
    where?: ObservationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationMedias to fetch.
     */
    orderBy?: ObservationMediaOrderByWithRelationInput | ObservationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObservationMedias
    **/
    _count?: true | ObservationMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationMediaMaxAggregateInputType
  }

  export type GetObservationMediaAggregateType<T extends ObservationMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateObservationMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservationMedia[P]>
      : GetScalarType<T[P], AggregateObservationMedia[P]>
  }




  export type ObservationMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationMediaWhereInput
    orderBy?: ObservationMediaOrderByWithAggregationInput | ObservationMediaOrderByWithAggregationInput[]
    by: ObservationMediaScalarFieldEnum[] | ObservationMediaScalarFieldEnum
    having?: ObservationMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationMediaCountAggregateInputType | true
    _min?: ObservationMediaMinAggregateInputType
    _max?: ObservationMediaMaxAggregateInputType
  }

  export type ObservationMediaGroupByOutputType = {
    id: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    mediaId: string
    traceId: string
    observationId: string
    field: string
    _count: ObservationMediaCountAggregateOutputType | null
    _min: ObservationMediaMinAggregateOutputType | null
    _max: ObservationMediaMaxAggregateOutputType | null
  }

  type GetObservationMediaGroupByPayload<T extends ObservationMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationMediaGroupByOutputType[P]>
        }
      >
    >


  export type ObservationMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaId?: boolean
    traceId?: boolean
    observationId?: boolean
    field?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observationMedia"]>

  export type ObservationMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaId?: boolean
    traceId?: boolean
    observationId?: boolean
    field?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observationMedia"]>

  export type ObservationMediaSelectScalar = {
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaId?: boolean
    traceId?: boolean
    observationId?: boolean
    field?: boolean
  }

  export type ObservationMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ObservationMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $ObservationMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObservationMedia"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      createdAt: Date
      updatedAt: Date
      mediaId: string
      traceId: string
      observationId: string
      field: string
    }, ExtArgs["result"]["observationMedia"]>
    composites: {}
  }

  type ObservationMediaGetPayload<S extends boolean | null | undefined | ObservationMediaDefaultArgs> = $Result.GetResult<Prisma.$ObservationMediaPayload, S>

  type ObservationMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObservationMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ObservationMediaCountAggregateInputType | true
    }

  export interface ObservationMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObservationMedia'], meta: { name: 'ObservationMedia' } }
    /**
     * Find zero or one ObservationMedia that matches the filter.
     * @param {ObservationMediaFindUniqueArgs} args - Arguments to find a ObservationMedia
     * @example
     * // Get one ObservationMedia
     * const observationMedia = await prisma.observationMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationMediaFindUniqueArgs>(args: SelectSubset<T, ObservationMediaFindUniqueArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ObservationMedia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObservationMediaFindUniqueOrThrowArgs} args - Arguments to find a ObservationMedia
     * @example
     * // Get one ObservationMedia
     * const observationMedia = await prisma.observationMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ObservationMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaFindFirstArgs} args - Arguments to find a ObservationMedia
     * @example
     * // Get one ObservationMedia
     * const observationMedia = await prisma.observationMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationMediaFindFirstArgs>(args?: SelectSubset<T, ObservationMediaFindFirstArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ObservationMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaFindFirstOrThrowArgs} args - Arguments to find a ObservationMedia
     * @example
     * // Get one ObservationMedia
     * const observationMedia = await prisma.observationMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ObservationMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObservationMedias
     * const observationMedias = await prisma.observationMedia.findMany()
     * 
     * // Get first 10 ObservationMedias
     * const observationMedias = await prisma.observationMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationMediaWithIdOnly = await prisma.observationMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationMediaFindManyArgs>(args?: SelectSubset<T, ObservationMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ObservationMedia.
     * @param {ObservationMediaCreateArgs} args - Arguments to create a ObservationMedia.
     * @example
     * // Create one ObservationMedia
     * const ObservationMedia = await prisma.observationMedia.create({
     *   data: {
     *     // ... data to create a ObservationMedia
     *   }
     * })
     * 
     */
    create<T extends ObservationMediaCreateArgs>(args: SelectSubset<T, ObservationMediaCreateArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ObservationMedias.
     * @param {ObservationMediaCreateManyArgs} args - Arguments to create many ObservationMedias.
     * @example
     * // Create many ObservationMedias
     * const observationMedia = await prisma.observationMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationMediaCreateManyArgs>(args?: SelectSubset<T, ObservationMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObservationMedias and returns the data saved in the database.
     * @param {ObservationMediaCreateManyAndReturnArgs} args - Arguments to create many ObservationMedias.
     * @example
     * // Create many ObservationMedias
     * const observationMedia = await prisma.observationMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObservationMedias and only return the `id`
     * const observationMediaWithIdOnly = await prisma.observationMedia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObservationMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ObservationMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ObservationMedia.
     * @param {ObservationMediaDeleteArgs} args - Arguments to delete one ObservationMedia.
     * @example
     * // Delete one ObservationMedia
     * const ObservationMedia = await prisma.observationMedia.delete({
     *   where: {
     *     // ... filter to delete one ObservationMedia
     *   }
     * })
     * 
     */
    delete<T extends ObservationMediaDeleteArgs>(args: SelectSubset<T, ObservationMediaDeleteArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ObservationMedia.
     * @param {ObservationMediaUpdateArgs} args - Arguments to update one ObservationMedia.
     * @example
     * // Update one ObservationMedia
     * const observationMedia = await prisma.observationMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationMediaUpdateArgs>(args: SelectSubset<T, ObservationMediaUpdateArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ObservationMedias.
     * @param {ObservationMediaDeleteManyArgs} args - Arguments to filter ObservationMedias to delete.
     * @example
     * // Delete a few ObservationMedias
     * const { count } = await prisma.observationMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationMediaDeleteManyArgs>(args?: SelectSubset<T, ObservationMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObservationMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObservationMedias
     * const observationMedia = await prisma.observationMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationMediaUpdateManyArgs>(args: SelectSubset<T, ObservationMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObservationMedia.
     * @param {ObservationMediaUpsertArgs} args - Arguments to update or create a ObservationMedia.
     * @example
     * // Update or create a ObservationMedia
     * const observationMedia = await prisma.observationMedia.upsert({
     *   create: {
     *     // ... data to create a ObservationMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObservationMedia we want to update
     *   }
     * })
     */
    upsert<T extends ObservationMediaUpsertArgs>(args: SelectSubset<T, ObservationMediaUpsertArgs<ExtArgs>>): Prisma__ObservationMediaClient<$Result.GetResult<Prisma.$ObservationMediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ObservationMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaCountArgs} args - Arguments to filter ObservationMedias to count.
     * @example
     * // Count the number of ObservationMedias
     * const count = await prisma.observationMedia.count({
     *   where: {
     *     // ... the filter for the ObservationMedias we want to count
     *   }
     * })
    **/
    count<T extends ObservationMediaCountArgs>(
      args?: Subset<T, ObservationMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObservationMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationMediaAggregateArgs>(args: Subset<T, ObservationMediaAggregateArgs>): Prisma.PrismaPromise<GetObservationMediaAggregateType<T>>

    /**
     * Group by ObservationMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationMediaGroupByArgs['orderBy'] }
        : { orderBy?: ObservationMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObservationMedia model
   */
  readonly fields: ObservationMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObservationMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ObservationMedia model
   */ 
  interface ObservationMediaFieldRefs {
    readonly id: FieldRef<"ObservationMedia", 'String'>
    readonly projectId: FieldRef<"ObservationMedia", 'String'>
    readonly createdAt: FieldRef<"ObservationMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"ObservationMedia", 'DateTime'>
    readonly mediaId: FieldRef<"ObservationMedia", 'String'>
    readonly traceId: FieldRef<"ObservationMedia", 'String'>
    readonly observationId: FieldRef<"ObservationMedia", 'String'>
    readonly field: FieldRef<"ObservationMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ObservationMedia findUnique
   */
  export type ObservationMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * Filter, which ObservationMedia to fetch.
     */
    where: ObservationMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia findUniqueOrThrow
   */
  export type ObservationMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * Filter, which ObservationMedia to fetch.
     */
    where: ObservationMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia findFirst
   */
  export type ObservationMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * Filter, which ObservationMedia to fetch.
     */
    where?: ObservationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationMedias to fetch.
     */
    orderBy?: ObservationMediaOrderByWithRelationInput | ObservationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObservationMedias.
     */
    cursor?: ObservationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObservationMedias.
     */
    distinct?: ObservationMediaScalarFieldEnum | ObservationMediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia findFirstOrThrow
   */
  export type ObservationMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * Filter, which ObservationMedia to fetch.
     */
    where?: ObservationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationMedias to fetch.
     */
    orderBy?: ObservationMediaOrderByWithRelationInput | ObservationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObservationMedias.
     */
    cursor?: ObservationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObservationMedias.
     */
    distinct?: ObservationMediaScalarFieldEnum | ObservationMediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia findMany
   */
  export type ObservationMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * Filter, which ObservationMedias to fetch.
     */
    where?: ObservationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationMedias to fetch.
     */
    orderBy?: ObservationMediaOrderByWithRelationInput | ObservationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObservationMedias.
     */
    cursor?: ObservationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationMedias.
     */
    skip?: number
    distinct?: ObservationMediaScalarFieldEnum | ObservationMediaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia create
   */
  export type ObservationMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ObservationMedia.
     */
    data: XOR<ObservationMediaCreateInput, ObservationMediaUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia createMany
   */
  export type ObservationMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObservationMedias.
     */
    data: ObservationMediaCreateManyInput | ObservationMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObservationMedia createManyAndReturn
   */
  export type ObservationMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ObservationMedias.
     */
    data: ObservationMediaCreateManyInput | ObservationMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ObservationMedia update
   */
  export type ObservationMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ObservationMedia.
     */
    data: XOR<ObservationMediaUpdateInput, ObservationMediaUncheckedUpdateInput>
    /**
     * Choose, which ObservationMedia to update.
     */
    where: ObservationMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia updateMany
   */
  export type ObservationMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObservationMedias.
     */
    data: XOR<ObservationMediaUpdateManyMutationInput, ObservationMediaUncheckedUpdateManyInput>
    /**
     * Filter which ObservationMedias to update
     */
    where?: ObservationMediaWhereInput
  }

  /**
   * ObservationMedia upsert
   */
  export type ObservationMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ObservationMedia to update in case it exists.
     */
    where: ObservationMediaWhereUniqueInput
    /**
     * In case the ObservationMedia found by the `where` argument doesn't exist, create a new ObservationMedia with this data.
     */
    create: XOR<ObservationMediaCreateInput, ObservationMediaUncheckedCreateInput>
    /**
     * In case the ObservationMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationMediaUpdateInput, ObservationMediaUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia delete
   */
  export type ObservationMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
    /**
     * Filter which ObservationMedia to delete.
     */
    where: ObservationMediaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationMedia deleteMany
   */
  export type ObservationMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObservationMedias to delete
     */
    where?: ObservationMediaWhereInput
  }

  /**
   * ObservationMedia without action
   */
  export type ObservationMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationMedia
     */
    select?: ObservationMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationMediaInclude<ExtArgs> | null
  }


  /**
   * Model TraceView
   */

  export type AggregateTraceView = {
    _count: TraceViewCountAggregateOutputType | null
    _avg: TraceViewAvgAggregateOutputType | null
    _sum: TraceViewSumAggregateOutputType | null
    _min: TraceViewMinAggregateOutputType | null
    _max: TraceViewMaxAggregateOutputType | null
  }

  export type TraceViewAvgAggregateOutputType = {
    duration: number | null
  }

  export type TraceViewSumAggregateOutputType = {
    duration: number | null
  }

  export type TraceViewMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    timestamp: Date | null
    name: string | null
    userId: string | null
    release: string | null
    version: string | null
    projectId: string | null
    public: boolean | null
    bookmarked: boolean | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    duration: number | null
  }

  export type TraceViewMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    timestamp: Date | null
    name: string | null
    userId: string | null
    release: string | null
    version: string | null
    projectId: string | null
    public: boolean | null
    bookmarked: boolean | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    duration: number | null
  }

  export type TraceViewCountAggregateOutputType = {
    id: number
    externalId: number
    timestamp: number
    name: number
    userId: number
    metadata: number
    release: number
    version: number
    projectId: number
    public: number
    bookmarked: number
    tags: number
    input: number
    output: number
    sessionId: number
    createdAt: number
    updatedAt: number
    duration: number
    _all: number
  }


  export type TraceViewAvgAggregateInputType = {
    duration?: true
  }

  export type TraceViewSumAggregateInputType = {
    duration?: true
  }

  export type TraceViewMinAggregateInputType = {
    id?: true
    externalId?: true
    timestamp?: true
    name?: true
    userId?: true
    release?: true
    version?: true
    projectId?: true
    public?: true
    bookmarked?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
  }

  export type TraceViewMaxAggregateInputType = {
    id?: true
    externalId?: true
    timestamp?: true
    name?: true
    userId?: true
    release?: true
    version?: true
    projectId?: true
    public?: true
    bookmarked?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
  }

  export type TraceViewCountAggregateInputType = {
    id?: true
    externalId?: true
    timestamp?: true
    name?: true
    userId?: true
    metadata?: true
    release?: true
    version?: true
    projectId?: true
    public?: true
    bookmarked?: true
    tags?: true
    input?: true
    output?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
    _all?: true
  }

  export type TraceViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceView to aggregate.
     */
    where?: TraceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceViews to fetch.
     */
    orderBy?: TraceViewOrderByWithRelationInput | TraceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraceViews
    **/
    _count?: true | TraceViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraceViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraceViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceViewMaxAggregateInputType
  }

  export type GetTraceViewAggregateType<T extends TraceViewAggregateArgs> = {
        [P in keyof T & keyof AggregateTraceView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraceView[P]>
      : GetScalarType<T[P], AggregateTraceView[P]>
  }




  export type TraceViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceViewWhereInput
    orderBy?: TraceViewOrderByWithAggregationInput | TraceViewOrderByWithAggregationInput[]
    by: TraceViewScalarFieldEnum[] | TraceViewScalarFieldEnum
    having?: TraceViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceViewCountAggregateInputType | true
    _avg?: TraceViewAvgAggregateInputType
    _sum?: TraceViewSumAggregateInputType
    _min?: TraceViewMinAggregateInputType
    _max?: TraceViewMaxAggregateInputType
  }

  export type TraceViewGroupByOutputType = {
    id: string
    externalId: string | null
    timestamp: Date
    name: string | null
    userId: string | null
    metadata: JsonValue | null
    release: string | null
    version: string | null
    projectId: string
    public: boolean
    bookmarked: boolean
    tags: string[]
    input: JsonValue | null
    output: JsonValue | null
    sessionId: string | null
    createdAt: Date
    updatedAt: Date
    duration: number | null
    _count: TraceViewCountAggregateOutputType | null
    _avg: TraceViewAvgAggregateOutputType | null
    _sum: TraceViewSumAggregateOutputType | null
    _min: TraceViewMinAggregateOutputType | null
    _max: TraceViewMaxAggregateOutputType | null
  }

  type GetTraceViewGroupByPayload<T extends TraceViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraceViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceViewGroupByOutputType[P]>
            : GetScalarType<T[P], TraceViewGroupByOutputType[P]>
        }
      >
    >


  export type TraceViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    timestamp?: boolean
    name?: boolean
    userId?: boolean
    metadata?: boolean
    release?: boolean
    version?: boolean
    projectId?: boolean
    public?: boolean
    bookmarked?: boolean
    tags?: boolean
    input?: boolean
    output?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    duration?: boolean
  }, ExtArgs["result"]["traceView"]>

  export type TraceViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    timestamp?: boolean
    name?: boolean
    userId?: boolean
    metadata?: boolean
    release?: boolean
    version?: boolean
    projectId?: boolean
    public?: boolean
    bookmarked?: boolean
    tags?: boolean
    input?: boolean
    output?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    duration?: boolean
  }, ExtArgs["result"]["traceView"]>

  export type TraceViewSelectScalar = {
    id?: boolean
    externalId?: boolean
    timestamp?: boolean
    name?: boolean
    userId?: boolean
    metadata?: boolean
    release?: boolean
    version?: boolean
    projectId?: boolean
    public?: boolean
    bookmarked?: boolean
    tags?: boolean
    input?: boolean
    output?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    duration?: boolean
  }


  export type $TraceViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraceView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      timestamp: Date
      name: string | null
      userId: string | null
      metadata: Prisma.JsonValue | null
      release: string | null
      version: string | null
      projectId: string
      public: boolean
      bookmarked: boolean
      tags: string[]
      input: Prisma.JsonValue | null
      output: Prisma.JsonValue | null
      sessionId: string | null
      createdAt: Date
      updatedAt: Date
      duration: number | null
    }, ExtArgs["result"]["traceView"]>
    composites: {}
  }

  type TraceViewGetPayload<S extends boolean | null | undefined | TraceViewDefaultArgs> = $Result.GetResult<Prisma.$TraceViewPayload, S>

  type TraceViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TraceViewFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TraceViewCountAggregateInputType | true
    }

  export interface TraceViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraceView'], meta: { name: 'TraceView' } }
    /**
     * Find zero or one TraceView that matches the filter.
     * @param {TraceViewFindUniqueArgs} args - Arguments to find a TraceView
     * @example
     * // Get one TraceView
     * const traceView = await prisma.traceView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraceViewFindUniqueArgs>(args: SelectSubset<T, TraceViewFindUniqueArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TraceView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TraceViewFindUniqueOrThrowArgs} args - Arguments to find a TraceView
     * @example
     * // Get one TraceView
     * const traceView = await prisma.traceView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraceViewFindUniqueOrThrowArgs>(args: SelectSubset<T, TraceViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TraceView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewFindFirstArgs} args - Arguments to find a TraceView
     * @example
     * // Get one TraceView
     * const traceView = await prisma.traceView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraceViewFindFirstArgs>(args?: SelectSubset<T, TraceViewFindFirstArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TraceView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewFindFirstOrThrowArgs} args - Arguments to find a TraceView
     * @example
     * // Get one TraceView
     * const traceView = await prisma.traceView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraceViewFindFirstOrThrowArgs>(args?: SelectSubset<T, TraceViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TraceViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraceViews
     * const traceViews = await prisma.traceView.findMany()
     * 
     * // Get first 10 TraceViews
     * const traceViews = await prisma.traceView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traceViewWithIdOnly = await prisma.traceView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraceViewFindManyArgs>(args?: SelectSubset<T, TraceViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TraceView.
     * @param {TraceViewCreateArgs} args - Arguments to create a TraceView.
     * @example
     * // Create one TraceView
     * const TraceView = await prisma.traceView.create({
     *   data: {
     *     // ... data to create a TraceView
     *   }
     * })
     * 
     */
    create<T extends TraceViewCreateArgs>(args: SelectSubset<T, TraceViewCreateArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TraceViews.
     * @param {TraceViewCreateManyArgs} args - Arguments to create many TraceViews.
     * @example
     * // Create many TraceViews
     * const traceView = await prisma.traceView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraceViewCreateManyArgs>(args?: SelectSubset<T, TraceViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TraceViews and returns the data saved in the database.
     * @param {TraceViewCreateManyAndReturnArgs} args - Arguments to create many TraceViews.
     * @example
     * // Create many TraceViews
     * const traceView = await prisma.traceView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TraceViews and only return the `id`
     * const traceViewWithIdOnly = await prisma.traceView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraceViewCreateManyAndReturnArgs>(args?: SelectSubset<T, TraceViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TraceView.
     * @param {TraceViewDeleteArgs} args - Arguments to delete one TraceView.
     * @example
     * // Delete one TraceView
     * const TraceView = await prisma.traceView.delete({
     *   where: {
     *     // ... filter to delete one TraceView
     *   }
     * })
     * 
     */
    delete<T extends TraceViewDeleteArgs>(args: SelectSubset<T, TraceViewDeleteArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TraceView.
     * @param {TraceViewUpdateArgs} args - Arguments to update one TraceView.
     * @example
     * // Update one TraceView
     * const traceView = await prisma.traceView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraceViewUpdateArgs>(args: SelectSubset<T, TraceViewUpdateArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TraceViews.
     * @param {TraceViewDeleteManyArgs} args - Arguments to filter TraceViews to delete.
     * @example
     * // Delete a few TraceViews
     * const { count } = await prisma.traceView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraceViewDeleteManyArgs>(args?: SelectSubset<T, TraceViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraceViews
     * const traceView = await prisma.traceView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraceViewUpdateManyArgs>(args: SelectSubset<T, TraceViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TraceView.
     * @param {TraceViewUpsertArgs} args - Arguments to update or create a TraceView.
     * @example
     * // Update or create a TraceView
     * const traceView = await prisma.traceView.upsert({
     *   create: {
     *     // ... data to create a TraceView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraceView we want to update
     *   }
     * })
     */
    upsert<T extends TraceViewUpsertArgs>(args: SelectSubset<T, TraceViewUpsertArgs<ExtArgs>>): Prisma__TraceViewClient<$Result.GetResult<Prisma.$TraceViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TraceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewCountArgs} args - Arguments to filter TraceViews to count.
     * @example
     * // Count the number of TraceViews
     * const count = await prisma.traceView.count({
     *   where: {
     *     // ... the filter for the TraceViews we want to count
     *   }
     * })
    **/
    count<T extends TraceViewCountArgs>(
      args?: Subset<T, TraceViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceViewAggregateArgs>(args: Subset<T, TraceViewAggregateArgs>): Prisma.PrismaPromise<GetTraceViewAggregateType<T>>

    /**
     * Group by TraceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceViewGroupByArgs['orderBy'] }
        : { orderBy?: TraceViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraceView model
   */
  readonly fields: TraceViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraceView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraceViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraceView model
   */ 
  interface TraceViewFieldRefs {
    readonly id: FieldRef<"TraceView", 'String'>
    readonly externalId: FieldRef<"TraceView", 'String'>
    readonly timestamp: FieldRef<"TraceView", 'DateTime'>
    readonly name: FieldRef<"TraceView", 'String'>
    readonly userId: FieldRef<"TraceView", 'String'>
    readonly metadata: FieldRef<"TraceView", 'Json'>
    readonly release: FieldRef<"TraceView", 'String'>
    readonly version: FieldRef<"TraceView", 'String'>
    readonly projectId: FieldRef<"TraceView", 'String'>
    readonly public: FieldRef<"TraceView", 'Boolean'>
    readonly bookmarked: FieldRef<"TraceView", 'Boolean'>
    readonly tags: FieldRef<"TraceView", 'String[]'>
    readonly input: FieldRef<"TraceView", 'Json'>
    readonly output: FieldRef<"TraceView", 'Json'>
    readonly sessionId: FieldRef<"TraceView", 'String'>
    readonly createdAt: FieldRef<"TraceView", 'DateTime'>
    readonly updatedAt: FieldRef<"TraceView", 'DateTime'>
    readonly duration: FieldRef<"TraceView", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TraceView findUnique
   */
  export type TraceViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * Filter, which TraceView to fetch.
     */
    where: TraceViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView findUniqueOrThrow
   */
  export type TraceViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * Filter, which TraceView to fetch.
     */
    where: TraceViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView findFirst
   */
  export type TraceViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * Filter, which TraceView to fetch.
     */
    where?: TraceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceViews to fetch.
     */
    orderBy?: TraceViewOrderByWithRelationInput | TraceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceViews.
     */
    cursor?: TraceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceViews.
     */
    distinct?: TraceViewScalarFieldEnum | TraceViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView findFirstOrThrow
   */
  export type TraceViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * Filter, which TraceView to fetch.
     */
    where?: TraceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceViews to fetch.
     */
    orderBy?: TraceViewOrderByWithRelationInput | TraceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceViews.
     */
    cursor?: TraceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceViews.
     */
    distinct?: TraceViewScalarFieldEnum | TraceViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView findMany
   */
  export type TraceViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * Filter, which TraceViews to fetch.
     */
    where?: TraceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceViews to fetch.
     */
    orderBy?: TraceViewOrderByWithRelationInput | TraceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraceViews.
     */
    cursor?: TraceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceViews.
     */
    skip?: number
    distinct?: TraceViewScalarFieldEnum | TraceViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView create
   */
  export type TraceViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * The data needed to create a TraceView.
     */
    data: XOR<TraceViewCreateInput, TraceViewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView createMany
   */
  export type TraceViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraceViews.
     */
    data: TraceViewCreateManyInput | TraceViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraceView createManyAndReturn
   */
  export type TraceViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TraceViews.
     */
    data: TraceViewCreateManyInput | TraceViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraceView update
   */
  export type TraceViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * The data needed to update a TraceView.
     */
    data: XOR<TraceViewUpdateInput, TraceViewUncheckedUpdateInput>
    /**
     * Choose, which TraceView to update.
     */
    where: TraceViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView updateMany
   */
  export type TraceViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraceViews.
     */
    data: XOR<TraceViewUpdateManyMutationInput, TraceViewUncheckedUpdateManyInput>
    /**
     * Filter which TraceViews to update
     */
    where?: TraceViewWhereInput
  }

  /**
   * TraceView upsert
   */
  export type TraceViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * The filter to search for the TraceView to update in case it exists.
     */
    where: TraceViewWhereUniqueInput
    /**
     * In case the TraceView found by the `where` argument doesn't exist, create a new TraceView with this data.
     */
    create: XOR<TraceViewCreateInput, TraceViewUncheckedCreateInput>
    /**
     * In case the TraceView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraceViewUpdateInput, TraceViewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView delete
   */
  export type TraceViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
    /**
     * Filter which TraceView to delete.
     */
    where: TraceViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TraceView deleteMany
   */
  export type TraceViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceViews to delete
     */
    where?: TraceViewWhereInput
  }

  /**
   * TraceView without action
   */
  export type TraceViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceView
     */
    select?: TraceViewSelect<ExtArgs> | null
  }


  /**
   * Model ObservationView
   */

  export type AggregateObservationView = {
    _count: ObservationViewCountAggregateOutputType | null
    _avg: ObservationViewAvgAggregateOutputType | null
    _sum: ObservationViewSumAggregateOutputType | null
    _min: ObservationViewMinAggregateOutputType | null
    _max: ObservationViewMaxAggregateOutputType | null
  }

  export type ObservationViewAvgAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    promptVersion: number | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    latency: number | null
    timeToFirstToken: number | null
  }

  export type ObservationViewSumAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    promptVersion: number | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    latency: number | null
    timeToFirstToken: number | null
  }

  export type ObservationViewMinAggregateOutputType = {
    id: string | null
    traceId: string | null
    projectId: string | null
    type: $Enums.ObservationType | null
    startTime: Date | null
    endTime: Date | null
    name: string | null
    parentObservationId: string | null
    level: $Enums.ObservationLevel | null
    statusMessage: string | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    unit: string | null
    completionStartTime: Date | null
    promptId: string | null
    promptName: string | null
    promptVersion: number | null
    modelId: string | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    latency: number | null
    timeToFirstToken: number | null
  }

  export type ObservationViewMaxAggregateOutputType = {
    id: string | null
    traceId: string | null
    projectId: string | null
    type: $Enums.ObservationType | null
    startTime: Date | null
    endTime: Date | null
    name: string | null
    parentObservationId: string | null
    level: $Enums.ObservationLevel | null
    statusMessage: string | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    unit: string | null
    completionStartTime: Date | null
    promptId: string | null
    promptName: string | null
    promptVersion: number | null
    modelId: string | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    latency: number | null
    timeToFirstToken: number | null
  }

  export type ObservationViewCountAggregateOutputType = {
    id: number
    traceId: number
    projectId: number
    type: number
    startTime: number
    endTime: number
    name: number
    metadata: number
    parentObservationId: number
    level: number
    statusMessage: number
    version: number
    createdAt: number
    updatedAt: number
    model: number
    modelParameters: number
    input: number
    output: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    unit: number
    completionStartTime: number
    promptId: number
    promptName: number
    promptVersion: number
    modelId: number
    inputPrice: number
    outputPrice: number
    totalPrice: number
    calculatedInputCost: number
    calculatedOutputCost: number
    calculatedTotalCost: number
    latency: number
    timeToFirstToken: number
    _all: number
  }


  export type ObservationViewAvgAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    promptVersion?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    latency?: true
    timeToFirstToken?: true
  }

  export type ObservationViewSumAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    promptVersion?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    latency?: true
    timeToFirstToken?: true
  }

  export type ObservationViewMinAggregateInputType = {
    id?: true
    traceId?: true
    projectId?: true
    type?: true
    startTime?: true
    endTime?: true
    name?: true
    parentObservationId?: true
    level?: true
    statusMessage?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    unit?: true
    completionStartTime?: true
    promptId?: true
    promptName?: true
    promptVersion?: true
    modelId?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    latency?: true
    timeToFirstToken?: true
  }

  export type ObservationViewMaxAggregateInputType = {
    id?: true
    traceId?: true
    projectId?: true
    type?: true
    startTime?: true
    endTime?: true
    name?: true
    parentObservationId?: true
    level?: true
    statusMessage?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    unit?: true
    completionStartTime?: true
    promptId?: true
    promptName?: true
    promptVersion?: true
    modelId?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    latency?: true
    timeToFirstToken?: true
  }

  export type ObservationViewCountAggregateInputType = {
    id?: true
    traceId?: true
    projectId?: true
    type?: true
    startTime?: true
    endTime?: true
    name?: true
    metadata?: true
    parentObservationId?: true
    level?: true
    statusMessage?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    model?: true
    modelParameters?: true
    input?: true
    output?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    unit?: true
    completionStartTime?: true
    promptId?: true
    promptName?: true
    promptVersion?: true
    modelId?: true
    inputPrice?: true
    outputPrice?: true
    totalPrice?: true
    calculatedInputCost?: true
    calculatedOutputCost?: true
    calculatedTotalCost?: true
    latency?: true
    timeToFirstToken?: true
    _all?: true
  }

  export type ObservationViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObservationView to aggregate.
     */
    where?: ObservationViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationViews to fetch.
     */
    orderBy?: ObservationViewOrderByWithRelationInput | ObservationViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObservationViews
    **/
    _count?: true | ObservationViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObservationViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObservationViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationViewMaxAggregateInputType
  }

  export type GetObservationViewAggregateType<T extends ObservationViewAggregateArgs> = {
        [P in keyof T & keyof AggregateObservationView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservationView[P]>
      : GetScalarType<T[P], AggregateObservationView[P]>
  }




  export type ObservationViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationViewWhereInput
    orderBy?: ObservationViewOrderByWithAggregationInput | ObservationViewOrderByWithAggregationInput[]
    by: ObservationViewScalarFieldEnum[] | ObservationViewScalarFieldEnum
    having?: ObservationViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationViewCountAggregateInputType | true
    _avg?: ObservationViewAvgAggregateInputType
    _sum?: ObservationViewSumAggregateInputType
    _min?: ObservationViewMinAggregateInputType
    _max?: ObservationViewMaxAggregateInputType
  }

  export type ObservationViewGroupByOutputType = {
    id: string
    traceId: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime: Date
    endTime: Date | null
    name: string | null
    metadata: JsonValue | null
    parentObservationId: string | null
    level: $Enums.ObservationLevel
    statusMessage: string | null
    version: string | null
    createdAt: Date
    updatedAt: Date
    model: string | null
    modelParameters: JsonValue | null
    input: JsonValue | null
    output: JsonValue | null
    promptTokens: number
    completionTokens: number
    totalTokens: number
    unit: string | null
    completionStartTime: Date | null
    promptId: string | null
    promptName: string | null
    promptVersion: number | null
    modelId: string | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    totalPrice: Decimal | null
    calculatedInputCost: Decimal | null
    calculatedOutputCost: Decimal | null
    calculatedTotalCost: Decimal | null
    latency: number | null
    timeToFirstToken: number | null
    _count: ObservationViewCountAggregateOutputType | null
    _avg: ObservationViewAvgAggregateOutputType | null
    _sum: ObservationViewSumAggregateOutputType | null
    _min: ObservationViewMinAggregateOutputType | null
    _max: ObservationViewMaxAggregateOutputType | null
  }

  type GetObservationViewGroupByPayload<T extends ObservationViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationViewGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationViewGroupByOutputType[P]>
        }
      >
    >


  export type ObservationViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    projectId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    name?: boolean
    metadata?: boolean
    parentObservationId?: boolean
    level?: boolean
    statusMessage?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean
    modelParameters?: boolean
    input?: boolean
    output?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    unit?: boolean
    completionStartTime?: boolean
    promptId?: boolean
    promptName?: boolean
    promptVersion?: boolean
    modelId?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    totalPrice?: boolean
    calculatedInputCost?: boolean
    calculatedOutputCost?: boolean
    calculatedTotalCost?: boolean
    latency?: boolean
    timeToFirstToken?: boolean
  }, ExtArgs["result"]["observationView"]>

  export type ObservationViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    projectId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    name?: boolean
    metadata?: boolean
    parentObservationId?: boolean
    level?: boolean
    statusMessage?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean
    modelParameters?: boolean
    input?: boolean
    output?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    unit?: boolean
    completionStartTime?: boolean
    promptId?: boolean
    promptName?: boolean
    promptVersion?: boolean
    modelId?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    totalPrice?: boolean
    calculatedInputCost?: boolean
    calculatedOutputCost?: boolean
    calculatedTotalCost?: boolean
    latency?: boolean
    timeToFirstToken?: boolean
  }, ExtArgs["result"]["observationView"]>

  export type ObservationViewSelectScalar = {
    id?: boolean
    traceId?: boolean
    projectId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    name?: boolean
    metadata?: boolean
    parentObservationId?: boolean
    level?: boolean
    statusMessage?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean
    modelParameters?: boolean
    input?: boolean
    output?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    unit?: boolean
    completionStartTime?: boolean
    promptId?: boolean
    promptName?: boolean
    promptVersion?: boolean
    modelId?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    totalPrice?: boolean
    calculatedInputCost?: boolean
    calculatedOutputCost?: boolean
    calculatedTotalCost?: boolean
    latency?: boolean
    timeToFirstToken?: boolean
  }


  export type $ObservationViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObservationView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      traceId: string | null
      projectId: string
      type: $Enums.ObservationType
      startTime: Date
      endTime: Date | null
      name: string | null
      metadata: Prisma.JsonValue | null
      parentObservationId: string | null
      level: $Enums.ObservationLevel
      statusMessage: string | null
      version: string | null
      createdAt: Date
      updatedAt: Date
      model: string | null
      modelParameters: Prisma.JsonValue | null
      input: Prisma.JsonValue | null
      output: Prisma.JsonValue | null
      promptTokens: number
      completionTokens: number
      totalTokens: number
      unit: string | null
      completionStartTime: Date | null
      promptId: string | null
      promptName: string | null
      promptVersion: number | null
      modelId: string | null
      inputPrice: Prisma.Decimal | null
      outputPrice: Prisma.Decimal | null
      totalPrice: Prisma.Decimal | null
      calculatedInputCost: Prisma.Decimal | null
      calculatedOutputCost: Prisma.Decimal | null
      calculatedTotalCost: Prisma.Decimal | null
      latency: number | null
      timeToFirstToken: number | null
    }, ExtArgs["result"]["observationView"]>
    composites: {}
  }

  type ObservationViewGetPayload<S extends boolean | null | undefined | ObservationViewDefaultArgs> = $Result.GetResult<Prisma.$ObservationViewPayload, S>

  type ObservationViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObservationViewFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ObservationViewCountAggregateInputType | true
    }

  export interface ObservationViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObservationView'], meta: { name: 'ObservationView' } }
    /**
     * Find zero or one ObservationView that matches the filter.
     * @param {ObservationViewFindUniqueArgs} args - Arguments to find a ObservationView
     * @example
     * // Get one ObservationView
     * const observationView = await prisma.observationView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationViewFindUniqueArgs>(args: SelectSubset<T, ObservationViewFindUniqueArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ObservationView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObservationViewFindUniqueOrThrowArgs} args - Arguments to find a ObservationView
     * @example
     * // Get one ObservationView
     * const observationView = await prisma.observationView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ObservationView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewFindFirstArgs} args - Arguments to find a ObservationView
     * @example
     * // Get one ObservationView
     * const observationView = await prisma.observationView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationViewFindFirstArgs>(args?: SelectSubset<T, ObservationViewFindFirstArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ObservationView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewFindFirstOrThrowArgs} args - Arguments to find a ObservationView
     * @example
     * // Get one ObservationView
     * const observationView = await prisma.observationView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ObservationViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObservationViews
     * const observationViews = await prisma.observationView.findMany()
     * 
     * // Get first 10 ObservationViews
     * const observationViews = await prisma.observationView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationViewWithIdOnly = await prisma.observationView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationViewFindManyArgs>(args?: SelectSubset<T, ObservationViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ObservationView.
     * @param {ObservationViewCreateArgs} args - Arguments to create a ObservationView.
     * @example
     * // Create one ObservationView
     * const ObservationView = await prisma.observationView.create({
     *   data: {
     *     // ... data to create a ObservationView
     *   }
     * })
     * 
     */
    create<T extends ObservationViewCreateArgs>(args: SelectSubset<T, ObservationViewCreateArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ObservationViews.
     * @param {ObservationViewCreateManyArgs} args - Arguments to create many ObservationViews.
     * @example
     * // Create many ObservationViews
     * const observationView = await prisma.observationView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationViewCreateManyArgs>(args?: SelectSubset<T, ObservationViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObservationViews and returns the data saved in the database.
     * @param {ObservationViewCreateManyAndReturnArgs} args - Arguments to create many ObservationViews.
     * @example
     * // Create many ObservationViews
     * const observationView = await prisma.observationView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObservationViews and only return the `id`
     * const observationViewWithIdOnly = await prisma.observationView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObservationViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ObservationViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ObservationView.
     * @param {ObservationViewDeleteArgs} args - Arguments to delete one ObservationView.
     * @example
     * // Delete one ObservationView
     * const ObservationView = await prisma.observationView.delete({
     *   where: {
     *     // ... filter to delete one ObservationView
     *   }
     * })
     * 
     */
    delete<T extends ObservationViewDeleteArgs>(args: SelectSubset<T, ObservationViewDeleteArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ObservationView.
     * @param {ObservationViewUpdateArgs} args - Arguments to update one ObservationView.
     * @example
     * // Update one ObservationView
     * const observationView = await prisma.observationView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationViewUpdateArgs>(args: SelectSubset<T, ObservationViewUpdateArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ObservationViews.
     * @param {ObservationViewDeleteManyArgs} args - Arguments to filter ObservationViews to delete.
     * @example
     * // Delete a few ObservationViews
     * const { count } = await prisma.observationView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationViewDeleteManyArgs>(args?: SelectSubset<T, ObservationViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObservationViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObservationViews
     * const observationView = await prisma.observationView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationViewUpdateManyArgs>(args: SelectSubset<T, ObservationViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObservationView.
     * @param {ObservationViewUpsertArgs} args - Arguments to update or create a ObservationView.
     * @example
     * // Update or create a ObservationView
     * const observationView = await prisma.observationView.upsert({
     *   create: {
     *     // ... data to create a ObservationView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObservationView we want to update
     *   }
     * })
     */
    upsert<T extends ObservationViewUpsertArgs>(args: SelectSubset<T, ObservationViewUpsertArgs<ExtArgs>>): Prisma__ObservationViewClient<$Result.GetResult<Prisma.$ObservationViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ObservationViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewCountArgs} args - Arguments to filter ObservationViews to count.
     * @example
     * // Count the number of ObservationViews
     * const count = await prisma.observationView.count({
     *   where: {
     *     // ... the filter for the ObservationViews we want to count
     *   }
     * })
    **/
    count<T extends ObservationViewCountArgs>(
      args?: Subset<T, ObservationViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObservationView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationViewAggregateArgs>(args: Subset<T, ObservationViewAggregateArgs>): Prisma.PrismaPromise<GetObservationViewAggregateType<T>>

    /**
     * Group by ObservationView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationViewGroupByArgs['orderBy'] }
        : { orderBy?: ObservationViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObservationView model
   */
  readonly fields: ObservationViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObservationView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ObservationView model
   */ 
  interface ObservationViewFieldRefs {
    readonly id: FieldRef<"ObservationView", 'String'>
    readonly traceId: FieldRef<"ObservationView", 'String'>
    readonly projectId: FieldRef<"ObservationView", 'String'>
    readonly type: FieldRef<"ObservationView", 'ObservationType'>
    readonly startTime: FieldRef<"ObservationView", 'DateTime'>
    readonly endTime: FieldRef<"ObservationView", 'DateTime'>
    readonly name: FieldRef<"ObservationView", 'String'>
    readonly metadata: FieldRef<"ObservationView", 'Json'>
    readonly parentObservationId: FieldRef<"ObservationView", 'String'>
    readonly level: FieldRef<"ObservationView", 'ObservationLevel'>
    readonly statusMessage: FieldRef<"ObservationView", 'String'>
    readonly version: FieldRef<"ObservationView", 'String'>
    readonly createdAt: FieldRef<"ObservationView", 'DateTime'>
    readonly updatedAt: FieldRef<"ObservationView", 'DateTime'>
    readonly model: FieldRef<"ObservationView", 'String'>
    readonly modelParameters: FieldRef<"ObservationView", 'Json'>
    readonly input: FieldRef<"ObservationView", 'Json'>
    readonly output: FieldRef<"ObservationView", 'Json'>
    readonly promptTokens: FieldRef<"ObservationView", 'Int'>
    readonly completionTokens: FieldRef<"ObservationView", 'Int'>
    readonly totalTokens: FieldRef<"ObservationView", 'Int'>
    readonly unit: FieldRef<"ObservationView", 'String'>
    readonly completionStartTime: FieldRef<"ObservationView", 'DateTime'>
    readonly promptId: FieldRef<"ObservationView", 'String'>
    readonly promptName: FieldRef<"ObservationView", 'String'>
    readonly promptVersion: FieldRef<"ObservationView", 'Int'>
    readonly modelId: FieldRef<"ObservationView", 'String'>
    readonly inputPrice: FieldRef<"ObservationView", 'Decimal'>
    readonly outputPrice: FieldRef<"ObservationView", 'Decimal'>
    readonly totalPrice: FieldRef<"ObservationView", 'Decimal'>
    readonly calculatedInputCost: FieldRef<"ObservationView", 'Decimal'>
    readonly calculatedOutputCost: FieldRef<"ObservationView", 'Decimal'>
    readonly calculatedTotalCost: FieldRef<"ObservationView", 'Decimal'>
    readonly latency: FieldRef<"ObservationView", 'Float'>
    readonly timeToFirstToken: FieldRef<"ObservationView", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ObservationView findUnique
   */
  export type ObservationViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * Filter, which ObservationView to fetch.
     */
    where: ObservationViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView findUniqueOrThrow
   */
  export type ObservationViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * Filter, which ObservationView to fetch.
     */
    where: ObservationViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView findFirst
   */
  export type ObservationViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * Filter, which ObservationView to fetch.
     */
    where?: ObservationViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationViews to fetch.
     */
    orderBy?: ObservationViewOrderByWithRelationInput | ObservationViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObservationViews.
     */
    cursor?: ObservationViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObservationViews.
     */
    distinct?: ObservationViewScalarFieldEnum | ObservationViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView findFirstOrThrow
   */
  export type ObservationViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * Filter, which ObservationView to fetch.
     */
    where?: ObservationViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationViews to fetch.
     */
    orderBy?: ObservationViewOrderByWithRelationInput | ObservationViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObservationViews.
     */
    cursor?: ObservationViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObservationViews.
     */
    distinct?: ObservationViewScalarFieldEnum | ObservationViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView findMany
   */
  export type ObservationViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * Filter, which ObservationViews to fetch.
     */
    where?: ObservationViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationViews to fetch.
     */
    orderBy?: ObservationViewOrderByWithRelationInput | ObservationViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObservationViews.
     */
    cursor?: ObservationViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationViews.
     */
    skip?: number
    distinct?: ObservationViewScalarFieldEnum | ObservationViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView create
   */
  export type ObservationViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * The data needed to create a ObservationView.
     */
    data: XOR<ObservationViewCreateInput, ObservationViewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView createMany
   */
  export type ObservationViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObservationViews.
     */
    data: ObservationViewCreateManyInput | ObservationViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObservationView createManyAndReturn
   */
  export type ObservationViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ObservationViews.
     */
    data: ObservationViewCreateManyInput | ObservationViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObservationView update
   */
  export type ObservationViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * The data needed to update a ObservationView.
     */
    data: XOR<ObservationViewUpdateInput, ObservationViewUncheckedUpdateInput>
    /**
     * Choose, which ObservationView to update.
     */
    where: ObservationViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView updateMany
   */
  export type ObservationViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObservationViews.
     */
    data: XOR<ObservationViewUpdateManyMutationInput, ObservationViewUncheckedUpdateManyInput>
    /**
     * Filter which ObservationViews to update
     */
    where?: ObservationViewWhereInput
  }

  /**
   * ObservationView upsert
   */
  export type ObservationViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * The filter to search for the ObservationView to update in case it exists.
     */
    where: ObservationViewWhereUniqueInput
    /**
     * In case the ObservationView found by the `where` argument doesn't exist, create a new ObservationView with this data.
     */
    create: XOR<ObservationViewCreateInput, ObservationViewUncheckedCreateInput>
    /**
     * In case the ObservationView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationViewUpdateInput, ObservationViewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView delete
   */
  export type ObservationViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
    /**
     * Filter which ObservationView to delete.
     */
    where: ObservationViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ObservationView deleteMany
   */
  export type ObservationViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObservationViews to delete
     */
    where?: ObservationViewWhereInput
  }

  /**
   * ObservationView without action
   */
  export type ObservationViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationView
     */
    select?: ObservationViewSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    expires_in: 'expires_in',
    ext_expires_in: 'ext_expires_in',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    refresh_token_expires_in: 'refresh_token_expires_in',
    created_at: 'created_at'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    admin: 'admin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    featureFlags: 'featureFlags'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cloudConfig: 'cloudConfig'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    name: 'name'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    note: 'note',
    publicKey: 'publicKey',
    hashedSecretKey: 'hashedSecretKey',
    fastHashedSecretKey: 'fastHashedSecretKey',
    displaySecretKey: 'displaySecretKey',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    projectId: 'projectId'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const BackgroundMigrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    script: 'script',
    args: 'args',
    state: 'state',
    finishedAt: 'finishedAt',
    failedAt: 'failedAt',
    failedReason: 'failedReason',
    workerId: 'workerId',
    lockedAt: 'lockedAt'
  };

  export type BackgroundMigrationScalarFieldEnum = (typeof BackgroundMigrationScalarFieldEnum)[keyof typeof BackgroundMigrationScalarFieldEnum]


  export const LlmApiKeysScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    provider: 'provider',
    adapter: 'adapter',
    displaySecretKey: 'displaySecretKey',
    secretKey: 'secretKey',
    baseURL: 'baseURL',
    customModels: 'customModels',
    withDefaultModels: 'withDefaultModels',
    config: 'config',
    projectId: 'projectId'
  };

  export type LlmApiKeysScalarFieldEnum = (typeof LlmApiKeysScalarFieldEnum)[keyof typeof LlmApiKeysScalarFieldEnum]


  export const OrganizationMembershipScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationMembershipScalarFieldEnum = (typeof OrganizationMembershipScalarFieldEnum)[keyof typeof OrganizationMembershipScalarFieldEnum]


  export const ProjectMembershipScalarFieldEnum: {
    orgMembershipId: 'orgMembershipId',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectMembershipScalarFieldEnum = (typeof ProjectMembershipScalarFieldEnum)[keyof typeof ProjectMembershipScalarFieldEnum]


  export const MembershipInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    orgId: 'orgId',
    orgRole: 'orgRole',
    projectId: 'projectId',
    projectRole: 'projectRole',
    invitedByUserId: 'invitedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipInvitationScalarFieldEnum = (typeof MembershipInvitationScalarFieldEnum)[keyof typeof MembershipInvitationScalarFieldEnum]


  export const TraceSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    bookmarked: 'bookmarked',
    public: 'public'
  };

  export type TraceSessionScalarFieldEnum = (typeof TraceSessionScalarFieldEnum)[keyof typeof TraceSessionScalarFieldEnum]


  export const TraceScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    timestamp: 'timestamp',
    name: 'name',
    userId: 'userId',
    metadata: 'metadata',
    release: 'release',
    version: 'version',
    projectId: 'projectId',
    public: 'public',
    bookmarked: 'bookmarked',
    tags: 'tags',
    input: 'input',
    output: 'output',
    sessionId: 'sessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TraceScalarFieldEnum = (typeof TraceScalarFieldEnum)[keyof typeof TraceScalarFieldEnum]


  export const ObservationScalarFieldEnum: {
    id: 'id',
    traceId: 'traceId',
    projectId: 'projectId',
    type: 'type',
    startTime: 'startTime',
    endTime: 'endTime',
    name: 'name',
    metadata: 'metadata',
    parentObservationId: 'parentObservationId',
    level: 'level',
    statusMessage: 'statusMessage',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    model: 'model',
    internalModel: 'internalModel',
    internalModelId: 'internalModelId',
    modelParameters: 'modelParameters',
    input: 'input',
    output: 'output',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    unit: 'unit',
    inputCost: 'inputCost',
    outputCost: 'outputCost',
    totalCost: 'totalCost',
    calculatedInputCost: 'calculatedInputCost',
    calculatedOutputCost: 'calculatedOutputCost',
    calculatedTotalCost: 'calculatedTotalCost',
    completionStartTime: 'completionStartTime',
    promptId: 'promptId'
  };

  export type ObservationScalarFieldEnum = (typeof ObservationScalarFieldEnum)[keyof typeof ObservationScalarFieldEnum]


  export const ScoreScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    projectId: 'projectId',
    name: 'name',
    value: 'value',
    source: 'source',
    authorUserId: 'authorUserId',
    comment: 'comment',
    traceId: 'traceId',
    observationId: 'observationId',
    configId: 'configId',
    stringValue: 'stringValue',
    queueId: 'queueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dataType: 'dataType'
  };

  export type ScoreScalarFieldEnum = (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum]


  export const ScoreConfigScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    name: 'name',
    dataType: 'dataType',
    isArchived: 'isArchived',
    minValue: 'minValue',
    maxValue: 'maxValue',
    categories: 'categories',
    description: 'description'
  };

  export type ScoreConfigScalarFieldEnum = (typeof ScoreConfigScalarFieldEnum)[keyof typeof ScoreConfigScalarFieldEnum]


  export const AnnotationQueueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    scoreConfigIds: 'scoreConfigIds',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnotationQueueScalarFieldEnum = (typeof AnnotationQueueScalarFieldEnum)[keyof typeof AnnotationQueueScalarFieldEnum]


  export const AnnotationQueueItemScalarFieldEnum: {
    id: 'id',
    queueId: 'queueId',
    objectId: 'objectId',
    objectType: 'objectType',
    status: 'status',
    lockedAt: 'lockedAt',
    lockedByUserId: 'lockedByUserId',
    annotatorUserId: 'annotatorUserId',
    completedAt: 'completedAt',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnotationQueueItemScalarFieldEnum = (typeof AnnotationQueueItemScalarFieldEnum)[keyof typeof AnnotationQueueItemScalarFieldEnum]


  export const CronJobsScalarFieldEnum: {
    name: 'name',
    lastRun: 'lastRun',
    jobStartedAt: 'jobStartedAt',
    state: 'state'
  };

  export type CronJobsScalarFieldEnum = (typeof CronJobsScalarFieldEnum)[keyof typeof CronJobsScalarFieldEnum]


  export const DatasetScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatasetScalarFieldEnum = (typeof DatasetScalarFieldEnum)[keyof typeof DatasetScalarFieldEnum]


  export const DatasetItemScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    status: 'status',
    input: 'input',
    expectedOutput: 'expectedOutput',
    metadata: 'metadata',
    sourceTraceId: 'sourceTraceId',
    sourceObservationId: 'sourceObservationId',
    datasetId: 'datasetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatasetItemScalarFieldEnum = (typeof DatasetItemScalarFieldEnum)[keyof typeof DatasetItemScalarFieldEnum]


  export const DatasetRunsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    metadata: 'metadata',
    datasetId: 'datasetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatasetRunsScalarFieldEnum = (typeof DatasetRunsScalarFieldEnum)[keyof typeof DatasetRunsScalarFieldEnum]


  export const DatasetRunItemsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    datasetRunId: 'datasetRunId',
    datasetItemId: 'datasetItemId',
    traceId: 'traceId',
    observationId: 'observationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatasetRunItemsScalarFieldEnum = (typeof DatasetRunItemsScalarFieldEnum)[keyof typeof DatasetRunItemsScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    data: 'data',
    headers: 'headers',
    url: 'url',
    method: 'method'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    objectType: 'objectType',
    objectId: 'objectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    authorUserId: 'authorUserId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PromptScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    createdBy: 'createdBy',
    prompt: 'prompt',
    name: 'name',
    version: 'version',
    type: 'type',
    isActive: 'isActive',
    config: 'config',
    tags: 'tags',
    labels: 'labels'
  };

  export type PromptScalarFieldEnum = (typeof PromptScalarFieldEnum)[keyof typeof PromptScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    modelName: 'modelName',
    matchPattern: 'matchPattern',
    startDate: 'startDate',
    inputPrice: 'inputPrice',
    outputPrice: 'outputPrice',
    totalPrice: 'totalPrice',
    unit: 'unit',
    tokenizerId: 'tokenizerId',
    tokenizerConfig: 'tokenizerConfig'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    modelId: 'modelId',
    usageType: 'usageType',
    price: 'price'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    orgId: 'orgId',
    userOrgRole: 'userOrgRole',
    projectId: 'projectId',
    userProjectRole: 'userProjectRole',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    action: 'action',
    before: 'before',
    after: 'after'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const EvalTemplateScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    name: 'name',
    version: 'version',
    prompt: 'prompt',
    model: 'model',
    provider: 'provider',
    modelParams: 'modelParams',
    vars: 'vars',
    outputSchema: 'outputSchema'
  };

  export type EvalTemplateScalarFieldEnum = (typeof EvalTemplateScalarFieldEnum)[keyof typeof EvalTemplateScalarFieldEnum]


  export const JobConfigurationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    jobType: 'jobType',
    status: 'status',
    evalTemplateId: 'evalTemplateId',
    scoreName: 'scoreName',
    filter: 'filter',
    targetObject: 'targetObject',
    variableMapping: 'variableMapping',
    sampling: 'sampling',
    delay: 'delay'
  };

  export type JobConfigurationScalarFieldEnum = (typeof JobConfigurationScalarFieldEnum)[keyof typeof JobConfigurationScalarFieldEnum]


  export const JobExecutionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    jobConfigurationId: 'jobConfigurationId',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    error: 'error',
    jobInputTraceId: 'jobInputTraceId',
    jobInputObservationId: 'jobInputObservationId',
    jobInputDatasetItemId: 'jobInputDatasetItemId',
    jobOutputScoreId: 'jobOutputScoreId'
  };

  export type JobExecutionScalarFieldEnum = (typeof JobExecutionScalarFieldEnum)[keyof typeof JobExecutionScalarFieldEnum]


  export const SsoConfigScalarFieldEnum: {
    domain: 'domain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authProvider: 'authProvider',
    authConfig: 'authConfig'
  };

  export type SsoConfigScalarFieldEnum = (typeof SsoConfigScalarFieldEnum)[keyof typeof SsoConfigScalarFieldEnum]


  export const PosthogIntegrationScalarFieldEnum: {
    projectId: 'projectId',
    encryptedPosthogApiKey: 'encryptedPosthogApiKey',
    posthogHostName: 'posthogHostName',
    lastSyncAt: 'lastSyncAt',
    enabled: 'enabled',
    createdAt: 'createdAt'
  };

  export type PosthogIntegrationScalarFieldEnum = (typeof PosthogIntegrationScalarFieldEnum)[keyof typeof PosthogIntegrationScalarFieldEnum]


  export const BatchExportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    userId: 'userId',
    finishedAt: 'finishedAt',
    expiresAt: 'expiresAt',
    name: 'name',
    status: 'status',
    query: 'query',
    format: 'format',
    url: 'url',
    log: 'log'
  };

  export type BatchExportScalarFieldEnum = (typeof BatchExportScalarFieldEnum)[keyof typeof BatchExportScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    sha256Hash: 'sha256Hash',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uploadedAt: 'uploadedAt',
    uploadHttpStatus: 'uploadHttpStatus',
    uploadHttpError: 'uploadHttpError',
    bucketPath: 'bucketPath',
    bucketName: 'bucketName',
    contentType: 'contentType',
    contentLength: 'contentLength'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const TraceMediaScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mediaId: 'mediaId',
    traceId: 'traceId',
    field: 'field'
  };

  export type TraceMediaScalarFieldEnum = (typeof TraceMediaScalarFieldEnum)[keyof typeof TraceMediaScalarFieldEnum]


  export const ObservationMediaScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mediaId: 'mediaId',
    traceId: 'traceId',
    observationId: 'observationId',
    field: 'field'
  };

  export type ObservationMediaScalarFieldEnum = (typeof ObservationMediaScalarFieldEnum)[keyof typeof ObservationMediaScalarFieldEnum]


  export const TraceViewScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    timestamp: 'timestamp',
    name: 'name',
    userId: 'userId',
    metadata: 'metadata',
    release: 'release',
    version: 'version',
    projectId: 'projectId',
    public: 'public',
    bookmarked: 'bookmarked',
    tags: 'tags',
    input: 'input',
    output: 'output',
    sessionId: 'sessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    duration: 'duration'
  };

  export type TraceViewScalarFieldEnum = (typeof TraceViewScalarFieldEnum)[keyof typeof TraceViewScalarFieldEnum]


  export const ObservationViewScalarFieldEnum: {
    id: 'id',
    traceId: 'traceId',
    projectId: 'projectId',
    type: 'type',
    startTime: 'startTime',
    endTime: 'endTime',
    name: 'name',
    metadata: 'metadata',
    parentObservationId: 'parentObservationId',
    level: 'level',
    statusMessage: 'statusMessage',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    model: 'model',
    modelParameters: 'modelParameters',
    input: 'input',
    output: 'output',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    unit: 'unit',
    completionStartTime: 'completionStartTime',
    promptId: 'promptId',
    promptName: 'promptName',
    promptVersion: 'promptVersion',
    modelId: 'modelId',
    inputPrice: 'inputPrice',
    outputPrice: 'outputPrice',
    totalPrice: 'totalPrice',
    calculatedInputCost: 'calculatedInputCost',
    calculatedOutputCost: 'calculatedOutputCost',
    calculatedTotalCost: 'calculatedTotalCost',
    latency: 'latency',
    timeToFirstToken: 'timeToFirstToken'
  };

  export type ObservationViewScalarFieldEnum = (typeof ObservationViewScalarFieldEnum)[keyof typeof ObservationViewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'ObservationType'
   */
  export type EnumObservationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObservationType'>
    


  /**
   * Reference to a field of type 'ObservationType[]'
   */
  export type ListEnumObservationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObservationType[]'>
    


  /**
   * Reference to a field of type 'ObservationLevel'
   */
  export type EnumObservationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObservationLevel'>
    


  /**
   * Reference to a field of type 'ObservationLevel[]'
   */
  export type ListEnumObservationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObservationLevel[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ScoreSource'
   */
  export type EnumScoreSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreSource'>
    


  /**
   * Reference to a field of type 'ScoreSource[]'
   */
  export type ListEnumScoreSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreSource[]'>
    


  /**
   * Reference to a field of type 'ScoreDataType'
   */
  export type EnumScoreDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreDataType'>
    


  /**
   * Reference to a field of type 'ScoreDataType[]'
   */
  export type ListEnumScoreDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreDataType[]'>
    


  /**
   * Reference to a field of type 'AnnotationQueueObjectType'
   */
  export type EnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnotationQueueObjectType'>
    


  /**
   * Reference to a field of type 'AnnotationQueueObjectType[]'
   */
  export type ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnotationQueueObjectType[]'>
    


  /**
   * Reference to a field of type 'AnnotationQueueStatus'
   */
  export type EnumAnnotationQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnotationQueueStatus'>
    


  /**
   * Reference to a field of type 'AnnotationQueueStatus[]'
   */
  export type ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnotationQueueStatus[]'>
    


  /**
   * Reference to a field of type 'DatasetStatus'
   */
  export type EnumDatasetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetStatus'>
    


  /**
   * Reference to a field of type 'DatasetStatus[]'
   */
  export type ListEnumDatasetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetStatus[]'>
    


  /**
   * Reference to a field of type 'CommentObjectType'
   */
  export type EnumCommentObjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentObjectType'>
    


  /**
   * Reference to a field of type 'CommentObjectType[]'
   */
  export type ListEnumCommentObjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentObjectType[]'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'JobType[]'
   */
  export type ListEnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType[]'>
    


  /**
   * Reference to a field of type 'JobConfigState'
   */
  export type EnumJobConfigStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobConfigState'>
    


  /**
   * Reference to a field of type 'JobConfigState[]'
   */
  export type ListEnumJobConfigStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobConfigState[]'>
    


  /**
   * Reference to a field of type 'JobExecutionStatus'
   */
  export type EnumJobExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobExecutionStatus'>
    


  /**
   * Reference to a field of type 'JobExecutionStatus[]'
   */
  export type ListEnumJobExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobExecutionStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    expires_in?: IntNullableFilter<"Account"> | number | null
    ext_expires_in?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    created_at?: IntNullableFilter<"Account"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    expires_in?: SortOrderInput | SortOrder
    ext_expires_in?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    refresh_token_expires_in?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    expires_in?: IntNullableFilter<"Account"> | number | null
    ext_expires_in?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    created_at?: IntNullableFilter<"Account"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    expires_in?: SortOrderInput | SortOrder
    ext_expires_in?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    refresh_token_expires_in?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    expires_in?: IntNullableWithAggregatesFilter<"Account"> | number | null
    ext_expires_in?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableWithAggregatesFilter<"Account"> | number | null
    created_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    admin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    featureFlags?: StringNullableListFilter<"User">
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    organizationMemberships?: OrganizationMembershipListRelationFilter
    projectMemberships?: ProjectMembershipListRelationFilter
    invitations?: MembershipInvitationListRelationFilter
    annotatedLockedItem?: AnnotationQueueItemListRelationFilter
    annotatedCompletedItem?: AnnotationQueueItemListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureFlags?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    organizationMemberships?: OrganizationMembershipOrderByRelationAggregateInput
    projectMemberships?: ProjectMembershipOrderByRelationAggregateInput
    invitations?: MembershipInvitationOrderByRelationAggregateInput
    annotatedLockedItem?: AnnotationQueueItemOrderByRelationAggregateInput
    annotatedCompletedItem?: AnnotationQueueItemOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    admin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    featureFlags?: StringNullableListFilter<"User">
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    organizationMemberships?: OrganizationMembershipListRelationFilter
    projectMemberships?: ProjectMembershipListRelationFilter
    invitations?: MembershipInvitationListRelationFilter
    annotatedLockedItem?: AnnotationQueueItemListRelationFilter
    annotatedCompletedItem?: AnnotationQueueItemListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureFlags?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    admin?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    featureFlags?: StringNullableListFilter<"User">
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    cloudConfig?: JsonNullableFilter<"Organization">
    organizationMemberships?: OrganizationMembershipListRelationFilter
    projects?: ProjectListRelationFilter
    MembershipInvitation?: MembershipInvitationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cloudConfig?: SortOrderInput | SortOrder
    organizationMemberships?: OrganizationMembershipOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    MembershipInvitation?: MembershipInvitationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    cloudConfig?: JsonNullableFilter<"Organization">
    organizationMemberships?: OrganizationMembershipListRelationFilter
    projects?: ProjectListRelationFilter
    MembershipInvitation?: MembershipInvitationListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cloudConfig?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    cloudConfig?: JsonNullableWithAggregatesFilter<"Organization">
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    orgId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    name?: StringFilter<"Project"> | string
    projectMembers?: ProjectMembershipListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    traces?: TraceListRelationFilter
    observations?: ObservationListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    dataset?: DatasetListRelationFilter
    RawEvents?: EventsListRelationFilter
    invitations?: MembershipInvitationListRelationFilter
    sessions?: TraceSessionListRelationFilter
    Prompt?: PromptListRelationFilter
    Model?: ModelListRelationFilter
    EvalTemplate?: EvalTemplateListRelationFilter
    JobConfiguration?: JobConfigurationListRelationFilter
    JobExecution?: JobExecutionListRelationFilter
    LlmApiKeys?: LlmApiKeysListRelationFilter
    PosthogIntegration?: PosthogIntegrationListRelationFilter
    Score?: ScoreListRelationFilter
    scoreConfig?: ScoreConfigListRelationFilter
    BatchExport?: BatchExportListRelationFilter
    comment?: CommentListRelationFilter
    annotationQueue?: AnnotationQueueListRelationFilter
    annotationQueueItem?: AnnotationQueueItemListRelationFilter
    TraceMedia?: TraceMediaListRelationFilter
    Media?: MediaListRelationFilter
    ObservationMedia?: ObservationMediaListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    projectMembers?: ProjectMembershipOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
    traces?: TraceOrderByRelationAggregateInput
    observations?: ObservationOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    dataset?: DatasetOrderByRelationAggregateInput
    RawEvents?: EventsOrderByRelationAggregateInput
    invitations?: MembershipInvitationOrderByRelationAggregateInput
    sessions?: TraceSessionOrderByRelationAggregateInput
    Prompt?: PromptOrderByRelationAggregateInput
    Model?: ModelOrderByRelationAggregateInput
    EvalTemplate?: EvalTemplateOrderByRelationAggregateInput
    JobConfiguration?: JobConfigurationOrderByRelationAggregateInput
    JobExecution?: JobExecutionOrderByRelationAggregateInput
    LlmApiKeys?: LlmApiKeysOrderByRelationAggregateInput
    PosthogIntegration?: PosthogIntegrationOrderByRelationAggregateInput
    Score?: ScoreOrderByRelationAggregateInput
    scoreConfig?: ScoreConfigOrderByRelationAggregateInput
    BatchExport?: BatchExportOrderByRelationAggregateInput
    comment?: CommentOrderByRelationAggregateInput
    annotationQueue?: AnnotationQueueOrderByRelationAggregateInput
    annotationQueueItem?: AnnotationQueueItemOrderByRelationAggregateInput
    TraceMedia?: TraceMediaOrderByRelationAggregateInput
    Media?: MediaOrderByRelationAggregateInput
    ObservationMedia?: ObservationMediaOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    orgId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    name?: StringFilter<"Project"> | string
    projectMembers?: ProjectMembershipListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    traces?: TraceListRelationFilter
    observations?: ObservationListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    dataset?: DatasetListRelationFilter
    RawEvents?: EventsListRelationFilter
    invitations?: MembershipInvitationListRelationFilter
    sessions?: TraceSessionListRelationFilter
    Prompt?: PromptListRelationFilter
    Model?: ModelListRelationFilter
    EvalTemplate?: EvalTemplateListRelationFilter
    JobConfiguration?: JobConfigurationListRelationFilter
    JobExecution?: JobExecutionListRelationFilter
    LlmApiKeys?: LlmApiKeysListRelationFilter
    PosthogIntegration?: PosthogIntegrationListRelationFilter
    Score?: ScoreListRelationFilter
    scoreConfig?: ScoreConfigListRelationFilter
    BatchExport?: BatchExportListRelationFilter
    comment?: CommentListRelationFilter
    annotationQueue?: AnnotationQueueListRelationFilter
    annotationQueueItem?: AnnotationQueueItemListRelationFilter
    TraceMedia?: TraceMediaListRelationFilter
    Media?: MediaListRelationFilter
    ObservationMedia?: ObservationMediaListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    orgId?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    name?: StringWithAggregatesFilter<"Project"> | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    note?: StringNullableFilter<"ApiKey"> | string | null
    publicKey?: StringFilter<"ApiKey"> | string
    hashedSecretKey?: StringFilter<"ApiKey"> | string
    fastHashedSecretKey?: StringNullableFilter<"ApiKey"> | string | null
    displaySecretKey?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    projectId?: StringFilter<"ApiKey"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    note?: SortOrderInput | SortOrder
    publicKey?: SortOrder
    hashedSecretKey?: SortOrder
    fastHashedSecretKey?: SortOrderInput | SortOrder
    displaySecretKey?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicKey?: string
    hashedSecretKey?: string
    fastHashedSecretKey?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    note?: StringNullableFilter<"ApiKey"> | string | null
    displaySecretKey?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    projectId?: StringFilter<"ApiKey"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "id" | "publicKey" | "hashedSecretKey" | "fastHashedSecretKey">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    note?: SortOrderInput | SortOrder
    publicKey?: SortOrder
    hashedSecretKey?: SortOrder
    fastHashedSecretKey?: SortOrderInput | SortOrder
    displaySecretKey?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    note?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    publicKey?: StringWithAggregatesFilter<"ApiKey"> | string
    hashedSecretKey?: StringWithAggregatesFilter<"ApiKey"> | string
    fastHashedSecretKey?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    displaySecretKey?: StringWithAggregatesFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    projectId?: StringWithAggregatesFilter<"ApiKey"> | string
  }

  export type BackgroundMigrationWhereInput = {
    AND?: BackgroundMigrationWhereInput | BackgroundMigrationWhereInput[]
    OR?: BackgroundMigrationWhereInput[]
    NOT?: BackgroundMigrationWhereInput | BackgroundMigrationWhereInput[]
    id?: StringFilter<"BackgroundMigration"> | string
    name?: StringFilter<"BackgroundMigration"> | string
    script?: StringFilter<"BackgroundMigration"> | string
    args?: JsonFilter<"BackgroundMigration">
    state?: JsonFilter<"BackgroundMigration">
    finishedAt?: DateTimeNullableFilter<"BackgroundMigration"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"BackgroundMigration"> | Date | string | null
    failedReason?: StringNullableFilter<"BackgroundMigration"> | string | null
    workerId?: StringNullableFilter<"BackgroundMigration"> | string | null
    lockedAt?: DateTimeNullableFilter<"BackgroundMigration"> | Date | string | null
  }

  export type BackgroundMigrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    script?: SortOrder
    args?: SortOrder
    state?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failedReason?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
  }

  export type BackgroundMigrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BackgroundMigrationWhereInput | BackgroundMigrationWhereInput[]
    OR?: BackgroundMigrationWhereInput[]
    NOT?: BackgroundMigrationWhereInput | BackgroundMigrationWhereInput[]
    script?: StringFilter<"BackgroundMigration"> | string
    args?: JsonFilter<"BackgroundMigration">
    state?: JsonFilter<"BackgroundMigration">
    finishedAt?: DateTimeNullableFilter<"BackgroundMigration"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"BackgroundMigration"> | Date | string | null
    failedReason?: StringNullableFilter<"BackgroundMigration"> | string | null
    workerId?: StringNullableFilter<"BackgroundMigration"> | string | null
    lockedAt?: DateTimeNullableFilter<"BackgroundMigration"> | Date | string | null
  }, "id" | "name">

  export type BackgroundMigrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    script?: SortOrder
    args?: SortOrder
    state?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failedReason?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    _count?: BackgroundMigrationCountOrderByAggregateInput
    _max?: BackgroundMigrationMaxOrderByAggregateInput
    _min?: BackgroundMigrationMinOrderByAggregateInput
  }

  export type BackgroundMigrationScalarWhereWithAggregatesInput = {
    AND?: BackgroundMigrationScalarWhereWithAggregatesInput | BackgroundMigrationScalarWhereWithAggregatesInput[]
    OR?: BackgroundMigrationScalarWhereWithAggregatesInput[]
    NOT?: BackgroundMigrationScalarWhereWithAggregatesInput | BackgroundMigrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackgroundMigration"> | string
    name?: StringWithAggregatesFilter<"BackgroundMigration"> | string
    script?: StringWithAggregatesFilter<"BackgroundMigration"> | string
    args?: JsonWithAggregatesFilter<"BackgroundMigration">
    state?: JsonWithAggregatesFilter<"BackgroundMigration">
    finishedAt?: DateTimeNullableWithAggregatesFilter<"BackgroundMigration"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"BackgroundMigration"> | Date | string | null
    failedReason?: StringNullableWithAggregatesFilter<"BackgroundMigration"> | string | null
    workerId?: StringNullableWithAggregatesFilter<"BackgroundMigration"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"BackgroundMigration"> | Date | string | null
  }

  export type LlmApiKeysWhereInput = {
    AND?: LlmApiKeysWhereInput | LlmApiKeysWhereInput[]
    OR?: LlmApiKeysWhereInput[]
    NOT?: LlmApiKeysWhereInput | LlmApiKeysWhereInput[]
    id?: StringFilter<"LlmApiKeys"> | string
    createdAt?: DateTimeFilter<"LlmApiKeys"> | Date | string
    updatedAt?: DateTimeFilter<"LlmApiKeys"> | Date | string
    provider?: StringFilter<"LlmApiKeys"> | string
    adapter?: StringFilter<"LlmApiKeys"> | string
    displaySecretKey?: StringFilter<"LlmApiKeys"> | string
    secretKey?: StringFilter<"LlmApiKeys"> | string
    baseURL?: StringNullableFilter<"LlmApiKeys"> | string | null
    customModels?: StringNullableListFilter<"LlmApiKeys">
    withDefaultModels?: BoolFilter<"LlmApiKeys"> | boolean
    config?: JsonNullableFilter<"LlmApiKeys">
    projectId?: StringFilter<"LlmApiKeys"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type LlmApiKeysOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    adapter?: SortOrder
    displaySecretKey?: SortOrder
    secretKey?: SortOrder
    baseURL?: SortOrderInput | SortOrder
    customModels?: SortOrder
    withDefaultModels?: SortOrder
    config?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type LlmApiKeysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_provider?: LlmApiKeysProjectIdProviderCompoundUniqueInput
    AND?: LlmApiKeysWhereInput | LlmApiKeysWhereInput[]
    OR?: LlmApiKeysWhereInput[]
    NOT?: LlmApiKeysWhereInput | LlmApiKeysWhereInput[]
    createdAt?: DateTimeFilter<"LlmApiKeys"> | Date | string
    updatedAt?: DateTimeFilter<"LlmApiKeys"> | Date | string
    provider?: StringFilter<"LlmApiKeys"> | string
    adapter?: StringFilter<"LlmApiKeys"> | string
    displaySecretKey?: StringFilter<"LlmApiKeys"> | string
    secretKey?: StringFilter<"LlmApiKeys"> | string
    baseURL?: StringNullableFilter<"LlmApiKeys"> | string | null
    customModels?: StringNullableListFilter<"LlmApiKeys">
    withDefaultModels?: BoolFilter<"LlmApiKeys"> | boolean
    config?: JsonNullableFilter<"LlmApiKeys">
    projectId?: StringFilter<"LlmApiKeys"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "id" | "projectId_provider">

  export type LlmApiKeysOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    adapter?: SortOrder
    displaySecretKey?: SortOrder
    secretKey?: SortOrder
    baseURL?: SortOrderInput | SortOrder
    customModels?: SortOrder
    withDefaultModels?: SortOrder
    config?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: LlmApiKeysCountOrderByAggregateInput
    _max?: LlmApiKeysMaxOrderByAggregateInput
    _min?: LlmApiKeysMinOrderByAggregateInput
  }

  export type LlmApiKeysScalarWhereWithAggregatesInput = {
    AND?: LlmApiKeysScalarWhereWithAggregatesInput | LlmApiKeysScalarWhereWithAggregatesInput[]
    OR?: LlmApiKeysScalarWhereWithAggregatesInput[]
    NOT?: LlmApiKeysScalarWhereWithAggregatesInput | LlmApiKeysScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LlmApiKeys"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LlmApiKeys"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LlmApiKeys"> | Date | string
    provider?: StringWithAggregatesFilter<"LlmApiKeys"> | string
    adapter?: StringWithAggregatesFilter<"LlmApiKeys"> | string
    displaySecretKey?: StringWithAggregatesFilter<"LlmApiKeys"> | string
    secretKey?: StringWithAggregatesFilter<"LlmApiKeys"> | string
    baseURL?: StringNullableWithAggregatesFilter<"LlmApiKeys"> | string | null
    customModels?: StringNullableListFilter<"LlmApiKeys">
    withDefaultModels?: BoolWithAggregatesFilter<"LlmApiKeys"> | boolean
    config?: JsonNullableWithAggregatesFilter<"LlmApiKeys">
    projectId?: StringWithAggregatesFilter<"LlmApiKeys"> | string
  }

  export type OrganizationMembershipWhereInput = {
    AND?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    OR?: OrganizationMembershipWhereInput[]
    NOT?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    id?: StringFilter<"OrganizationMembership"> | string
    orgId?: StringFilter<"OrganizationMembership"> | string
    userId?: StringFilter<"OrganizationMembership"> | string
    role?: EnumRoleFilter<"OrganizationMembership"> | $Enums.Role
    createdAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    ProjectMemberships?: ProjectMembershipListRelationFilter
  }

  export type OrganizationMembershipOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    ProjectMemberships?: ProjectMembershipOrderByRelationAggregateInput
  }

  export type OrganizationMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId_userId?: OrganizationMembershipOrgIdUserIdCompoundUniqueInput
    AND?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    OR?: OrganizationMembershipWhereInput[]
    NOT?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    orgId?: StringFilter<"OrganizationMembership"> | string
    userId?: StringFilter<"OrganizationMembership"> | string
    role?: EnumRoleFilter<"OrganizationMembership"> | $Enums.Role
    createdAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    ProjectMemberships?: ProjectMembershipListRelationFilter
  }, "id" | "orgId_userId">

  export type OrganizationMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationMembershipCountOrderByAggregateInput
    _max?: OrganizationMembershipMaxOrderByAggregateInput
    _min?: OrganizationMembershipMinOrderByAggregateInput
  }

  export type OrganizationMembershipScalarWhereWithAggregatesInput = {
    AND?: OrganizationMembershipScalarWhereWithAggregatesInput | OrganizationMembershipScalarWhereWithAggregatesInput[]
    OR?: OrganizationMembershipScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMembershipScalarWhereWithAggregatesInput | OrganizationMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    orgId?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    userId?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    role?: EnumRoleWithAggregatesFilter<"OrganizationMembership"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationMembership"> | Date | string
  }

  export type ProjectMembershipWhereInput = {
    AND?: ProjectMembershipWhereInput | ProjectMembershipWhereInput[]
    OR?: ProjectMembershipWhereInput[]
    NOT?: ProjectMembershipWhereInput | ProjectMembershipWhereInput[]
    orgMembershipId?: StringFilter<"ProjectMembership"> | string
    projectId?: StringFilter<"ProjectMembership"> | string
    userId?: StringFilter<"ProjectMembership"> | string
    role?: EnumRoleFilter<"ProjectMembership"> | $Enums.Role
    createdAt?: DateTimeFilter<"ProjectMembership"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMembership"> | Date | string
    organizationMembership?: XOR<OrganizationMembershipRelationFilter, OrganizationMembershipWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectMembershipOrderByWithRelationInput = {
    orgMembershipId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationMembership?: OrganizationMembershipOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMembershipWhereUniqueInput = Prisma.AtLeast<{
    projectId_userId?: ProjectMembershipProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMembershipWhereInput | ProjectMembershipWhereInput[]
    OR?: ProjectMembershipWhereInput[]
    NOT?: ProjectMembershipWhereInput | ProjectMembershipWhereInput[]
    orgMembershipId?: StringFilter<"ProjectMembership"> | string
    projectId?: StringFilter<"ProjectMembership"> | string
    userId?: StringFilter<"ProjectMembership"> | string
    role?: EnumRoleFilter<"ProjectMembership"> | $Enums.Role
    createdAt?: DateTimeFilter<"ProjectMembership"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMembership"> | Date | string
    organizationMembership?: XOR<OrganizationMembershipRelationFilter, OrganizationMembershipWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "projectId_userId">

  export type ProjectMembershipOrderByWithAggregationInput = {
    orgMembershipId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectMembershipCountOrderByAggregateInput
    _max?: ProjectMembershipMaxOrderByAggregateInput
    _min?: ProjectMembershipMinOrderByAggregateInput
  }

  export type ProjectMembershipScalarWhereWithAggregatesInput = {
    AND?: ProjectMembershipScalarWhereWithAggregatesInput | ProjectMembershipScalarWhereWithAggregatesInput[]
    OR?: ProjectMembershipScalarWhereWithAggregatesInput[]
    NOT?: ProjectMembershipScalarWhereWithAggregatesInput | ProjectMembershipScalarWhereWithAggregatesInput[]
    orgMembershipId?: StringWithAggregatesFilter<"ProjectMembership"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMembership"> | string
    userId?: StringWithAggregatesFilter<"ProjectMembership"> | string
    role?: EnumRoleWithAggregatesFilter<"ProjectMembership"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMembership"> | Date | string
  }

  export type MembershipInvitationWhereInput = {
    AND?: MembershipInvitationWhereInput | MembershipInvitationWhereInput[]
    OR?: MembershipInvitationWhereInput[]
    NOT?: MembershipInvitationWhereInput | MembershipInvitationWhereInput[]
    id?: StringFilter<"MembershipInvitation"> | string
    email?: StringFilter<"MembershipInvitation"> | string
    orgId?: StringFilter<"MembershipInvitation"> | string
    orgRole?: EnumRoleFilter<"MembershipInvitation"> | $Enums.Role
    projectId?: StringNullableFilter<"MembershipInvitation"> | string | null
    projectRole?: EnumRoleNullableFilter<"MembershipInvitation"> | $Enums.Role | null
    invitedByUserId?: StringNullableFilter<"MembershipInvitation"> | string | null
    createdAt?: DateTimeFilter<"MembershipInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipInvitation"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    invitedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type MembershipInvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    orgRole?: SortOrder
    projectId?: SortOrderInput | SortOrder
    projectRole?: SortOrderInput | SortOrder
    invitedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    invitedByUser?: UserOrderByWithRelationInput
  }

  export type MembershipInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MembershipInvitationWhereInput | MembershipInvitationWhereInput[]
    OR?: MembershipInvitationWhereInput[]
    NOT?: MembershipInvitationWhereInput | MembershipInvitationWhereInput[]
    email?: StringFilter<"MembershipInvitation"> | string
    orgId?: StringFilter<"MembershipInvitation"> | string
    orgRole?: EnumRoleFilter<"MembershipInvitation"> | $Enums.Role
    projectId?: StringNullableFilter<"MembershipInvitation"> | string | null
    projectRole?: EnumRoleNullableFilter<"MembershipInvitation"> | $Enums.Role | null
    invitedByUserId?: StringNullableFilter<"MembershipInvitation"> | string | null
    createdAt?: DateTimeFilter<"MembershipInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipInvitation"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    invitedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "id">

  export type MembershipInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    orgRole?: SortOrder
    projectId?: SortOrderInput | SortOrder
    projectRole?: SortOrderInput | SortOrder
    invitedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipInvitationCountOrderByAggregateInput
    _max?: MembershipInvitationMaxOrderByAggregateInput
    _min?: MembershipInvitationMinOrderByAggregateInput
  }

  export type MembershipInvitationScalarWhereWithAggregatesInput = {
    AND?: MembershipInvitationScalarWhereWithAggregatesInput | MembershipInvitationScalarWhereWithAggregatesInput[]
    OR?: MembershipInvitationScalarWhereWithAggregatesInput[]
    NOT?: MembershipInvitationScalarWhereWithAggregatesInput | MembershipInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipInvitation"> | string
    email?: StringWithAggregatesFilter<"MembershipInvitation"> | string
    orgId?: StringWithAggregatesFilter<"MembershipInvitation"> | string
    orgRole?: EnumRoleWithAggregatesFilter<"MembershipInvitation"> | $Enums.Role
    projectId?: StringNullableWithAggregatesFilter<"MembershipInvitation"> | string | null
    projectRole?: EnumRoleNullableWithAggregatesFilter<"MembershipInvitation"> | $Enums.Role | null
    invitedByUserId?: StringNullableWithAggregatesFilter<"MembershipInvitation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MembershipInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipInvitation"> | Date | string
  }

  export type TraceSessionWhereInput = {
    AND?: TraceSessionWhereInput | TraceSessionWhereInput[]
    OR?: TraceSessionWhereInput[]
    NOT?: TraceSessionWhereInput | TraceSessionWhereInput[]
    id?: StringFilter<"TraceSession"> | string
    createdAt?: DateTimeFilter<"TraceSession"> | Date | string
    updatedAt?: DateTimeFilter<"TraceSession"> | Date | string
    projectId?: StringFilter<"TraceSession"> | string
    bookmarked?: BoolFilter<"TraceSession"> | boolean
    public?: BoolFilter<"TraceSession"> | boolean
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    traces?: TraceListRelationFilter
  }

  export type TraceSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    bookmarked?: SortOrder
    public?: SortOrder
    project?: ProjectOrderByWithRelationInput
    traces?: TraceOrderByRelationAggregateInput
  }

  export type TraceSessionWhereUniqueInput = Prisma.AtLeast<{
    id_projectId?: TraceSessionIdProjectIdCompoundUniqueInput
    AND?: TraceSessionWhereInput | TraceSessionWhereInput[]
    OR?: TraceSessionWhereInput[]
    NOT?: TraceSessionWhereInput | TraceSessionWhereInput[]
    id?: StringFilter<"TraceSession"> | string
    createdAt?: DateTimeFilter<"TraceSession"> | Date | string
    updatedAt?: DateTimeFilter<"TraceSession"> | Date | string
    projectId?: StringFilter<"TraceSession"> | string
    bookmarked?: BoolFilter<"TraceSession"> | boolean
    public?: BoolFilter<"TraceSession"> | boolean
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    traces?: TraceListRelationFilter
  }, "id_projectId">

  export type TraceSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    bookmarked?: SortOrder
    public?: SortOrder
    _count?: TraceSessionCountOrderByAggregateInput
    _max?: TraceSessionMaxOrderByAggregateInput
    _min?: TraceSessionMinOrderByAggregateInput
  }

  export type TraceSessionScalarWhereWithAggregatesInput = {
    AND?: TraceSessionScalarWhereWithAggregatesInput | TraceSessionScalarWhereWithAggregatesInput[]
    OR?: TraceSessionScalarWhereWithAggregatesInput[]
    NOT?: TraceSessionScalarWhereWithAggregatesInput | TraceSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TraceSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TraceSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TraceSession"> | Date | string
    projectId?: StringWithAggregatesFilter<"TraceSession"> | string
    bookmarked?: BoolWithAggregatesFilter<"TraceSession"> | boolean
    public?: BoolWithAggregatesFilter<"TraceSession"> | boolean
  }

  export type TraceWhereInput = {
    AND?: TraceWhereInput | TraceWhereInput[]
    OR?: TraceWhereInput[]
    NOT?: TraceWhereInput | TraceWhereInput[]
    id?: StringFilter<"Trace"> | string
    externalId?: StringNullableFilter<"Trace"> | string | null
    timestamp?: DateTimeFilter<"Trace"> | Date | string
    name?: StringNullableFilter<"Trace"> | string | null
    userId?: StringNullableFilter<"Trace"> | string | null
    metadata?: JsonNullableFilter<"Trace">
    release?: StringNullableFilter<"Trace"> | string | null
    version?: StringNullableFilter<"Trace"> | string | null
    projectId?: StringFilter<"Trace"> | string
    public?: BoolFilter<"Trace"> | boolean
    bookmarked?: BoolFilter<"Trace"> | boolean
    tags?: StringNullableListFilter<"Trace">
    input?: JsonNullableFilter<"Trace">
    output?: JsonNullableFilter<"Trace">
    sessionId?: StringNullableFilter<"Trace"> | string | null
    createdAt?: DateTimeFilter<"Trace"> | Date | string
    updatedAt?: DateTimeFilter<"Trace"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    session?: XOR<TraceSessionNullableRelationFilter, TraceSessionWhereInput> | null
  }

  export type TraceOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    release?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    tags?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    session?: TraceSessionOrderByWithRelationInput
  }

  export type TraceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TraceWhereInput | TraceWhereInput[]
    OR?: TraceWhereInput[]
    NOT?: TraceWhereInput | TraceWhereInput[]
    externalId?: StringNullableFilter<"Trace"> | string | null
    timestamp?: DateTimeFilter<"Trace"> | Date | string
    name?: StringNullableFilter<"Trace"> | string | null
    userId?: StringNullableFilter<"Trace"> | string | null
    metadata?: JsonNullableFilter<"Trace">
    release?: StringNullableFilter<"Trace"> | string | null
    version?: StringNullableFilter<"Trace"> | string | null
    projectId?: StringFilter<"Trace"> | string
    public?: BoolFilter<"Trace"> | boolean
    bookmarked?: BoolFilter<"Trace"> | boolean
    tags?: StringNullableListFilter<"Trace">
    input?: JsonNullableFilter<"Trace">
    output?: JsonNullableFilter<"Trace">
    sessionId?: StringNullableFilter<"Trace"> | string | null
    createdAt?: DateTimeFilter<"Trace"> | Date | string
    updatedAt?: DateTimeFilter<"Trace"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    session?: XOR<TraceSessionNullableRelationFilter, TraceSessionWhereInput> | null
  }, "id">

  export type TraceOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    release?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    tags?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TraceCountOrderByAggregateInput
    _max?: TraceMaxOrderByAggregateInput
    _min?: TraceMinOrderByAggregateInput
  }

  export type TraceScalarWhereWithAggregatesInput = {
    AND?: TraceScalarWhereWithAggregatesInput | TraceScalarWhereWithAggregatesInput[]
    OR?: TraceScalarWhereWithAggregatesInput[]
    NOT?: TraceScalarWhereWithAggregatesInput | TraceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trace"> | string
    externalId?: StringNullableWithAggregatesFilter<"Trace"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Trace"> | Date | string
    name?: StringNullableWithAggregatesFilter<"Trace"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Trace"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Trace">
    release?: StringNullableWithAggregatesFilter<"Trace"> | string | null
    version?: StringNullableWithAggregatesFilter<"Trace"> | string | null
    projectId?: StringWithAggregatesFilter<"Trace"> | string
    public?: BoolWithAggregatesFilter<"Trace"> | boolean
    bookmarked?: BoolWithAggregatesFilter<"Trace"> | boolean
    tags?: StringNullableListFilter<"Trace">
    input?: JsonNullableWithAggregatesFilter<"Trace">
    output?: JsonNullableWithAggregatesFilter<"Trace">
    sessionId?: StringNullableWithAggregatesFilter<"Trace"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Trace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trace"> | Date | string
  }

  export type ObservationWhereInput = {
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    id?: StringFilter<"Observation"> | string
    traceId?: StringNullableFilter<"Observation"> | string | null
    projectId?: StringFilter<"Observation"> | string
    type?: EnumObservationTypeFilter<"Observation"> | $Enums.ObservationType
    startTime?: DateTimeFilter<"Observation"> | Date | string
    endTime?: DateTimeNullableFilter<"Observation"> | Date | string | null
    name?: StringNullableFilter<"Observation"> | string | null
    metadata?: JsonNullableFilter<"Observation">
    parentObservationId?: StringNullableFilter<"Observation"> | string | null
    level?: EnumObservationLevelFilter<"Observation"> | $Enums.ObservationLevel
    statusMessage?: StringNullableFilter<"Observation"> | string | null
    version?: StringNullableFilter<"Observation"> | string | null
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    updatedAt?: DateTimeFilter<"Observation"> | Date | string
    model?: StringNullableFilter<"Observation"> | string | null
    internalModel?: StringNullableFilter<"Observation"> | string | null
    internalModelId?: StringNullableFilter<"Observation"> | string | null
    modelParameters?: JsonNullableFilter<"Observation">
    input?: JsonNullableFilter<"Observation">
    output?: JsonNullableFilter<"Observation">
    promptTokens?: IntFilter<"Observation"> | number
    completionTokens?: IntFilter<"Observation"> | number
    totalTokens?: IntFilter<"Observation"> | number
    unit?: StringNullableFilter<"Observation"> | string | null
    inputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: DateTimeNullableFilter<"Observation"> | Date | string | null
    promptId?: StringNullableFilter<"Observation"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ObservationOrderByWithRelationInput = {
    id?: SortOrder
    traceId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    parentObservationId?: SortOrderInput | SortOrder
    level?: SortOrder
    statusMessage?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrderInput | SortOrder
    internalModel?: SortOrderInput | SortOrder
    internalModelId?: SortOrderInput | SortOrder
    modelParameters?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrderInput | SortOrder
    inputCost?: SortOrderInput | SortOrder
    outputCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    calculatedInputCost?: SortOrderInput | SortOrder
    calculatedOutputCost?: SortOrderInput | SortOrder
    calculatedTotalCost?: SortOrderInput | SortOrder
    completionStartTime?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ObservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_projectId?: ObservationIdProjectIdCompoundUniqueInput
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    traceId?: StringNullableFilter<"Observation"> | string | null
    projectId?: StringFilter<"Observation"> | string
    type?: EnumObservationTypeFilter<"Observation"> | $Enums.ObservationType
    startTime?: DateTimeFilter<"Observation"> | Date | string
    endTime?: DateTimeNullableFilter<"Observation"> | Date | string | null
    name?: StringNullableFilter<"Observation"> | string | null
    metadata?: JsonNullableFilter<"Observation">
    parentObservationId?: StringNullableFilter<"Observation"> | string | null
    level?: EnumObservationLevelFilter<"Observation"> | $Enums.ObservationLevel
    statusMessage?: StringNullableFilter<"Observation"> | string | null
    version?: StringNullableFilter<"Observation"> | string | null
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    updatedAt?: DateTimeFilter<"Observation"> | Date | string
    model?: StringNullableFilter<"Observation"> | string | null
    internalModel?: StringNullableFilter<"Observation"> | string | null
    internalModelId?: StringNullableFilter<"Observation"> | string | null
    modelParameters?: JsonNullableFilter<"Observation">
    input?: JsonNullableFilter<"Observation">
    output?: JsonNullableFilter<"Observation">
    promptTokens?: IntFilter<"Observation"> | number
    completionTokens?: IntFilter<"Observation"> | number
    totalTokens?: IntFilter<"Observation"> | number
    unit?: StringNullableFilter<"Observation"> | string | null
    inputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: DateTimeNullableFilter<"Observation"> | Date | string | null
    promptId?: StringNullableFilter<"Observation"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "id_projectId">

  export type ObservationOrderByWithAggregationInput = {
    id?: SortOrder
    traceId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    parentObservationId?: SortOrderInput | SortOrder
    level?: SortOrder
    statusMessage?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrderInput | SortOrder
    internalModel?: SortOrderInput | SortOrder
    internalModelId?: SortOrderInput | SortOrder
    modelParameters?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrderInput | SortOrder
    inputCost?: SortOrderInput | SortOrder
    outputCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    calculatedInputCost?: SortOrderInput | SortOrder
    calculatedOutputCost?: SortOrderInput | SortOrder
    calculatedTotalCost?: SortOrderInput | SortOrder
    completionStartTime?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    _count?: ObservationCountOrderByAggregateInput
    _avg?: ObservationAvgOrderByAggregateInput
    _max?: ObservationMaxOrderByAggregateInput
    _min?: ObservationMinOrderByAggregateInput
    _sum?: ObservationSumOrderByAggregateInput
  }

  export type ObservationScalarWhereWithAggregatesInput = {
    AND?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    OR?: ObservationScalarWhereWithAggregatesInput[]
    NOT?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Observation"> | string
    traceId?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    projectId?: StringWithAggregatesFilter<"Observation"> | string
    type?: EnumObservationTypeWithAggregatesFilter<"Observation"> | $Enums.ObservationType
    startTime?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Observation"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Observation">
    parentObservationId?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    level?: EnumObservationLevelWithAggregatesFilter<"Observation"> | $Enums.ObservationLevel
    statusMessage?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    version?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
    model?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    internalModel?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    internalModelId?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    modelParameters?: JsonNullableWithAggregatesFilter<"Observation">
    input?: JsonNullableWithAggregatesFilter<"Observation">
    output?: JsonNullableWithAggregatesFilter<"Observation">
    promptTokens?: IntWithAggregatesFilter<"Observation"> | number
    completionTokens?: IntWithAggregatesFilter<"Observation"> | number
    totalTokens?: IntWithAggregatesFilter<"Observation"> | number
    unit?: StringNullableWithAggregatesFilter<"Observation"> | string | null
    inputCost?: DecimalNullableWithAggregatesFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableWithAggregatesFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableWithAggregatesFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableWithAggregatesFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableWithAggregatesFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: DateTimeNullableWithAggregatesFilter<"Observation"> | Date | string | null
    promptId?: StringNullableWithAggregatesFilter<"Observation"> | string | null
  }

  export type ScoreWhereInput = {
    AND?: ScoreWhereInput | ScoreWhereInput[]
    OR?: ScoreWhereInput[]
    NOT?: ScoreWhereInput | ScoreWhereInput[]
    id?: StringFilter<"Score"> | string
    timestamp?: DateTimeFilter<"Score"> | Date | string
    projectId?: StringFilter<"Score"> | string
    name?: StringFilter<"Score"> | string
    value?: FloatNullableFilter<"Score"> | number | null
    source?: EnumScoreSourceFilter<"Score"> | $Enums.ScoreSource
    authorUserId?: StringNullableFilter<"Score"> | string | null
    comment?: StringNullableFilter<"Score"> | string | null
    traceId?: StringFilter<"Score"> | string
    observationId?: StringNullableFilter<"Score"> | string | null
    configId?: StringNullableFilter<"Score"> | string | null
    stringValue?: StringNullableFilter<"Score"> | string | null
    queueId?: StringNullableFilter<"Score"> | string | null
    createdAt?: DateTimeFilter<"Score"> | Date | string
    updatedAt?: DateTimeFilter<"Score"> | Date | string
    dataType?: EnumScoreDataTypeFilter<"Score"> | $Enums.ScoreDataType
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    scoreConfig?: XOR<ScoreConfigNullableRelationFilter, ScoreConfigWhereInput> | null
  }

  export type ScoreOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrderInput | SortOrder
    source?: SortOrder
    authorUserId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    traceId?: SortOrder
    observationId?: SortOrderInput | SortOrder
    configId?: SortOrderInput | SortOrder
    stringValue?: SortOrderInput | SortOrder
    queueId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataType?: SortOrder
    project?: ProjectOrderByWithRelationInput
    scoreConfig?: ScoreConfigOrderByWithRelationInput
  }

  export type ScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_projectId?: ScoreIdProjectIdCompoundUniqueInput
    AND?: ScoreWhereInput | ScoreWhereInput[]
    OR?: ScoreWhereInput[]
    NOT?: ScoreWhereInput | ScoreWhereInput[]
    timestamp?: DateTimeFilter<"Score"> | Date | string
    projectId?: StringFilter<"Score"> | string
    name?: StringFilter<"Score"> | string
    value?: FloatNullableFilter<"Score"> | number | null
    source?: EnumScoreSourceFilter<"Score"> | $Enums.ScoreSource
    authorUserId?: StringNullableFilter<"Score"> | string | null
    comment?: StringNullableFilter<"Score"> | string | null
    traceId?: StringFilter<"Score"> | string
    observationId?: StringNullableFilter<"Score"> | string | null
    configId?: StringNullableFilter<"Score"> | string | null
    stringValue?: StringNullableFilter<"Score"> | string | null
    queueId?: StringNullableFilter<"Score"> | string | null
    createdAt?: DateTimeFilter<"Score"> | Date | string
    updatedAt?: DateTimeFilter<"Score"> | Date | string
    dataType?: EnumScoreDataTypeFilter<"Score"> | $Enums.ScoreDataType
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    scoreConfig?: XOR<ScoreConfigNullableRelationFilter, ScoreConfigWhereInput> | null
  }, "id" | "id_projectId">

  export type ScoreOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrderInput | SortOrder
    source?: SortOrder
    authorUserId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    traceId?: SortOrder
    observationId?: SortOrderInput | SortOrder
    configId?: SortOrderInput | SortOrder
    stringValue?: SortOrderInput | SortOrder
    queueId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataType?: SortOrder
    _count?: ScoreCountOrderByAggregateInput
    _avg?: ScoreAvgOrderByAggregateInput
    _max?: ScoreMaxOrderByAggregateInput
    _min?: ScoreMinOrderByAggregateInput
    _sum?: ScoreSumOrderByAggregateInput
  }

  export type ScoreScalarWhereWithAggregatesInput = {
    AND?: ScoreScalarWhereWithAggregatesInput | ScoreScalarWhereWithAggregatesInput[]
    OR?: ScoreScalarWhereWithAggregatesInput[]
    NOT?: ScoreScalarWhereWithAggregatesInput | ScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Score"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Score"> | Date | string
    projectId?: StringWithAggregatesFilter<"Score"> | string
    name?: StringWithAggregatesFilter<"Score"> | string
    value?: FloatNullableWithAggregatesFilter<"Score"> | number | null
    source?: EnumScoreSourceWithAggregatesFilter<"Score"> | $Enums.ScoreSource
    authorUserId?: StringNullableWithAggregatesFilter<"Score"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Score"> | string | null
    traceId?: StringWithAggregatesFilter<"Score"> | string
    observationId?: StringNullableWithAggregatesFilter<"Score"> | string | null
    configId?: StringNullableWithAggregatesFilter<"Score"> | string | null
    stringValue?: StringNullableWithAggregatesFilter<"Score"> | string | null
    queueId?: StringNullableWithAggregatesFilter<"Score"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Score"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Score"> | Date | string
    dataType?: EnumScoreDataTypeWithAggregatesFilter<"Score"> | $Enums.ScoreDataType
  }

  export type ScoreConfigWhereInput = {
    AND?: ScoreConfigWhereInput | ScoreConfigWhereInput[]
    OR?: ScoreConfigWhereInput[]
    NOT?: ScoreConfigWhereInput | ScoreConfigWhereInput[]
    id?: StringFilter<"ScoreConfig"> | string
    createdAt?: DateTimeFilter<"ScoreConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ScoreConfig"> | Date | string
    projectId?: StringFilter<"ScoreConfig"> | string
    name?: StringFilter<"ScoreConfig"> | string
    dataType?: EnumScoreDataTypeFilter<"ScoreConfig"> | $Enums.ScoreDataType
    isArchived?: BoolFilter<"ScoreConfig"> | boolean
    minValue?: FloatNullableFilter<"ScoreConfig"> | number | null
    maxValue?: FloatNullableFilter<"ScoreConfig"> | number | null
    categories?: JsonNullableFilter<"ScoreConfig">
    description?: StringNullableFilter<"ScoreConfig"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    score?: ScoreListRelationFilter
  }

  export type ScoreConfigOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    dataType?: SortOrder
    isArchived?: SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    score?: ScoreOrderByRelationAggregateInput
  }

  export type ScoreConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_projectId?: ScoreConfigIdProjectIdCompoundUniqueInput
    AND?: ScoreConfigWhereInput | ScoreConfigWhereInput[]
    OR?: ScoreConfigWhereInput[]
    NOT?: ScoreConfigWhereInput | ScoreConfigWhereInput[]
    createdAt?: DateTimeFilter<"ScoreConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ScoreConfig"> | Date | string
    projectId?: StringFilter<"ScoreConfig"> | string
    name?: StringFilter<"ScoreConfig"> | string
    dataType?: EnumScoreDataTypeFilter<"ScoreConfig"> | $Enums.ScoreDataType
    isArchived?: BoolFilter<"ScoreConfig"> | boolean
    minValue?: FloatNullableFilter<"ScoreConfig"> | number | null
    maxValue?: FloatNullableFilter<"ScoreConfig"> | number | null
    categories?: JsonNullableFilter<"ScoreConfig">
    description?: StringNullableFilter<"ScoreConfig"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    score?: ScoreListRelationFilter
  }, "id" | "id_projectId">

  export type ScoreConfigOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    dataType?: SortOrder
    isArchived?: SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ScoreConfigCountOrderByAggregateInput
    _avg?: ScoreConfigAvgOrderByAggregateInput
    _max?: ScoreConfigMaxOrderByAggregateInput
    _min?: ScoreConfigMinOrderByAggregateInput
    _sum?: ScoreConfigSumOrderByAggregateInput
  }

  export type ScoreConfigScalarWhereWithAggregatesInput = {
    AND?: ScoreConfigScalarWhereWithAggregatesInput | ScoreConfigScalarWhereWithAggregatesInput[]
    OR?: ScoreConfigScalarWhereWithAggregatesInput[]
    NOT?: ScoreConfigScalarWhereWithAggregatesInput | ScoreConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScoreConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScoreConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScoreConfig"> | Date | string
    projectId?: StringWithAggregatesFilter<"ScoreConfig"> | string
    name?: StringWithAggregatesFilter<"ScoreConfig"> | string
    dataType?: EnumScoreDataTypeWithAggregatesFilter<"ScoreConfig"> | $Enums.ScoreDataType
    isArchived?: BoolWithAggregatesFilter<"ScoreConfig"> | boolean
    minValue?: FloatNullableWithAggregatesFilter<"ScoreConfig"> | number | null
    maxValue?: FloatNullableWithAggregatesFilter<"ScoreConfig"> | number | null
    categories?: JsonNullableWithAggregatesFilter<"ScoreConfig">
    description?: StringNullableWithAggregatesFilter<"ScoreConfig"> | string | null
  }

  export type AnnotationQueueWhereInput = {
    AND?: AnnotationQueueWhereInput | AnnotationQueueWhereInput[]
    OR?: AnnotationQueueWhereInput[]
    NOT?: AnnotationQueueWhereInput | AnnotationQueueWhereInput[]
    id?: StringFilter<"AnnotationQueue"> | string
    name?: StringFilter<"AnnotationQueue"> | string
    description?: StringNullableFilter<"AnnotationQueue"> | string | null
    scoreConfigIds?: StringNullableListFilter<"AnnotationQueue">
    projectId?: StringFilter<"AnnotationQueue"> | string
    createdAt?: DateTimeFilter<"AnnotationQueue"> | Date | string
    updatedAt?: DateTimeFilter<"AnnotationQueue"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    annotationQueueItem?: AnnotationQueueItemListRelationFilter
  }

  export type AnnotationQueueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scoreConfigIds?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    annotationQueueItem?: AnnotationQueueItemOrderByRelationAggregateInput
  }

  export type AnnotationQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name?: AnnotationQueueProjectIdNameCompoundUniqueInput
    AND?: AnnotationQueueWhereInput | AnnotationQueueWhereInput[]
    OR?: AnnotationQueueWhereInput[]
    NOT?: AnnotationQueueWhereInput | AnnotationQueueWhereInput[]
    name?: StringFilter<"AnnotationQueue"> | string
    description?: StringNullableFilter<"AnnotationQueue"> | string | null
    scoreConfigIds?: StringNullableListFilter<"AnnotationQueue">
    projectId?: StringFilter<"AnnotationQueue"> | string
    createdAt?: DateTimeFilter<"AnnotationQueue"> | Date | string
    updatedAt?: DateTimeFilter<"AnnotationQueue"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    annotationQueueItem?: AnnotationQueueItemListRelationFilter
  }, "id" | "projectId_name">

  export type AnnotationQueueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scoreConfigIds?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnotationQueueCountOrderByAggregateInput
    _max?: AnnotationQueueMaxOrderByAggregateInput
    _min?: AnnotationQueueMinOrderByAggregateInput
  }

  export type AnnotationQueueScalarWhereWithAggregatesInput = {
    AND?: AnnotationQueueScalarWhereWithAggregatesInput | AnnotationQueueScalarWhereWithAggregatesInput[]
    OR?: AnnotationQueueScalarWhereWithAggregatesInput[]
    NOT?: AnnotationQueueScalarWhereWithAggregatesInput | AnnotationQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnnotationQueue"> | string
    name?: StringWithAggregatesFilter<"AnnotationQueue"> | string
    description?: StringNullableWithAggregatesFilter<"AnnotationQueue"> | string | null
    scoreConfigIds?: StringNullableListFilter<"AnnotationQueue">
    projectId?: StringWithAggregatesFilter<"AnnotationQueue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AnnotationQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnnotationQueue"> | Date | string
  }

  export type AnnotationQueueItemWhereInput = {
    AND?: AnnotationQueueItemWhereInput | AnnotationQueueItemWhereInput[]
    OR?: AnnotationQueueItemWhereInput[]
    NOT?: AnnotationQueueItemWhereInput | AnnotationQueueItemWhereInput[]
    id?: StringFilter<"AnnotationQueueItem"> | string
    queueId?: StringFilter<"AnnotationQueueItem"> | string
    objectId?: StringFilter<"AnnotationQueueItem"> | string
    objectType?: EnumAnnotationQueueObjectTypeFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueStatus
    lockedAt?: DateTimeNullableFilter<"AnnotationQueueItem"> | Date | string | null
    lockedByUserId?: StringNullableFilter<"AnnotationQueueItem"> | string | null
    annotatorUserId?: StringNullableFilter<"AnnotationQueueItem"> | string | null
    completedAt?: DateTimeNullableFilter<"AnnotationQueueItem"> | Date | string | null
    projectId?: StringFilter<"AnnotationQueueItem"> | string
    createdAt?: DateTimeFilter<"AnnotationQueueItem"> | Date | string
    updatedAt?: DateTimeFilter<"AnnotationQueueItem"> | Date | string
    queue?: XOR<AnnotationQueueRelationFilter, AnnotationQueueWhereInput>
    lockedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    annotatorUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type AnnotationQueueItemOrderByWithRelationInput = {
    id?: SortOrder
    queueId?: SortOrder
    objectId?: SortOrder
    objectType?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedByUserId?: SortOrderInput | SortOrder
    annotatorUserId?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    queue?: AnnotationQueueOrderByWithRelationInput
    lockedByUser?: UserOrderByWithRelationInput
    annotatorUser?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type AnnotationQueueItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnotationQueueItemWhereInput | AnnotationQueueItemWhereInput[]
    OR?: AnnotationQueueItemWhereInput[]
    NOT?: AnnotationQueueItemWhereInput | AnnotationQueueItemWhereInput[]
    queueId?: StringFilter<"AnnotationQueueItem"> | string
    objectId?: StringFilter<"AnnotationQueueItem"> | string
    objectType?: EnumAnnotationQueueObjectTypeFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueStatus
    lockedAt?: DateTimeNullableFilter<"AnnotationQueueItem"> | Date | string | null
    lockedByUserId?: StringNullableFilter<"AnnotationQueueItem"> | string | null
    annotatorUserId?: StringNullableFilter<"AnnotationQueueItem"> | string | null
    completedAt?: DateTimeNullableFilter<"AnnotationQueueItem"> | Date | string | null
    projectId?: StringFilter<"AnnotationQueueItem"> | string
    createdAt?: DateTimeFilter<"AnnotationQueueItem"> | Date | string
    updatedAt?: DateTimeFilter<"AnnotationQueueItem"> | Date | string
    queue?: XOR<AnnotationQueueRelationFilter, AnnotationQueueWhereInput>
    lockedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    annotatorUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type AnnotationQueueItemOrderByWithAggregationInput = {
    id?: SortOrder
    queueId?: SortOrder
    objectId?: SortOrder
    objectType?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedByUserId?: SortOrderInput | SortOrder
    annotatorUserId?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnotationQueueItemCountOrderByAggregateInput
    _max?: AnnotationQueueItemMaxOrderByAggregateInput
    _min?: AnnotationQueueItemMinOrderByAggregateInput
  }

  export type AnnotationQueueItemScalarWhereWithAggregatesInput = {
    AND?: AnnotationQueueItemScalarWhereWithAggregatesInput | AnnotationQueueItemScalarWhereWithAggregatesInput[]
    OR?: AnnotationQueueItemScalarWhereWithAggregatesInput[]
    NOT?: AnnotationQueueItemScalarWhereWithAggregatesInput | AnnotationQueueItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnnotationQueueItem"> | string
    queueId?: StringWithAggregatesFilter<"AnnotationQueueItem"> | string
    objectId?: StringWithAggregatesFilter<"AnnotationQueueItem"> | string
    objectType?: EnumAnnotationQueueObjectTypeWithAggregatesFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusWithAggregatesFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueStatus
    lockedAt?: DateTimeNullableWithAggregatesFilter<"AnnotationQueueItem"> | Date | string | null
    lockedByUserId?: StringNullableWithAggregatesFilter<"AnnotationQueueItem"> | string | null
    annotatorUserId?: StringNullableWithAggregatesFilter<"AnnotationQueueItem"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AnnotationQueueItem"> | Date | string | null
    projectId?: StringWithAggregatesFilter<"AnnotationQueueItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AnnotationQueueItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnnotationQueueItem"> | Date | string
  }

  export type CronJobsWhereInput = {
    AND?: CronJobsWhereInput | CronJobsWhereInput[]
    OR?: CronJobsWhereInput[]
    NOT?: CronJobsWhereInput | CronJobsWhereInput[]
    name?: StringFilter<"CronJobs"> | string
    lastRun?: DateTimeNullableFilter<"CronJobs"> | Date | string | null
    jobStartedAt?: DateTimeNullableFilter<"CronJobs"> | Date | string | null
    state?: StringNullableFilter<"CronJobs"> | string | null
  }

  export type CronJobsOrderByWithRelationInput = {
    name?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    jobStartedAt?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
  }

  export type CronJobsWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: CronJobsWhereInput | CronJobsWhereInput[]
    OR?: CronJobsWhereInput[]
    NOT?: CronJobsWhereInput | CronJobsWhereInput[]
    lastRun?: DateTimeNullableFilter<"CronJobs"> | Date | string | null
    jobStartedAt?: DateTimeNullableFilter<"CronJobs"> | Date | string | null
    state?: StringNullableFilter<"CronJobs"> | string | null
  }, "name">

  export type CronJobsOrderByWithAggregationInput = {
    name?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    jobStartedAt?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    _count?: CronJobsCountOrderByAggregateInput
    _max?: CronJobsMaxOrderByAggregateInput
    _min?: CronJobsMinOrderByAggregateInput
  }

  export type CronJobsScalarWhereWithAggregatesInput = {
    AND?: CronJobsScalarWhereWithAggregatesInput | CronJobsScalarWhereWithAggregatesInput[]
    OR?: CronJobsScalarWhereWithAggregatesInput[]
    NOT?: CronJobsScalarWhereWithAggregatesInput | CronJobsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"CronJobs"> | string
    lastRun?: DateTimeNullableWithAggregatesFilter<"CronJobs"> | Date | string | null
    jobStartedAt?: DateTimeNullableWithAggregatesFilter<"CronJobs"> | Date | string | null
    state?: StringNullableWithAggregatesFilter<"CronJobs"> | string | null
  }

  export type DatasetWhereInput = {
    AND?: DatasetWhereInput | DatasetWhereInput[]
    OR?: DatasetWhereInput[]
    NOT?: DatasetWhereInput | DatasetWhereInput[]
    id?: StringFilter<"Dataset"> | string
    projectId?: StringFilter<"Dataset"> | string
    name?: StringFilter<"Dataset"> | string
    description?: StringNullableFilter<"Dataset"> | string | null
    metadata?: JsonNullableFilter<"Dataset">
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    datasetItems?: DatasetItemListRelationFilter
    datasetRuns?: DatasetRunsListRelationFilter
  }

  export type DatasetOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    datasetItems?: DatasetItemOrderByRelationAggregateInput
    datasetRuns?: DatasetRunsOrderByRelationAggregateInput
  }

  export type DatasetWhereUniqueInput = Prisma.AtLeast<{
    projectId_name?: DatasetProjectIdNameCompoundUniqueInput
    id_projectId?: DatasetIdProjectIdCompoundUniqueInput
    AND?: DatasetWhereInput | DatasetWhereInput[]
    OR?: DatasetWhereInput[]
    NOT?: DatasetWhereInput | DatasetWhereInput[]
    id?: StringFilter<"Dataset"> | string
    projectId?: StringFilter<"Dataset"> | string
    name?: StringFilter<"Dataset"> | string
    description?: StringNullableFilter<"Dataset"> | string | null
    metadata?: JsonNullableFilter<"Dataset">
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    datasetItems?: DatasetItemListRelationFilter
    datasetRuns?: DatasetRunsListRelationFilter
  }, "id_projectId" | "projectId_name">

  export type DatasetOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatasetCountOrderByAggregateInput
    _max?: DatasetMaxOrderByAggregateInput
    _min?: DatasetMinOrderByAggregateInput
  }

  export type DatasetScalarWhereWithAggregatesInput = {
    AND?: DatasetScalarWhereWithAggregatesInput | DatasetScalarWhereWithAggregatesInput[]
    OR?: DatasetScalarWhereWithAggregatesInput[]
    NOT?: DatasetScalarWhereWithAggregatesInput | DatasetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dataset"> | string
    projectId?: StringWithAggregatesFilter<"Dataset"> | string
    name?: StringWithAggregatesFilter<"Dataset"> | string
    description?: StringNullableWithAggregatesFilter<"Dataset"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Dataset">
    createdAt?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
  }

  export type DatasetItemWhereInput = {
    AND?: DatasetItemWhereInput | DatasetItemWhereInput[]
    OR?: DatasetItemWhereInput[]
    NOT?: DatasetItemWhereInput | DatasetItemWhereInput[]
    id?: StringFilter<"DatasetItem"> | string
    projectId?: StringFilter<"DatasetItem"> | string
    status?: EnumDatasetStatusFilter<"DatasetItem"> | $Enums.DatasetStatus
    input?: JsonNullableFilter<"DatasetItem">
    expectedOutput?: JsonNullableFilter<"DatasetItem">
    metadata?: JsonNullableFilter<"DatasetItem">
    sourceTraceId?: StringNullableFilter<"DatasetItem"> | string | null
    sourceObservationId?: StringNullableFilter<"DatasetItem"> | string | null
    datasetId?: StringFilter<"DatasetItem"> | string
    createdAt?: DateTimeFilter<"DatasetItem"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetItem"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
    datasetRunItems?: DatasetRunItemsListRelationFilter
  }

  export type DatasetItemOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    input?: SortOrderInput | SortOrder
    expectedOutput?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sourceTraceId?: SortOrderInput | SortOrder
    sourceObservationId?: SortOrderInput | SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataset?: DatasetOrderByWithRelationInput
    datasetRunItems?: DatasetRunItemsOrderByRelationAggregateInput
  }

  export type DatasetItemWhereUniqueInput = Prisma.AtLeast<{
    id_projectId?: DatasetItemIdProjectIdCompoundUniqueInput
    AND?: DatasetItemWhereInput | DatasetItemWhereInput[]
    OR?: DatasetItemWhereInput[]
    NOT?: DatasetItemWhereInput | DatasetItemWhereInput[]
    id?: StringFilter<"DatasetItem"> | string
    projectId?: StringFilter<"DatasetItem"> | string
    status?: EnumDatasetStatusFilter<"DatasetItem"> | $Enums.DatasetStatus
    input?: JsonNullableFilter<"DatasetItem">
    expectedOutput?: JsonNullableFilter<"DatasetItem">
    metadata?: JsonNullableFilter<"DatasetItem">
    sourceTraceId?: StringNullableFilter<"DatasetItem"> | string | null
    sourceObservationId?: StringNullableFilter<"DatasetItem"> | string | null
    datasetId?: StringFilter<"DatasetItem"> | string
    createdAt?: DateTimeFilter<"DatasetItem"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetItem"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
    datasetRunItems?: DatasetRunItemsListRelationFilter
  }, "id_projectId">

  export type DatasetItemOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    input?: SortOrderInput | SortOrder
    expectedOutput?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sourceTraceId?: SortOrderInput | SortOrder
    sourceObservationId?: SortOrderInput | SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatasetItemCountOrderByAggregateInput
    _max?: DatasetItemMaxOrderByAggregateInput
    _min?: DatasetItemMinOrderByAggregateInput
  }

  export type DatasetItemScalarWhereWithAggregatesInput = {
    AND?: DatasetItemScalarWhereWithAggregatesInput | DatasetItemScalarWhereWithAggregatesInput[]
    OR?: DatasetItemScalarWhereWithAggregatesInput[]
    NOT?: DatasetItemScalarWhereWithAggregatesInput | DatasetItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatasetItem"> | string
    projectId?: StringWithAggregatesFilter<"DatasetItem"> | string
    status?: EnumDatasetStatusWithAggregatesFilter<"DatasetItem"> | $Enums.DatasetStatus
    input?: JsonNullableWithAggregatesFilter<"DatasetItem">
    expectedOutput?: JsonNullableWithAggregatesFilter<"DatasetItem">
    metadata?: JsonNullableWithAggregatesFilter<"DatasetItem">
    sourceTraceId?: StringNullableWithAggregatesFilter<"DatasetItem"> | string | null
    sourceObservationId?: StringNullableWithAggregatesFilter<"DatasetItem"> | string | null
    datasetId?: StringWithAggregatesFilter<"DatasetItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DatasetItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatasetItem"> | Date | string
  }

  export type DatasetRunsWhereInput = {
    AND?: DatasetRunsWhereInput | DatasetRunsWhereInput[]
    OR?: DatasetRunsWhereInput[]
    NOT?: DatasetRunsWhereInput | DatasetRunsWhereInput[]
    id?: StringFilter<"DatasetRuns"> | string
    projectId?: StringFilter<"DatasetRuns"> | string
    name?: StringFilter<"DatasetRuns"> | string
    description?: StringNullableFilter<"DatasetRuns"> | string | null
    metadata?: JsonNullableFilter<"DatasetRuns">
    datasetId?: StringFilter<"DatasetRuns"> | string
    createdAt?: DateTimeFilter<"DatasetRuns"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetRuns"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
    datasetRunItems?: DatasetRunItemsListRelationFilter
  }

  export type DatasetRunsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataset?: DatasetOrderByWithRelationInput
    datasetRunItems?: DatasetRunItemsOrderByRelationAggregateInput
  }

  export type DatasetRunsWhereUniqueInput = Prisma.AtLeast<{
    datasetId_projectId_name?: DatasetRunsDatasetIdProjectIdNameCompoundUniqueInput
    id_projectId?: DatasetRunsIdProjectIdCompoundUniqueInput
    AND?: DatasetRunsWhereInput | DatasetRunsWhereInput[]
    OR?: DatasetRunsWhereInput[]
    NOT?: DatasetRunsWhereInput | DatasetRunsWhereInput[]
    id?: StringFilter<"DatasetRuns"> | string
    projectId?: StringFilter<"DatasetRuns"> | string
    name?: StringFilter<"DatasetRuns"> | string
    description?: StringNullableFilter<"DatasetRuns"> | string | null
    metadata?: JsonNullableFilter<"DatasetRuns">
    datasetId?: StringFilter<"DatasetRuns"> | string
    createdAt?: DateTimeFilter<"DatasetRuns"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetRuns"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
    datasetRunItems?: DatasetRunItemsListRelationFilter
  }, "id_projectId" | "datasetId_projectId_name">

  export type DatasetRunsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatasetRunsCountOrderByAggregateInput
    _max?: DatasetRunsMaxOrderByAggregateInput
    _min?: DatasetRunsMinOrderByAggregateInput
  }

  export type DatasetRunsScalarWhereWithAggregatesInput = {
    AND?: DatasetRunsScalarWhereWithAggregatesInput | DatasetRunsScalarWhereWithAggregatesInput[]
    OR?: DatasetRunsScalarWhereWithAggregatesInput[]
    NOT?: DatasetRunsScalarWhereWithAggregatesInput | DatasetRunsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatasetRuns"> | string
    projectId?: StringWithAggregatesFilter<"DatasetRuns"> | string
    name?: StringWithAggregatesFilter<"DatasetRuns"> | string
    description?: StringNullableWithAggregatesFilter<"DatasetRuns"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"DatasetRuns">
    datasetId?: StringWithAggregatesFilter<"DatasetRuns"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DatasetRuns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatasetRuns"> | Date | string
  }

  export type DatasetRunItemsWhereInput = {
    AND?: DatasetRunItemsWhereInput | DatasetRunItemsWhereInput[]
    OR?: DatasetRunItemsWhereInput[]
    NOT?: DatasetRunItemsWhereInput | DatasetRunItemsWhereInput[]
    id?: StringFilter<"DatasetRunItems"> | string
    projectId?: StringFilter<"DatasetRunItems"> | string
    datasetRunId?: StringFilter<"DatasetRunItems"> | string
    datasetItemId?: StringFilter<"DatasetRunItems"> | string
    traceId?: StringFilter<"DatasetRunItems"> | string
    observationId?: StringNullableFilter<"DatasetRunItems"> | string | null
    createdAt?: DateTimeFilter<"DatasetRunItems"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetRunItems"> | Date | string
    datasetRun?: XOR<DatasetRunsRelationFilter, DatasetRunsWhereInput>
    datasetItem?: XOR<DatasetItemRelationFilter, DatasetItemWhereInput>
  }

  export type DatasetRunItemsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    datasetRunId?: SortOrder
    datasetItemId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    datasetRun?: DatasetRunsOrderByWithRelationInput
    datasetItem?: DatasetItemOrderByWithRelationInput
  }

  export type DatasetRunItemsWhereUniqueInput = Prisma.AtLeast<{
    id_projectId?: DatasetRunItemsIdProjectIdCompoundUniqueInput
    AND?: DatasetRunItemsWhereInput | DatasetRunItemsWhereInput[]
    OR?: DatasetRunItemsWhereInput[]
    NOT?: DatasetRunItemsWhereInput | DatasetRunItemsWhereInput[]
    id?: StringFilter<"DatasetRunItems"> | string
    projectId?: StringFilter<"DatasetRunItems"> | string
    datasetRunId?: StringFilter<"DatasetRunItems"> | string
    datasetItemId?: StringFilter<"DatasetRunItems"> | string
    traceId?: StringFilter<"DatasetRunItems"> | string
    observationId?: StringNullableFilter<"DatasetRunItems"> | string | null
    createdAt?: DateTimeFilter<"DatasetRunItems"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetRunItems"> | Date | string
    datasetRun?: XOR<DatasetRunsRelationFilter, DatasetRunsWhereInput>
    datasetItem?: XOR<DatasetItemRelationFilter, DatasetItemWhereInput>
  }, "id_projectId">

  export type DatasetRunItemsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    datasetRunId?: SortOrder
    datasetItemId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatasetRunItemsCountOrderByAggregateInput
    _max?: DatasetRunItemsMaxOrderByAggregateInput
    _min?: DatasetRunItemsMinOrderByAggregateInput
  }

  export type DatasetRunItemsScalarWhereWithAggregatesInput = {
    AND?: DatasetRunItemsScalarWhereWithAggregatesInput | DatasetRunItemsScalarWhereWithAggregatesInput[]
    OR?: DatasetRunItemsScalarWhereWithAggregatesInput[]
    NOT?: DatasetRunItemsScalarWhereWithAggregatesInput | DatasetRunItemsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatasetRunItems"> | string
    projectId?: StringWithAggregatesFilter<"DatasetRunItems"> | string
    datasetRunId?: StringWithAggregatesFilter<"DatasetRunItems"> | string
    datasetItemId?: StringWithAggregatesFilter<"DatasetRunItems"> | string
    traceId?: StringWithAggregatesFilter<"DatasetRunItems"> | string
    observationId?: StringNullableWithAggregatesFilter<"DatasetRunItems"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DatasetRunItems"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatasetRunItems"> | Date | string
  }

  export type EventsWhereInput = {
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    id?: StringFilter<"Events"> | string
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
    projectId?: StringFilter<"Events"> | string
    data?: JsonFilter<"Events">
    headers?: JsonFilter<"Events">
    url?: StringNullableFilter<"Events"> | string | null
    method?: StringNullableFilter<"Events"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    data?: SortOrder
    headers?: SortOrder
    url?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type EventsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
    projectId?: StringFilter<"Events"> | string
    data?: JsonFilter<"Events">
    headers?: JsonFilter<"Events">
    url?: StringNullableFilter<"Events"> | string | null
    method?: StringNullableFilter<"Events"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    data?: SortOrder
    headers?: SortOrder
    url?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    _count?: EventsCountOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    OR?: EventsScalarWhereWithAggregatesInput[]
    NOT?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Events"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    projectId?: StringWithAggregatesFilter<"Events"> | string
    data?: JsonWithAggregatesFilter<"Events">
    headers?: JsonWithAggregatesFilter<"Events">
    url?: StringNullableWithAggregatesFilter<"Events"> | string | null
    method?: StringNullableWithAggregatesFilter<"Events"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    projectId?: StringFilter<"Comment"> | string
    objectType?: EnumCommentObjectTypeFilter<"Comment"> | $Enums.CommentObjectType
    objectId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    authorUserId?: StringNullableFilter<"Comment"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    authorUserId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    projectId?: StringFilter<"Comment"> | string
    objectType?: EnumCommentObjectTypeFilter<"Comment"> | $Enums.CommentObjectType
    objectId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    authorUserId?: StringNullableFilter<"Comment"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    authorUserId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    projectId?: StringWithAggregatesFilter<"Comment"> | string
    objectType?: EnumCommentObjectTypeWithAggregatesFilter<"Comment"> | $Enums.CommentObjectType
    objectId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    authorUserId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type PromptWhereInput = {
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    id?: StringFilter<"Prompt"> | string
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    projectId?: StringFilter<"Prompt"> | string
    createdBy?: StringFilter<"Prompt"> | string
    prompt?: JsonFilter<"Prompt">
    name?: StringFilter<"Prompt"> | string
    version?: IntFilter<"Prompt"> | number
    type?: StringFilter<"Prompt"> | string
    isActive?: BoolNullableFilter<"Prompt"> | boolean | null
    config?: JsonFilter<"Prompt">
    tags?: StringNullableListFilter<"Prompt">
    labels?: StringNullableListFilter<"Prompt">
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type PromptOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    prompt?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isActive?: SortOrderInput | SortOrder
    config?: SortOrder
    tags?: SortOrder
    labels?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type PromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name_version?: PromptProjectIdNameVersionCompoundUniqueInput
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    projectId?: StringFilter<"Prompt"> | string
    createdBy?: StringFilter<"Prompt"> | string
    prompt?: JsonFilter<"Prompt">
    name?: StringFilter<"Prompt"> | string
    version?: IntFilter<"Prompt"> | number
    type?: StringFilter<"Prompt"> | string
    isActive?: BoolNullableFilter<"Prompt"> | boolean | null
    config?: JsonFilter<"Prompt">
    tags?: StringNullableListFilter<"Prompt">
    labels?: StringNullableListFilter<"Prompt">
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_name_version">

  export type PromptOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    prompt?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isActive?: SortOrderInput | SortOrder
    config?: SortOrder
    tags?: SortOrder
    labels?: SortOrder
    _count?: PromptCountOrderByAggregateInput
    _avg?: PromptAvgOrderByAggregateInput
    _max?: PromptMaxOrderByAggregateInput
    _min?: PromptMinOrderByAggregateInput
    _sum?: PromptSumOrderByAggregateInput
  }

  export type PromptScalarWhereWithAggregatesInput = {
    AND?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    OR?: PromptScalarWhereWithAggregatesInput[]
    NOT?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prompt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    projectId?: StringWithAggregatesFilter<"Prompt"> | string
    createdBy?: StringWithAggregatesFilter<"Prompt"> | string
    prompt?: JsonWithAggregatesFilter<"Prompt">
    name?: StringWithAggregatesFilter<"Prompt"> | string
    version?: IntWithAggregatesFilter<"Prompt"> | number
    type?: StringWithAggregatesFilter<"Prompt"> | string
    isActive?: BoolNullableWithAggregatesFilter<"Prompt"> | boolean | null
    config?: JsonWithAggregatesFilter<"Prompt">
    tags?: StringNullableListFilter<"Prompt">
    labels?: StringNullableListFilter<"Prompt">
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    projectId?: StringNullableFilter<"Model"> | string | null
    modelName?: StringFilter<"Model"> | string
    matchPattern?: StringFilter<"Model"> | string
    startDate?: DateTimeNullableFilter<"Model"> | Date | string | null
    inputPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"Model"> | string | null
    tokenizerId?: StringNullableFilter<"Model"> | string | null
    tokenizerConfig?: JsonNullableFilter<"Model">
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    Price?: PriceListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    modelName?: SortOrder
    matchPattern?: SortOrder
    startDate?: SortOrderInput | SortOrder
    inputPrice?: SortOrderInput | SortOrder
    outputPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    tokenizerId?: SortOrderInput | SortOrder
    tokenizerConfig?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    Price?: PriceOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_modelName_startDate_unit?: ModelProjectIdModelNameStartDateUnitCompoundUniqueInput
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    projectId?: StringNullableFilter<"Model"> | string | null
    modelName?: StringFilter<"Model"> | string
    matchPattern?: StringFilter<"Model"> | string
    startDate?: DateTimeNullableFilter<"Model"> | Date | string | null
    inputPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"Model"> | string | null
    tokenizerId?: StringNullableFilter<"Model"> | string | null
    tokenizerConfig?: JsonNullableFilter<"Model">
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    Price?: PriceListRelationFilter
  }, "id" | "projectId_modelName_startDate_unit">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    modelName?: SortOrder
    matchPattern?: SortOrder
    startDate?: SortOrderInput | SortOrder
    inputPrice?: SortOrderInput | SortOrder
    outputPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    tokenizerId?: SortOrderInput | SortOrder
    tokenizerConfig?: SortOrderInput | SortOrder
    _count?: ModelCountOrderByAggregateInput
    _avg?: ModelAvgOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
    _sum?: ModelSumOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Model"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    projectId?: StringNullableWithAggregatesFilter<"Model"> | string | null
    modelName?: StringWithAggregatesFilter<"Model"> | string
    matchPattern?: StringWithAggregatesFilter<"Model"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Model"> | Date | string | null
    inputPrice?: DecimalNullableWithAggregatesFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableWithAggregatesFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"Model"> | string | null
    tokenizerId?: StringNullableWithAggregatesFilter<"Model"> | string | null
    tokenizerConfig?: JsonNullableWithAggregatesFilter<"Model">
  }

  export type PriceWhereInput = {
    AND?: PriceWhereInput | PriceWhereInput[]
    OR?: PriceWhereInput[]
    NOT?: PriceWhereInput | PriceWhereInput[]
    id?: StringFilter<"Price"> | string
    createdAt?: DateTimeFilter<"Price"> | Date | string
    updatedAt?: DateTimeFilter<"Price"> | Date | string
    modelId?: StringFilter<"Price"> | string
    usageType?: StringFilter<"Price"> | string
    price?: DecimalFilter<"Price"> | Decimal | DecimalJsLike | number | string
    Model?: XOR<ModelRelationFilter, ModelWhereInput>
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modelId?: SortOrder
    usageType?: SortOrder
    price?: SortOrder
    Model?: ModelOrderByWithRelationInput
  }

  export type PriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    modelId_usageType?: PriceModelIdUsageTypeCompoundUniqueInput
    AND?: PriceWhereInput | PriceWhereInput[]
    OR?: PriceWhereInput[]
    NOT?: PriceWhereInput | PriceWhereInput[]
    createdAt?: DateTimeFilter<"Price"> | Date | string
    updatedAt?: DateTimeFilter<"Price"> | Date | string
    modelId?: StringFilter<"Price"> | string
    usageType?: StringFilter<"Price"> | string
    price?: DecimalFilter<"Price"> | Decimal | DecimalJsLike | number | string
    Model?: XOR<ModelRelationFilter, ModelWhereInput>
  }, "id" | "modelId_usageType">

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modelId?: SortOrder
    usageType?: SortOrder
    price?: SortOrder
    _count?: PriceCountOrderByAggregateInput
    _avg?: PriceAvgOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
    _sum?: PriceSumOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: PriceScalarWhereWithAggregatesInput | PriceScalarWhereWithAggregatesInput[]
    OR?: PriceScalarWhereWithAggregatesInput[]
    NOT?: PriceScalarWhereWithAggregatesInput | PriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Price"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Price"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Price"> | Date | string
    modelId?: StringWithAggregatesFilter<"Price"> | string
    usageType?: StringWithAggregatesFilter<"Price"> | string
    price?: DecimalWithAggregatesFilter<"Price"> | Decimal | DecimalJsLike | number | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    updatedAt?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringFilter<"AuditLog"> | string
    orgId?: StringFilter<"AuditLog"> | string
    userOrgRole?: StringFilter<"AuditLog"> | string
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    userProjectRole?: StringNullableFilter<"AuditLog"> | string | null
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    before?: StringNullableFilter<"AuditLog"> | string | null
    after?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    userOrgRole?: SortOrder
    projectId?: SortOrderInput | SortOrder
    userProjectRole?: SortOrderInput | SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    updatedAt?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringFilter<"AuditLog"> | string
    orgId?: StringFilter<"AuditLog"> | string
    userOrgRole?: StringFilter<"AuditLog"> | string
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    userProjectRole?: StringNullableFilter<"AuditLog"> | string | null
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    before?: StringNullableFilter<"AuditLog"> | string | null
    after?: StringNullableFilter<"AuditLog"> | string | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    userOrgRole?: SortOrder
    projectId?: SortOrderInput | SortOrder
    userProjectRole?: SortOrderInput | SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    orgId?: StringWithAggregatesFilter<"AuditLog"> | string
    userOrgRole?: StringWithAggregatesFilter<"AuditLog"> | string
    projectId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userProjectRole?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceType?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    before?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    after?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type EvalTemplateWhereInput = {
    AND?: EvalTemplateWhereInput | EvalTemplateWhereInput[]
    OR?: EvalTemplateWhereInput[]
    NOT?: EvalTemplateWhereInput | EvalTemplateWhereInput[]
    id?: StringFilter<"EvalTemplate"> | string
    createdAt?: DateTimeFilter<"EvalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EvalTemplate"> | Date | string
    projectId?: StringFilter<"EvalTemplate"> | string
    name?: StringFilter<"EvalTemplate"> | string
    version?: IntFilter<"EvalTemplate"> | number
    prompt?: StringFilter<"EvalTemplate"> | string
    model?: StringFilter<"EvalTemplate"> | string
    provider?: StringFilter<"EvalTemplate"> | string
    modelParams?: JsonFilter<"EvalTemplate">
    vars?: StringNullableListFilter<"EvalTemplate">
    outputSchema?: JsonFilter<"EvalTemplate">
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    JobConfiguration?: JobConfigurationListRelationFilter
  }

  export type EvalTemplateOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    modelParams?: SortOrder
    vars?: SortOrder
    outputSchema?: SortOrder
    project?: ProjectOrderByWithRelationInput
    JobConfiguration?: JobConfigurationOrderByRelationAggregateInput
  }

  export type EvalTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name_version?: EvalTemplateProjectIdNameVersionCompoundUniqueInput
    AND?: EvalTemplateWhereInput | EvalTemplateWhereInput[]
    OR?: EvalTemplateWhereInput[]
    NOT?: EvalTemplateWhereInput | EvalTemplateWhereInput[]
    createdAt?: DateTimeFilter<"EvalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EvalTemplate"> | Date | string
    projectId?: StringFilter<"EvalTemplate"> | string
    name?: StringFilter<"EvalTemplate"> | string
    version?: IntFilter<"EvalTemplate"> | number
    prompt?: StringFilter<"EvalTemplate"> | string
    model?: StringFilter<"EvalTemplate"> | string
    provider?: StringFilter<"EvalTemplate"> | string
    modelParams?: JsonFilter<"EvalTemplate">
    vars?: StringNullableListFilter<"EvalTemplate">
    outputSchema?: JsonFilter<"EvalTemplate">
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    JobConfiguration?: JobConfigurationListRelationFilter
  }, "id" | "projectId_name_version">

  export type EvalTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    modelParams?: SortOrder
    vars?: SortOrder
    outputSchema?: SortOrder
    _count?: EvalTemplateCountOrderByAggregateInput
    _avg?: EvalTemplateAvgOrderByAggregateInput
    _max?: EvalTemplateMaxOrderByAggregateInput
    _min?: EvalTemplateMinOrderByAggregateInput
    _sum?: EvalTemplateSumOrderByAggregateInput
  }

  export type EvalTemplateScalarWhereWithAggregatesInput = {
    AND?: EvalTemplateScalarWhereWithAggregatesInput | EvalTemplateScalarWhereWithAggregatesInput[]
    OR?: EvalTemplateScalarWhereWithAggregatesInput[]
    NOT?: EvalTemplateScalarWhereWithAggregatesInput | EvalTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvalTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EvalTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvalTemplate"> | Date | string
    projectId?: StringWithAggregatesFilter<"EvalTemplate"> | string
    name?: StringWithAggregatesFilter<"EvalTemplate"> | string
    version?: IntWithAggregatesFilter<"EvalTemplate"> | number
    prompt?: StringWithAggregatesFilter<"EvalTemplate"> | string
    model?: StringWithAggregatesFilter<"EvalTemplate"> | string
    provider?: StringWithAggregatesFilter<"EvalTemplate"> | string
    modelParams?: JsonWithAggregatesFilter<"EvalTemplate">
    vars?: StringNullableListFilter<"EvalTemplate">
    outputSchema?: JsonWithAggregatesFilter<"EvalTemplate">
  }

  export type JobConfigurationWhereInput = {
    AND?: JobConfigurationWhereInput | JobConfigurationWhereInput[]
    OR?: JobConfigurationWhereInput[]
    NOT?: JobConfigurationWhereInput | JobConfigurationWhereInput[]
    id?: StringFilter<"JobConfiguration"> | string
    createdAt?: DateTimeFilter<"JobConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"JobConfiguration"> | Date | string
    projectId?: StringFilter<"JobConfiguration"> | string
    jobType?: EnumJobTypeFilter<"JobConfiguration"> | $Enums.JobType
    status?: EnumJobConfigStateFilter<"JobConfiguration"> | $Enums.JobConfigState
    evalTemplateId?: StringNullableFilter<"JobConfiguration"> | string | null
    scoreName?: StringFilter<"JobConfiguration"> | string
    filter?: JsonFilter<"JobConfiguration">
    targetObject?: StringFilter<"JobConfiguration"> | string
    variableMapping?: JsonFilter<"JobConfiguration">
    sampling?: DecimalFilter<"JobConfiguration"> | Decimal | DecimalJsLike | number | string
    delay?: IntFilter<"JobConfiguration"> | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    evalTemplate?: XOR<EvalTemplateNullableRelationFilter, EvalTemplateWhereInput> | null
    JobExecution?: JobExecutionListRelationFilter
  }

  export type JobConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    evalTemplateId?: SortOrderInput | SortOrder
    scoreName?: SortOrder
    filter?: SortOrder
    targetObject?: SortOrder
    variableMapping?: SortOrder
    sampling?: SortOrder
    delay?: SortOrder
    project?: ProjectOrderByWithRelationInput
    evalTemplate?: EvalTemplateOrderByWithRelationInput
    JobExecution?: JobExecutionOrderByRelationAggregateInput
  }

  export type JobConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobConfigurationWhereInput | JobConfigurationWhereInput[]
    OR?: JobConfigurationWhereInput[]
    NOT?: JobConfigurationWhereInput | JobConfigurationWhereInput[]
    createdAt?: DateTimeFilter<"JobConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"JobConfiguration"> | Date | string
    projectId?: StringFilter<"JobConfiguration"> | string
    jobType?: EnumJobTypeFilter<"JobConfiguration"> | $Enums.JobType
    status?: EnumJobConfigStateFilter<"JobConfiguration"> | $Enums.JobConfigState
    evalTemplateId?: StringNullableFilter<"JobConfiguration"> | string | null
    scoreName?: StringFilter<"JobConfiguration"> | string
    filter?: JsonFilter<"JobConfiguration">
    targetObject?: StringFilter<"JobConfiguration"> | string
    variableMapping?: JsonFilter<"JobConfiguration">
    sampling?: DecimalFilter<"JobConfiguration"> | Decimal | DecimalJsLike | number | string
    delay?: IntFilter<"JobConfiguration"> | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    evalTemplate?: XOR<EvalTemplateNullableRelationFilter, EvalTemplateWhereInput> | null
    JobExecution?: JobExecutionListRelationFilter
  }, "id">

  export type JobConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    evalTemplateId?: SortOrderInput | SortOrder
    scoreName?: SortOrder
    filter?: SortOrder
    targetObject?: SortOrder
    variableMapping?: SortOrder
    sampling?: SortOrder
    delay?: SortOrder
    _count?: JobConfigurationCountOrderByAggregateInput
    _avg?: JobConfigurationAvgOrderByAggregateInput
    _max?: JobConfigurationMaxOrderByAggregateInput
    _min?: JobConfigurationMinOrderByAggregateInput
    _sum?: JobConfigurationSumOrderByAggregateInput
  }

  export type JobConfigurationScalarWhereWithAggregatesInput = {
    AND?: JobConfigurationScalarWhereWithAggregatesInput | JobConfigurationScalarWhereWithAggregatesInput[]
    OR?: JobConfigurationScalarWhereWithAggregatesInput[]
    NOT?: JobConfigurationScalarWhereWithAggregatesInput | JobConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobConfiguration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobConfiguration"> | Date | string
    projectId?: StringWithAggregatesFilter<"JobConfiguration"> | string
    jobType?: EnumJobTypeWithAggregatesFilter<"JobConfiguration"> | $Enums.JobType
    status?: EnumJobConfigStateWithAggregatesFilter<"JobConfiguration"> | $Enums.JobConfigState
    evalTemplateId?: StringNullableWithAggregatesFilter<"JobConfiguration"> | string | null
    scoreName?: StringWithAggregatesFilter<"JobConfiguration"> | string
    filter?: JsonWithAggregatesFilter<"JobConfiguration">
    targetObject?: StringWithAggregatesFilter<"JobConfiguration"> | string
    variableMapping?: JsonWithAggregatesFilter<"JobConfiguration">
    sampling?: DecimalWithAggregatesFilter<"JobConfiguration"> | Decimal | DecimalJsLike | number | string
    delay?: IntWithAggregatesFilter<"JobConfiguration"> | number
  }

  export type JobExecutionWhereInput = {
    AND?: JobExecutionWhereInput | JobExecutionWhereInput[]
    OR?: JobExecutionWhereInput[]
    NOT?: JobExecutionWhereInput | JobExecutionWhereInput[]
    id?: StringFilter<"JobExecution"> | string
    createdAt?: DateTimeFilter<"JobExecution"> | Date | string
    updatedAt?: DateTimeFilter<"JobExecution"> | Date | string
    projectId?: StringFilter<"JobExecution"> | string
    jobConfigurationId?: StringFilter<"JobExecution"> | string
    status?: EnumJobExecutionStatusFilter<"JobExecution"> | $Enums.JobExecutionStatus
    startTime?: DateTimeNullableFilter<"JobExecution"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobExecution"> | Date | string | null
    error?: StringNullableFilter<"JobExecution"> | string | null
    jobInputTraceId?: StringNullableFilter<"JobExecution"> | string | null
    jobInputObservationId?: StringNullableFilter<"JobExecution"> | string | null
    jobInputDatasetItemId?: StringNullableFilter<"JobExecution"> | string | null
    jobOutputScoreId?: StringNullableFilter<"JobExecution"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    jobConfiguration?: XOR<JobConfigurationRelationFilter, JobConfigurationWhereInput>
  }

  export type JobExecutionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobConfigurationId?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    jobInputTraceId?: SortOrderInput | SortOrder
    jobInputObservationId?: SortOrderInput | SortOrder
    jobInputDatasetItemId?: SortOrderInput | SortOrder
    jobOutputScoreId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    jobConfiguration?: JobConfigurationOrderByWithRelationInput
  }

  export type JobExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobExecutionWhereInput | JobExecutionWhereInput[]
    OR?: JobExecutionWhereInput[]
    NOT?: JobExecutionWhereInput | JobExecutionWhereInput[]
    createdAt?: DateTimeFilter<"JobExecution"> | Date | string
    updatedAt?: DateTimeFilter<"JobExecution"> | Date | string
    projectId?: StringFilter<"JobExecution"> | string
    jobConfigurationId?: StringFilter<"JobExecution"> | string
    status?: EnumJobExecutionStatusFilter<"JobExecution"> | $Enums.JobExecutionStatus
    startTime?: DateTimeNullableFilter<"JobExecution"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobExecution"> | Date | string | null
    error?: StringNullableFilter<"JobExecution"> | string | null
    jobInputTraceId?: StringNullableFilter<"JobExecution"> | string | null
    jobInputObservationId?: StringNullableFilter<"JobExecution"> | string | null
    jobInputDatasetItemId?: StringNullableFilter<"JobExecution"> | string | null
    jobOutputScoreId?: StringNullableFilter<"JobExecution"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    jobConfiguration?: XOR<JobConfigurationRelationFilter, JobConfigurationWhereInput>
  }, "id">

  export type JobExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobConfigurationId?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    jobInputTraceId?: SortOrderInput | SortOrder
    jobInputObservationId?: SortOrderInput | SortOrder
    jobInputDatasetItemId?: SortOrderInput | SortOrder
    jobOutputScoreId?: SortOrderInput | SortOrder
    _count?: JobExecutionCountOrderByAggregateInput
    _max?: JobExecutionMaxOrderByAggregateInput
    _min?: JobExecutionMinOrderByAggregateInput
  }

  export type JobExecutionScalarWhereWithAggregatesInput = {
    AND?: JobExecutionScalarWhereWithAggregatesInput | JobExecutionScalarWhereWithAggregatesInput[]
    OR?: JobExecutionScalarWhereWithAggregatesInput[]
    NOT?: JobExecutionScalarWhereWithAggregatesInput | JobExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobExecution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobExecution"> | Date | string
    projectId?: StringWithAggregatesFilter<"JobExecution"> | string
    jobConfigurationId?: StringWithAggregatesFilter<"JobExecution"> | string
    status?: EnumJobExecutionStatusWithAggregatesFilter<"JobExecution"> | $Enums.JobExecutionStatus
    startTime?: DateTimeNullableWithAggregatesFilter<"JobExecution"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"JobExecution"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"JobExecution"> | string | null
    jobInputTraceId?: StringNullableWithAggregatesFilter<"JobExecution"> | string | null
    jobInputObservationId?: StringNullableWithAggregatesFilter<"JobExecution"> | string | null
    jobInputDatasetItemId?: StringNullableWithAggregatesFilter<"JobExecution"> | string | null
    jobOutputScoreId?: StringNullableWithAggregatesFilter<"JobExecution"> | string | null
  }

  export type SsoConfigWhereInput = {
    AND?: SsoConfigWhereInput | SsoConfigWhereInput[]
    OR?: SsoConfigWhereInput[]
    NOT?: SsoConfigWhereInput | SsoConfigWhereInput[]
    domain?: StringFilter<"SsoConfig"> | string
    createdAt?: DateTimeFilter<"SsoConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SsoConfig"> | Date | string
    authProvider?: StringFilter<"SsoConfig"> | string
    authConfig?: JsonNullableFilter<"SsoConfig">
  }

  export type SsoConfigOrderByWithRelationInput = {
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    authConfig?: SortOrderInput | SortOrder
  }

  export type SsoConfigWhereUniqueInput = Prisma.AtLeast<{
    domain?: string
    AND?: SsoConfigWhereInput | SsoConfigWhereInput[]
    OR?: SsoConfigWhereInput[]
    NOT?: SsoConfigWhereInput | SsoConfigWhereInput[]
    createdAt?: DateTimeFilter<"SsoConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SsoConfig"> | Date | string
    authProvider?: StringFilter<"SsoConfig"> | string
    authConfig?: JsonNullableFilter<"SsoConfig">
  }, "domain">

  export type SsoConfigOrderByWithAggregationInput = {
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    authConfig?: SortOrderInput | SortOrder
    _count?: SsoConfigCountOrderByAggregateInput
    _max?: SsoConfigMaxOrderByAggregateInput
    _min?: SsoConfigMinOrderByAggregateInput
  }

  export type SsoConfigScalarWhereWithAggregatesInput = {
    AND?: SsoConfigScalarWhereWithAggregatesInput | SsoConfigScalarWhereWithAggregatesInput[]
    OR?: SsoConfigScalarWhereWithAggregatesInput[]
    NOT?: SsoConfigScalarWhereWithAggregatesInput | SsoConfigScalarWhereWithAggregatesInput[]
    domain?: StringWithAggregatesFilter<"SsoConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SsoConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SsoConfig"> | Date | string
    authProvider?: StringWithAggregatesFilter<"SsoConfig"> | string
    authConfig?: JsonNullableWithAggregatesFilter<"SsoConfig">
  }

  export type PosthogIntegrationWhereInput = {
    AND?: PosthogIntegrationWhereInput | PosthogIntegrationWhereInput[]
    OR?: PosthogIntegrationWhereInput[]
    NOT?: PosthogIntegrationWhereInput | PosthogIntegrationWhereInput[]
    projectId?: StringFilter<"PosthogIntegration"> | string
    encryptedPosthogApiKey?: StringFilter<"PosthogIntegration"> | string
    posthogHostName?: StringFilter<"PosthogIntegration"> | string
    lastSyncAt?: DateTimeNullableFilter<"PosthogIntegration"> | Date | string | null
    enabled?: BoolFilter<"PosthogIntegration"> | boolean
    createdAt?: DateTimeFilter<"PosthogIntegration"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type PosthogIntegrationOrderByWithRelationInput = {
    projectId?: SortOrder
    encryptedPosthogApiKey?: SortOrder
    posthogHostName?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type PosthogIntegrationWhereUniqueInput = Prisma.AtLeast<{
    projectId?: string
    AND?: PosthogIntegrationWhereInput | PosthogIntegrationWhereInput[]
    OR?: PosthogIntegrationWhereInput[]
    NOT?: PosthogIntegrationWhereInput | PosthogIntegrationWhereInput[]
    encryptedPosthogApiKey?: StringFilter<"PosthogIntegration"> | string
    posthogHostName?: StringFilter<"PosthogIntegration"> | string
    lastSyncAt?: DateTimeNullableFilter<"PosthogIntegration"> | Date | string | null
    enabled?: BoolFilter<"PosthogIntegration"> | boolean
    createdAt?: DateTimeFilter<"PosthogIntegration"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "projectId">

  export type PosthogIntegrationOrderByWithAggregationInput = {
    projectId?: SortOrder
    encryptedPosthogApiKey?: SortOrder
    posthogHostName?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    _count?: PosthogIntegrationCountOrderByAggregateInput
    _max?: PosthogIntegrationMaxOrderByAggregateInput
    _min?: PosthogIntegrationMinOrderByAggregateInput
  }

  export type PosthogIntegrationScalarWhereWithAggregatesInput = {
    AND?: PosthogIntegrationScalarWhereWithAggregatesInput | PosthogIntegrationScalarWhereWithAggregatesInput[]
    OR?: PosthogIntegrationScalarWhereWithAggregatesInput[]
    NOT?: PosthogIntegrationScalarWhereWithAggregatesInput | PosthogIntegrationScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"PosthogIntegration"> | string
    encryptedPosthogApiKey?: StringWithAggregatesFilter<"PosthogIntegration"> | string
    posthogHostName?: StringWithAggregatesFilter<"PosthogIntegration"> | string
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"PosthogIntegration"> | Date | string | null
    enabled?: BoolWithAggregatesFilter<"PosthogIntegration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PosthogIntegration"> | Date | string
  }

  export type BatchExportWhereInput = {
    AND?: BatchExportWhereInput | BatchExportWhereInput[]
    OR?: BatchExportWhereInput[]
    NOT?: BatchExportWhereInput | BatchExportWhereInput[]
    id?: StringFilter<"BatchExport"> | string
    createdAt?: DateTimeFilter<"BatchExport"> | Date | string
    updatedAt?: DateTimeFilter<"BatchExport"> | Date | string
    projectId?: StringFilter<"BatchExport"> | string
    userId?: StringFilter<"BatchExport"> | string
    finishedAt?: DateTimeNullableFilter<"BatchExport"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"BatchExport"> | Date | string | null
    name?: StringFilter<"BatchExport"> | string
    status?: StringFilter<"BatchExport"> | string
    query?: JsonFilter<"BatchExport">
    format?: StringFilter<"BatchExport"> | string
    url?: StringNullableFilter<"BatchExport"> | string | null
    log?: StringNullableFilter<"BatchExport"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type BatchExportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    query?: SortOrder
    format?: SortOrder
    url?: SortOrderInput | SortOrder
    log?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type BatchExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchExportWhereInput | BatchExportWhereInput[]
    OR?: BatchExportWhereInput[]
    NOT?: BatchExportWhereInput | BatchExportWhereInput[]
    createdAt?: DateTimeFilter<"BatchExport"> | Date | string
    updatedAt?: DateTimeFilter<"BatchExport"> | Date | string
    projectId?: StringFilter<"BatchExport"> | string
    userId?: StringFilter<"BatchExport"> | string
    finishedAt?: DateTimeNullableFilter<"BatchExport"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"BatchExport"> | Date | string | null
    name?: StringFilter<"BatchExport"> | string
    status?: StringFilter<"BatchExport"> | string
    query?: JsonFilter<"BatchExport">
    format?: StringFilter<"BatchExport"> | string
    url?: StringNullableFilter<"BatchExport"> | string | null
    log?: StringNullableFilter<"BatchExport"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type BatchExportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    query?: SortOrder
    format?: SortOrder
    url?: SortOrderInput | SortOrder
    log?: SortOrderInput | SortOrder
    _count?: BatchExportCountOrderByAggregateInput
    _max?: BatchExportMaxOrderByAggregateInput
    _min?: BatchExportMinOrderByAggregateInput
  }

  export type BatchExportScalarWhereWithAggregatesInput = {
    AND?: BatchExportScalarWhereWithAggregatesInput | BatchExportScalarWhereWithAggregatesInput[]
    OR?: BatchExportScalarWhereWithAggregatesInput[]
    NOT?: BatchExportScalarWhereWithAggregatesInput | BatchExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchExport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BatchExport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BatchExport"> | Date | string
    projectId?: StringWithAggregatesFilter<"BatchExport"> | string
    userId?: StringWithAggregatesFilter<"BatchExport"> | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"BatchExport"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"BatchExport"> | Date | string | null
    name?: StringWithAggregatesFilter<"BatchExport"> | string
    status?: StringWithAggregatesFilter<"BatchExport"> | string
    query?: JsonWithAggregatesFilter<"BatchExport">
    format?: StringWithAggregatesFilter<"BatchExport"> | string
    url?: StringNullableWithAggregatesFilter<"BatchExport"> | string | null
    log?: StringNullableWithAggregatesFilter<"BatchExport"> | string | null
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    sha256Hash?: StringFilter<"Media"> | string
    projectId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    uploadedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    uploadHttpStatus?: IntNullableFilter<"Media"> | number | null
    uploadHttpError?: StringNullableFilter<"Media"> | string | null
    bucketPath?: StringFilter<"Media"> | string
    bucketName?: StringFilter<"Media"> | string
    contentType?: StringFilter<"Media"> | string
    contentLength?: BigIntFilter<"Media"> | bigint | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    TraceMedia?: TraceMediaListRelationFilter
    ObservationMedia?: ObservationMediaListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    sha256Hash?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedAt?: SortOrderInput | SortOrder
    uploadHttpStatus?: SortOrderInput | SortOrder
    uploadHttpError?: SortOrderInput | SortOrder
    bucketPath?: SortOrder
    bucketName?: SortOrder
    contentType?: SortOrder
    contentLength?: SortOrder
    project?: ProjectOrderByWithRelationInput
    TraceMedia?: TraceMediaOrderByRelationAggregateInput
    ObservationMedia?: ObservationMediaOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_sha256Hash?: MediaProjectIdSha256HashCompoundUniqueInput
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    sha256Hash?: StringFilter<"Media"> | string
    projectId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    uploadedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    uploadHttpStatus?: IntNullableFilter<"Media"> | number | null
    uploadHttpError?: StringNullableFilter<"Media"> | string | null
    bucketPath?: StringFilter<"Media"> | string
    bucketName?: StringFilter<"Media"> | string
    contentType?: StringFilter<"Media"> | string
    contentLength?: BigIntFilter<"Media"> | bigint | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    TraceMedia?: TraceMediaListRelationFilter
    ObservationMedia?: ObservationMediaListRelationFilter
  }, "id" | "projectId_sha256Hash">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    sha256Hash?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedAt?: SortOrderInput | SortOrder
    uploadHttpStatus?: SortOrderInput | SortOrder
    uploadHttpError?: SortOrderInput | SortOrder
    bucketPath?: SortOrder
    bucketName?: SortOrder
    contentType?: SortOrder
    contentLength?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    sha256Hash?: StringWithAggregatesFilter<"Media"> | string
    projectId?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    uploadedAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
    uploadHttpStatus?: IntNullableWithAggregatesFilter<"Media"> | number | null
    uploadHttpError?: StringNullableWithAggregatesFilter<"Media"> | string | null
    bucketPath?: StringWithAggregatesFilter<"Media"> | string
    bucketName?: StringWithAggregatesFilter<"Media"> | string
    contentType?: StringWithAggregatesFilter<"Media"> | string
    contentLength?: BigIntWithAggregatesFilter<"Media"> | bigint | number
  }

  export type TraceMediaWhereInput = {
    AND?: TraceMediaWhereInput | TraceMediaWhereInput[]
    OR?: TraceMediaWhereInput[]
    NOT?: TraceMediaWhereInput | TraceMediaWhereInput[]
    id?: StringFilter<"TraceMedia"> | string
    projectId?: StringFilter<"TraceMedia"> | string
    createdAt?: DateTimeFilter<"TraceMedia"> | Date | string
    updatedAt?: DateTimeFilter<"TraceMedia"> | Date | string
    mediaId?: StringFilter<"TraceMedia"> | string
    traceId?: StringFilter<"TraceMedia"> | string
    field?: StringFilter<"TraceMedia"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }

  export type TraceMediaOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    field?: SortOrder
    project?: ProjectOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type TraceMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_traceId_mediaId_field?: TraceMediaProjectIdTraceIdMediaIdFieldCompoundUniqueInput
    AND?: TraceMediaWhereInput | TraceMediaWhereInput[]
    OR?: TraceMediaWhereInput[]
    NOT?: TraceMediaWhereInput | TraceMediaWhereInput[]
    projectId?: StringFilter<"TraceMedia"> | string
    createdAt?: DateTimeFilter<"TraceMedia"> | Date | string
    updatedAt?: DateTimeFilter<"TraceMedia"> | Date | string
    mediaId?: StringFilter<"TraceMedia"> | string
    traceId?: StringFilter<"TraceMedia"> | string
    field?: StringFilter<"TraceMedia"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }, "id" | "projectId_traceId_mediaId_field">

  export type TraceMediaOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    field?: SortOrder
    _count?: TraceMediaCountOrderByAggregateInput
    _max?: TraceMediaMaxOrderByAggregateInput
    _min?: TraceMediaMinOrderByAggregateInput
  }

  export type TraceMediaScalarWhereWithAggregatesInput = {
    AND?: TraceMediaScalarWhereWithAggregatesInput | TraceMediaScalarWhereWithAggregatesInput[]
    OR?: TraceMediaScalarWhereWithAggregatesInput[]
    NOT?: TraceMediaScalarWhereWithAggregatesInput | TraceMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TraceMedia"> | string
    projectId?: StringWithAggregatesFilter<"TraceMedia"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TraceMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TraceMedia"> | Date | string
    mediaId?: StringWithAggregatesFilter<"TraceMedia"> | string
    traceId?: StringWithAggregatesFilter<"TraceMedia"> | string
    field?: StringWithAggregatesFilter<"TraceMedia"> | string
  }

  export type ObservationMediaWhereInput = {
    AND?: ObservationMediaWhereInput | ObservationMediaWhereInput[]
    OR?: ObservationMediaWhereInput[]
    NOT?: ObservationMediaWhereInput | ObservationMediaWhereInput[]
    id?: StringFilter<"ObservationMedia"> | string
    projectId?: StringFilter<"ObservationMedia"> | string
    createdAt?: DateTimeFilter<"ObservationMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ObservationMedia"> | Date | string
    mediaId?: StringFilter<"ObservationMedia"> | string
    traceId?: StringFilter<"ObservationMedia"> | string
    observationId?: StringFilter<"ObservationMedia"> | string
    field?: StringFilter<"ObservationMedia"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }

  export type ObservationMediaOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    field?: SortOrder
    project?: ProjectOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type ObservationMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_traceId_observationId_mediaId_field?: ObservationMediaProjectIdTraceIdObservationIdMediaIdFieldCompoundUniqueInput
    AND?: ObservationMediaWhereInput | ObservationMediaWhereInput[]
    OR?: ObservationMediaWhereInput[]
    NOT?: ObservationMediaWhereInput | ObservationMediaWhereInput[]
    projectId?: StringFilter<"ObservationMedia"> | string
    createdAt?: DateTimeFilter<"ObservationMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ObservationMedia"> | Date | string
    mediaId?: StringFilter<"ObservationMedia"> | string
    traceId?: StringFilter<"ObservationMedia"> | string
    observationId?: StringFilter<"ObservationMedia"> | string
    field?: StringFilter<"ObservationMedia"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }, "id" | "projectId_traceId_observationId_mediaId_field">

  export type ObservationMediaOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    field?: SortOrder
    _count?: ObservationMediaCountOrderByAggregateInput
    _max?: ObservationMediaMaxOrderByAggregateInput
    _min?: ObservationMediaMinOrderByAggregateInput
  }

  export type ObservationMediaScalarWhereWithAggregatesInput = {
    AND?: ObservationMediaScalarWhereWithAggregatesInput | ObservationMediaScalarWhereWithAggregatesInput[]
    OR?: ObservationMediaScalarWhereWithAggregatesInput[]
    NOT?: ObservationMediaScalarWhereWithAggregatesInput | ObservationMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObservationMedia"> | string
    projectId?: StringWithAggregatesFilter<"ObservationMedia"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ObservationMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ObservationMedia"> | Date | string
    mediaId?: StringWithAggregatesFilter<"ObservationMedia"> | string
    traceId?: StringWithAggregatesFilter<"ObservationMedia"> | string
    observationId?: StringWithAggregatesFilter<"ObservationMedia"> | string
    field?: StringWithAggregatesFilter<"ObservationMedia"> | string
  }

  export type TraceViewWhereInput = {
    AND?: TraceViewWhereInput | TraceViewWhereInput[]
    OR?: TraceViewWhereInput[]
    NOT?: TraceViewWhereInput | TraceViewWhereInput[]
    id?: StringFilter<"TraceView"> | string
    externalId?: StringNullableFilter<"TraceView"> | string | null
    timestamp?: DateTimeFilter<"TraceView"> | Date | string
    name?: StringNullableFilter<"TraceView"> | string | null
    userId?: StringNullableFilter<"TraceView"> | string | null
    metadata?: JsonNullableFilter<"TraceView">
    release?: StringNullableFilter<"TraceView"> | string | null
    version?: StringNullableFilter<"TraceView"> | string | null
    projectId?: StringFilter<"TraceView"> | string
    public?: BoolFilter<"TraceView"> | boolean
    bookmarked?: BoolFilter<"TraceView"> | boolean
    tags?: StringNullableListFilter<"TraceView">
    input?: JsonNullableFilter<"TraceView">
    output?: JsonNullableFilter<"TraceView">
    sessionId?: StringNullableFilter<"TraceView"> | string | null
    createdAt?: DateTimeFilter<"TraceView"> | Date | string
    updatedAt?: DateTimeFilter<"TraceView"> | Date | string
    duration?: FloatNullableFilter<"TraceView"> | number | null
  }

  export type TraceViewOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    release?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    tags?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrderInput | SortOrder
  }

  export type TraceViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TraceViewWhereInput | TraceViewWhereInput[]
    OR?: TraceViewWhereInput[]
    NOT?: TraceViewWhereInput | TraceViewWhereInput[]
    externalId?: StringNullableFilter<"TraceView"> | string | null
    timestamp?: DateTimeFilter<"TraceView"> | Date | string
    name?: StringNullableFilter<"TraceView"> | string | null
    userId?: StringNullableFilter<"TraceView"> | string | null
    metadata?: JsonNullableFilter<"TraceView">
    release?: StringNullableFilter<"TraceView"> | string | null
    version?: StringNullableFilter<"TraceView"> | string | null
    projectId?: StringFilter<"TraceView"> | string
    public?: BoolFilter<"TraceView"> | boolean
    bookmarked?: BoolFilter<"TraceView"> | boolean
    tags?: StringNullableListFilter<"TraceView">
    input?: JsonNullableFilter<"TraceView">
    output?: JsonNullableFilter<"TraceView">
    sessionId?: StringNullableFilter<"TraceView"> | string | null
    createdAt?: DateTimeFilter<"TraceView"> | Date | string
    updatedAt?: DateTimeFilter<"TraceView"> | Date | string
    duration?: FloatNullableFilter<"TraceView"> | number | null
  }, "id">

  export type TraceViewOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    release?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    tags?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: TraceViewCountOrderByAggregateInput
    _avg?: TraceViewAvgOrderByAggregateInput
    _max?: TraceViewMaxOrderByAggregateInput
    _min?: TraceViewMinOrderByAggregateInput
    _sum?: TraceViewSumOrderByAggregateInput
  }

  export type TraceViewScalarWhereWithAggregatesInput = {
    AND?: TraceViewScalarWhereWithAggregatesInput | TraceViewScalarWhereWithAggregatesInput[]
    OR?: TraceViewScalarWhereWithAggregatesInput[]
    NOT?: TraceViewScalarWhereWithAggregatesInput | TraceViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TraceView"> | string
    externalId?: StringNullableWithAggregatesFilter<"TraceView"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"TraceView"> | Date | string
    name?: StringNullableWithAggregatesFilter<"TraceView"> | string | null
    userId?: StringNullableWithAggregatesFilter<"TraceView"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"TraceView">
    release?: StringNullableWithAggregatesFilter<"TraceView"> | string | null
    version?: StringNullableWithAggregatesFilter<"TraceView"> | string | null
    projectId?: StringWithAggregatesFilter<"TraceView"> | string
    public?: BoolWithAggregatesFilter<"TraceView"> | boolean
    bookmarked?: BoolWithAggregatesFilter<"TraceView"> | boolean
    tags?: StringNullableListFilter<"TraceView">
    input?: JsonNullableWithAggregatesFilter<"TraceView">
    output?: JsonNullableWithAggregatesFilter<"TraceView">
    sessionId?: StringNullableWithAggregatesFilter<"TraceView"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TraceView"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TraceView"> | Date | string
    duration?: FloatNullableWithAggregatesFilter<"TraceView"> | number | null
  }

  export type ObservationViewWhereInput = {
    AND?: ObservationViewWhereInput | ObservationViewWhereInput[]
    OR?: ObservationViewWhereInput[]
    NOT?: ObservationViewWhereInput | ObservationViewWhereInput[]
    id?: StringFilter<"ObservationView"> | string
    traceId?: StringNullableFilter<"ObservationView"> | string | null
    projectId?: StringFilter<"ObservationView"> | string
    type?: EnumObservationTypeFilter<"ObservationView"> | $Enums.ObservationType
    startTime?: DateTimeFilter<"ObservationView"> | Date | string
    endTime?: DateTimeNullableFilter<"ObservationView"> | Date | string | null
    name?: StringNullableFilter<"ObservationView"> | string | null
    metadata?: JsonNullableFilter<"ObservationView">
    parentObservationId?: StringNullableFilter<"ObservationView"> | string | null
    level?: EnumObservationLevelFilter<"ObservationView"> | $Enums.ObservationLevel
    statusMessage?: StringNullableFilter<"ObservationView"> | string | null
    version?: StringNullableFilter<"ObservationView"> | string | null
    createdAt?: DateTimeFilter<"ObservationView"> | Date | string
    updatedAt?: DateTimeFilter<"ObservationView"> | Date | string
    model?: StringNullableFilter<"ObservationView"> | string | null
    modelParameters?: JsonNullableFilter<"ObservationView">
    input?: JsonNullableFilter<"ObservationView">
    output?: JsonNullableFilter<"ObservationView">
    promptTokens?: IntFilter<"ObservationView"> | number
    completionTokens?: IntFilter<"ObservationView"> | number
    totalTokens?: IntFilter<"ObservationView"> | number
    unit?: StringNullableFilter<"ObservationView"> | string | null
    completionStartTime?: DateTimeNullableFilter<"ObservationView"> | Date | string | null
    promptId?: StringNullableFilter<"ObservationView"> | string | null
    promptName?: StringNullableFilter<"ObservationView"> | string | null
    promptVersion?: IntNullableFilter<"ObservationView"> | number | null
    modelId?: StringNullableFilter<"ObservationView"> | string | null
    inputPrice?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    latency?: FloatNullableFilter<"ObservationView"> | number | null
    timeToFirstToken?: FloatNullableFilter<"ObservationView"> | number | null
  }

  export type ObservationViewOrderByWithRelationInput = {
    id?: SortOrder
    traceId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    parentObservationId?: SortOrderInput | SortOrder
    level?: SortOrder
    statusMessage?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrderInput | SortOrder
    modelParameters?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrderInput | SortOrder
    completionStartTime?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    promptName?: SortOrderInput | SortOrder
    promptVersion?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    inputPrice?: SortOrderInput | SortOrder
    outputPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    calculatedInputCost?: SortOrderInput | SortOrder
    calculatedOutputCost?: SortOrderInput | SortOrder
    calculatedTotalCost?: SortOrderInput | SortOrder
    latency?: SortOrderInput | SortOrder
    timeToFirstToken?: SortOrderInput | SortOrder
  }

  export type ObservationViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObservationViewWhereInput | ObservationViewWhereInput[]
    OR?: ObservationViewWhereInput[]
    NOT?: ObservationViewWhereInput | ObservationViewWhereInput[]
    traceId?: StringNullableFilter<"ObservationView"> | string | null
    projectId?: StringFilter<"ObservationView"> | string
    type?: EnumObservationTypeFilter<"ObservationView"> | $Enums.ObservationType
    startTime?: DateTimeFilter<"ObservationView"> | Date | string
    endTime?: DateTimeNullableFilter<"ObservationView"> | Date | string | null
    name?: StringNullableFilter<"ObservationView"> | string | null
    metadata?: JsonNullableFilter<"ObservationView">
    parentObservationId?: StringNullableFilter<"ObservationView"> | string | null
    level?: EnumObservationLevelFilter<"ObservationView"> | $Enums.ObservationLevel
    statusMessage?: StringNullableFilter<"ObservationView"> | string | null
    version?: StringNullableFilter<"ObservationView"> | string | null
    createdAt?: DateTimeFilter<"ObservationView"> | Date | string
    updatedAt?: DateTimeFilter<"ObservationView"> | Date | string
    model?: StringNullableFilter<"ObservationView"> | string | null
    modelParameters?: JsonNullableFilter<"ObservationView">
    input?: JsonNullableFilter<"ObservationView">
    output?: JsonNullableFilter<"ObservationView">
    promptTokens?: IntFilter<"ObservationView"> | number
    completionTokens?: IntFilter<"ObservationView"> | number
    totalTokens?: IntFilter<"ObservationView"> | number
    unit?: StringNullableFilter<"ObservationView"> | string | null
    completionStartTime?: DateTimeNullableFilter<"ObservationView"> | Date | string | null
    promptId?: StringNullableFilter<"ObservationView"> | string | null
    promptName?: StringNullableFilter<"ObservationView"> | string | null
    promptVersion?: IntNullableFilter<"ObservationView"> | number | null
    modelId?: StringNullableFilter<"ObservationView"> | string | null
    inputPrice?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    latency?: FloatNullableFilter<"ObservationView"> | number | null
    timeToFirstToken?: FloatNullableFilter<"ObservationView"> | number | null
  }, "id">

  export type ObservationViewOrderByWithAggregationInput = {
    id?: SortOrder
    traceId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    parentObservationId?: SortOrderInput | SortOrder
    level?: SortOrder
    statusMessage?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrderInput | SortOrder
    modelParameters?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrderInput | SortOrder
    completionStartTime?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    promptName?: SortOrderInput | SortOrder
    promptVersion?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    inputPrice?: SortOrderInput | SortOrder
    outputPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    calculatedInputCost?: SortOrderInput | SortOrder
    calculatedOutputCost?: SortOrderInput | SortOrder
    calculatedTotalCost?: SortOrderInput | SortOrder
    latency?: SortOrderInput | SortOrder
    timeToFirstToken?: SortOrderInput | SortOrder
    _count?: ObservationViewCountOrderByAggregateInput
    _avg?: ObservationViewAvgOrderByAggregateInput
    _max?: ObservationViewMaxOrderByAggregateInput
    _min?: ObservationViewMinOrderByAggregateInput
    _sum?: ObservationViewSumOrderByAggregateInput
  }

  export type ObservationViewScalarWhereWithAggregatesInput = {
    AND?: ObservationViewScalarWhereWithAggregatesInput | ObservationViewScalarWhereWithAggregatesInput[]
    OR?: ObservationViewScalarWhereWithAggregatesInput[]
    NOT?: ObservationViewScalarWhereWithAggregatesInput | ObservationViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObservationView"> | string
    traceId?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    projectId?: StringWithAggregatesFilter<"ObservationView"> | string
    type?: EnumObservationTypeWithAggregatesFilter<"ObservationView"> | $Enums.ObservationType
    startTime?: DateTimeWithAggregatesFilter<"ObservationView"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"ObservationView"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ObservationView">
    parentObservationId?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    level?: EnumObservationLevelWithAggregatesFilter<"ObservationView"> | $Enums.ObservationLevel
    statusMessage?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    version?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ObservationView"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ObservationView"> | Date | string
    model?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    modelParameters?: JsonNullableWithAggregatesFilter<"ObservationView">
    input?: JsonNullableWithAggregatesFilter<"ObservationView">
    output?: JsonNullableWithAggregatesFilter<"ObservationView">
    promptTokens?: IntWithAggregatesFilter<"ObservationView"> | number
    completionTokens?: IntWithAggregatesFilter<"ObservationView"> | number
    totalTokens?: IntWithAggregatesFilter<"ObservationView"> | number
    unit?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    completionStartTime?: DateTimeNullableWithAggregatesFilter<"ObservationView"> | Date | string | null
    promptId?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    promptName?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    promptVersion?: IntNullableWithAggregatesFilter<"ObservationView"> | number | null
    modelId?: StringNullableWithAggregatesFilter<"ObservationView"> | string | null
    inputPrice?: DecimalNullableWithAggregatesFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableWithAggregatesFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableWithAggregatesFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableWithAggregatesFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableWithAggregatesFilter<"ObservationView"> | Decimal | DecimalJsLike | number | string | null
    latency?: FloatNullableWithAggregatesFilter<"ObservationView"> | number | null
    timeToFirstToken?: FloatNullableWithAggregatesFilter<"ObservationView"> | number | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    expires_in?: number | null
    ext_expires_in?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    created_at?: number | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    expires_in?: number | null
    ext_expires_in?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    created_at?: number | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    expires_in?: number | null
    ext_expires_in?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    created_at?: number | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    MembershipInvitation?: MembershipInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    MembershipInvitation?: MembershipInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    MembershipInvitation?: MembershipInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    MembershipInvitation?: MembershipInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    createdAt?: Date | string
    note?: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey?: string | null
    displaySecretKey: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    note?: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey?: string | null
    displaySecretKey: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    projectId: string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    note?: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey?: string | null
    displaySecretKey: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    projectId: string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type BackgroundMigrationCreateInput = {
    id?: string
    name: string
    script: string
    args: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: Date | string | null
    failedAt?: Date | string | null
    failedReason?: string | null
    workerId?: string | null
    lockedAt?: Date | string | null
  }

  export type BackgroundMigrationUncheckedCreateInput = {
    id?: string
    name: string
    script: string
    args: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: Date | string | null
    failedAt?: Date | string | null
    failedReason?: string | null
    workerId?: string | null
    lockedAt?: Date | string | null
  }

  export type BackgroundMigrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    args?: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BackgroundMigrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    args?: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BackgroundMigrationCreateManyInput = {
    id?: string
    name: string
    script: string
    args: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: Date | string | null
    failedAt?: Date | string | null
    failedReason?: string | null
    workerId?: string | null
    lockedAt?: Date | string | null
  }

  export type BackgroundMigrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    args?: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BackgroundMigrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    args?: JsonNullValueInput | InputJsonValue
    state?: JsonNullValueInput | InputJsonValue
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LlmApiKeysCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL?: string | null
    customModels?: LlmApiKeysCreatecustomModelsInput | string[]
    withDefaultModels?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutLlmApiKeysInput
  }

  export type LlmApiKeysUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL?: string | null
    customModels?: LlmApiKeysCreatecustomModelsInput | string[]
    withDefaultModels?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    projectId: string
  }

  export type LlmApiKeysUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutLlmApiKeysNestedInput
  }

  export type LlmApiKeysUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type LlmApiKeysCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL?: string | null
    customModels?: LlmApiKeysCreatecustomModelsInput | string[]
    withDefaultModels?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    projectId: string
  }

  export type LlmApiKeysUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LlmApiKeysUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationMembershipCreateInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutOrganizationMembershipsInput
    user: UserCreateNestedOneWithoutOrganizationMembershipsInput
    ProjectMemberships?: ProjectMembershipCreateNestedManyWithoutOrganizationMembershipInput
  }

  export type OrganizationMembershipUncheckedCreateInput = {
    id?: string
    orgId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    ProjectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutOrganizationMembershipInput
  }

  export type OrganizationMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
    ProjectMemberships?: ProjectMembershipUpdateManyWithoutOrganizationMembershipNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutOrganizationMembershipNestedInput
  }

  export type OrganizationMembershipCreateManyInput = {
    id?: string
    orgId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipCreateInput = {
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationMembership: OrganizationMembershipCreateNestedOneWithoutProjectMembershipsInput
    project: ProjectCreateNestedOneWithoutProjectMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMembershipUncheckedCreateInput = {
    orgMembershipId: string
    projectId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationMembership?: OrganizationMembershipUpdateOneRequiredWithoutProjectMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMembershipUncheckedUpdateInput = {
    orgMembershipId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipCreateManyInput = {
    orgMembershipId: string
    projectId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipUncheckedUpdateManyInput = {
    orgMembershipId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationCreateInput = {
    id?: string
    email: string
    orgRole: $Enums.Role
    projectRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembershipInvitationInput
    project?: ProjectCreateNestedOneWithoutInvitationsInput
    invitedByUser?: UserCreateNestedOneWithoutInvitationsInput
  }

  export type MembershipInvitationUncheckedCreateInput = {
    id?: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectId?: string | null
    projectRole?: $Enums.Role | null
    invitedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembershipInvitationNestedInput
    project?: ProjectUpdateOneWithoutInvitationsNestedInput
    invitedByUser?: UserUpdateOneWithoutInvitationsNestedInput
  }

  export type MembershipInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    invitedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationCreateManyInput = {
    id?: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectId?: string | null
    projectRole?: $Enums.Role | null
    invitedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    invitedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarked?: boolean
    public?: boolean
    project: ProjectCreateNestedOneWithoutSessionsInput
    traces?: TraceCreateNestedManyWithoutSessionInput
  }

  export type TraceSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    bookmarked?: boolean
    public?: boolean
    traces?: TraceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TraceSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
    traces?: TraceUpdateManyWithoutSessionNestedInput
  }

  export type TraceSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    traces?: TraceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TraceSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    bookmarked?: boolean
    public?: boolean
  }

  export type TraceSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TraceSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TraceCreateInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTracesInput
    session?: TraceSessionCreateNestedOneWithoutTracesInput
  }

  export type TraceUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    projectId: string
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTracesNestedInput
    session?: TraceSessionUpdateOneWithoutTracesNestedInput
  }

  export type TraceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceCreateManyInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    projectId: string
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationCreateInput = {
    id?: string
    traceId?: string | null
    type: $Enums.ObservationType
    startTime?: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model?: string | null
    internalModel?: string | null
    internalModelId?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
    project: ProjectCreateNestedOneWithoutObservationsInput
  }

  export type ObservationUncheckedCreateInput = {
    id?: string
    traceId?: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime?: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model?: string | null
    internalModel?: string | null
    internalModelId?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
  }

  export type ObservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutObservationsNestedInput
  }

  export type ObservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationCreateManyInput = {
    id?: string
    traceId?: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime?: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model?: string | null
    internalModel?: string | null
    internalModelId?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
  }

  export type ObservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScoreCreateInput = {
    id?: string
    timestamp?: Date | string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
    project: ProjectCreateNestedOneWithoutScoreInput
    scoreConfig?: ScoreConfigCreateNestedOneWithoutScoreInput
  }

  export type ScoreUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    projectId: string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    configId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
  }

  export type ScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    project?: ProjectUpdateOneRequiredWithoutScoreNestedInput
    scoreConfig?: ScoreConfigUpdateOneWithoutScoreNestedInput
  }

  export type ScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type ScoreCreateManyInput = {
    id?: string
    timestamp?: Date | string
    projectId: string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    configId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
  }

  export type ScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type ScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type ScoreConfigCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    project: ProjectCreateNestedOneWithoutScoreConfigInput
    score?: ScoreCreateNestedManyWithoutScoreConfigInput
  }

  export type ScoreConfigUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    score?: ScoreUncheckedCreateNestedManyWithoutScoreConfigInput
  }

  export type ScoreConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutScoreConfigNestedInput
    score?: ScoreUpdateManyWithoutScoreConfigNestedInput
  }

  export type ScoreConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: ScoreUncheckedUpdateManyWithoutScoreConfigNestedInput
  }

  export type ScoreConfigCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
  }

  export type ScoreConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScoreConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnotationQueueCreateInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAnnotationQueueInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutQueueInput
  }

  export type AnnotationQueueUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutQueueInput
  }

  export type AnnotationQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAnnotationQueueNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutQueueNestedInput
  }

  export type AnnotationQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutQueueNestedInput
  }

  export type AnnotationQueueCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemCreateInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: AnnotationQueueCreateNestedOneWithoutAnnotationQueueItemInput
    lockedByUser?: UserCreateNestedOneWithoutAnnotatedLockedItemInput
    annotatorUser?: UserCreateNestedOneWithoutAnnotatedCompletedItemInput
    project: ProjectCreateNestedOneWithoutAnnotationQueueItemInput
  }

  export type AnnotationQueueItemUncheckedCreateInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: AnnotationQueueUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
    lockedByUser?: UserUpdateOneWithoutAnnotatedLockedItemNestedInput
    annotatorUser?: UserUpdateOneWithoutAnnotatedCompletedItemNestedInput
    project?: ProjectUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
  }

  export type AnnotationQueueItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemCreateManyInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CronJobsCreateInput = {
    name: string
    lastRun?: Date | string | null
    jobStartedAt?: Date | string | null
    state?: string | null
  }

  export type CronJobsUncheckedCreateInput = {
    name: string
    lastRun?: Date | string | null
    jobStartedAt?: Date | string | null
    state?: string | null
  }

  export type CronJobsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronJobsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronJobsCreateManyInput = {
    name: string
    lastRun?: Date | string | null
    jobStartedAt?: Date | string | null
    state?: string | null
  }

  export type CronJobsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronJobsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DatasetCreateInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDatasetInput
    datasetItems?: DatasetItemCreateNestedManyWithoutDatasetInput
    datasetRuns?: DatasetRunsCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetItems?: DatasetItemUncheckedCreateNestedManyWithoutDatasetInput
    datasetRuns?: DatasetRunsUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDatasetNestedInput
    datasetItems?: DatasetItemUpdateManyWithoutDatasetNestedInput
    datasetRuns?: DatasetRunsUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetItems?: DatasetItemUncheckedUpdateManyWithoutDatasetNestedInput
    datasetRuns?: DatasetRunsUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetItemCreateInput = {
    id?: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutDatasetItemsInput
    datasetRunItems?: DatasetRunItemsCreateNestedManyWithoutDatasetItemInput
  }

  export type DatasetItemUncheckedCreateInput = {
    id?: string
    projectId: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    datasetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRunItems?: DatasetRunItemsUncheckedCreateNestedManyWithoutDatasetItemInput
  }

  export type DatasetItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutDatasetItemsNestedInput
    datasetRunItems?: DatasetRunItemsUpdateManyWithoutDatasetItemNestedInput
  }

  export type DatasetItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    datasetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRunItems?: DatasetRunItemsUncheckedUpdateManyWithoutDatasetItemNestedInput
  }

  export type DatasetItemCreateManyInput = {
    id?: string
    projectId: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    datasetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    datasetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunsCreateInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutDatasetRunsInput
    datasetRunItems?: DatasetRunItemsCreateNestedManyWithoutDatasetRunInput
  }

  export type DatasetRunsUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    datasetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRunItems?: DatasetRunItemsUncheckedCreateNestedManyWithoutDatasetRunInput
  }

  export type DatasetRunsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutDatasetRunsNestedInput
    datasetRunItems?: DatasetRunItemsUpdateManyWithoutDatasetRunNestedInput
  }

  export type DatasetRunsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    datasetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRunItems?: DatasetRunItemsUncheckedUpdateManyWithoutDatasetRunNestedInput
  }

  export type DatasetRunsCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    datasetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    datasetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsCreateInput = {
    id?: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRun: DatasetRunsCreateNestedOneWithoutDatasetRunItemsInput
    datasetItem: DatasetItemCreateNestedOneWithoutDatasetRunItemsInput
  }

  export type DatasetRunItemsUncheckedCreateInput = {
    id?: string
    projectId: string
    datasetRunId: string
    datasetItemId: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunItemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRun?: DatasetRunsUpdateOneRequiredWithoutDatasetRunItemsNestedInput
    datasetItem?: DatasetItemUpdateOneRequiredWithoutDatasetRunItemsNestedInput
  }

  export type DatasetRunItemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    datasetRunId?: StringFieldUpdateOperationsInput | string
    datasetItemId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsCreateManyInput = {
    id?: string
    projectId: string
    datasetRunId: string
    datasetItemId: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunItemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    datasetRunId?: StringFieldUpdateOperationsInput | string
    datasetItemId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    project: ProjectCreateNestedOneWithoutRawEventsInput
  }

  export type EventsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    data: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
  }

  export type EventsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutRawEventsNestedInput
  }

  export type EventsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    data: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
  }

  export type EventsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    authorUserId?: string | null
    project: ProjectCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    projectId: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    authorUserId?: string | null
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyInput = {
    id?: string
    projectId: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    authorUserId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromptCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    prompt: JsonNullValueInput | InputJsonValue
    name: string
    version: number
    type?: string
    isActive?: boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptCreatetagsInput | string[]
    labels?: PromptCreatelabelsInput | string[]
    project: ProjectCreateNestedOneWithoutPromptInput
  }

  export type PromptUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    prompt: JsonNullValueInput | InputJsonValue
    name: string
    version: number
    type?: string
    isActive?: boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptCreatetagsInput | string[]
    labels?: PromptCreatelabelsInput | string[]
  }

  export type PromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
    project?: ProjectUpdateOneRequiredWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
  }

  export type PromptCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    prompt: JsonNullValueInput | InputJsonValue
    name: string
    version: number
    type?: string
    isActive?: boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptCreatetagsInput | string[]
    labels?: PromptCreatelabelsInput | string[]
  }

  export type PromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
  }

  export type PromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
  }

  export type ModelCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectCreateNestedOneWithoutModelInput
    Price?: PriceCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    Price?: PriceUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneWithoutModelNestedInput
    Price?: PriceUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    Price?: PriceUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usageType: string
    price: Decimal | DecimalJsLike | number | string
    Model: ModelCreateNestedOneWithoutPriceInput
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelId: string
    usageType: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type PriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Model?: ModelUpdateOneRequiredWithoutPriceNestedInput
  }

  export type PriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelId?: StringFieldUpdateOperationsInput | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PriceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelId: string
    usageType: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type PriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelId?: StringFieldUpdateOperationsInput | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AuditLogCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    orgId: string
    userOrgRole: string
    projectId?: string | null
    userProjectRole?: string | null
    resourceType: string
    resourceId: string
    action: string
    before?: string | null
    after?: string | null
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    orgId: string
    userOrgRole: string
    projectId?: string | null
    userProjectRole?: string | null
    resourceType: string
    resourceId: string
    action: string
    before?: string | null
    after?: string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userOrgRole?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userProjectRole?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userOrgRole?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userProjectRole?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    orgId: string
    userOrgRole: string
    projectId?: string | null
    userProjectRole?: string | null
    resourceType: string
    resourceId: string
    action: string
    before?: string | null
    after?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userOrgRole?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userProjectRole?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userOrgRole?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userProjectRole?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvalTemplateCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutEvalTemplateInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutEvalTemplateInput
  }

  export type EvalTemplateUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutEvalTemplateInput
  }

  export type EvalTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutEvalTemplateNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutEvalTemplateNestedInput
  }

  export type EvalTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutEvalTemplateNestedInput
  }

  export type EvalTemplateCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
  }

  export type EvalTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
  }

  export type EvalTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
  }

  export type JobConfigurationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    project: ProjectCreateNestedOneWithoutJobConfigurationInput
    evalTemplate?: EvalTemplateCreateNestedOneWithoutJobConfigurationInput
    JobExecution?: JobExecutionCreateNestedManyWithoutJobConfigurationInput
  }

  export type JobConfigurationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    evalTemplateId?: string | null
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutJobConfigurationInput
  }

  export type JobConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutJobConfigurationNestedInput
    evalTemplate?: EvalTemplateUpdateOneWithoutJobConfigurationNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    evalTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    evalTemplateId?: string | null
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
  }

  export type JobConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type JobConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    evalTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type JobExecutionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
    project: ProjectCreateNestedOneWithoutJobExecutionInput
    jobConfiguration: JobConfigurationCreateNestedOneWithoutJobExecutionInput
  }

  export type JobExecutionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobConfigurationId: string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
  }

  export type JobExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutJobExecutionNestedInput
    jobConfiguration?: JobConfigurationUpdateOneRequiredWithoutJobExecutionNestedInput
  }

  export type JobExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobConfigurationId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobExecutionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobConfigurationId: string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
  }

  export type JobExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobConfigurationId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SsoConfigCreateInput = {
    domain?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider: string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SsoConfigUncheckedCreateInput = {
    domain?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider: string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SsoConfigUpdateInput = {
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: StringFieldUpdateOperationsInput | string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SsoConfigUncheckedUpdateInput = {
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: StringFieldUpdateOperationsInput | string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SsoConfigCreateManyInput = {
    domain?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider: string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SsoConfigUpdateManyMutationInput = {
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: StringFieldUpdateOperationsInput | string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SsoConfigUncheckedUpdateManyInput = {
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: StringFieldUpdateOperationsInput | string
    authConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PosthogIntegrationCreateInput = {
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt?: Date | string | null
    enabled: boolean
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutPosthogIntegrationInput
  }

  export type PosthogIntegrationUncheckedCreateInput = {
    projectId: string
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt?: Date | string | null
    enabled: boolean
    createdAt?: Date | string
  }

  export type PosthogIntegrationUpdateInput = {
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPosthogIntegrationNestedInput
  }

  export type PosthogIntegrationUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosthogIntegrationCreateManyInput = {
    projectId: string
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt?: Date | string | null
    enabled: boolean
    createdAt?: Date | string
  }

  export type PosthogIntegrationUpdateManyMutationInput = {
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosthogIntegrationUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchExportCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    finishedAt?: Date | string | null
    expiresAt?: Date | string | null
    name: string
    status: string
    query: JsonNullValueInput | InputJsonValue
    format: string
    url?: string | null
    log?: string | null
    project: ProjectCreateNestedOneWithoutBatchExportInput
  }

  export type BatchExportUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    finishedAt?: Date | string | null
    expiresAt?: Date | string | null
    name: string
    status: string
    query: JsonNullValueInput | InputJsonValue
    format: string
    url?: string | null
    log?: string | null
  }

  export type BatchExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutBatchExportNestedInput
  }

  export type BatchExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchExportCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    finishedAt?: Date | string | null
    expiresAt?: Date | string | null
    name: string
    status: string
    query: JsonNullValueInput | InputJsonValue
    format: string
    url?: string | null
    log?: string | null
  }

  export type BatchExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaCreateInput = {
    id?: string
    sha256Hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    project: ProjectCreateNestedOneWithoutMediaInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutMediaInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    sha256Hash: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutMediaInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutMediaNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutMediaNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    sha256Hash: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TraceMediaCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    field: string
    project: ProjectCreateNestedOneWithoutTraceMediaInput
    media: MediaCreateNestedOneWithoutTraceMediaInput
  }

  export type TraceMediaUncheckedCreateInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    field: string
  }

  export type TraceMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTraceMediaNestedInput
    media?: MediaUpdateOneRequiredWithoutTraceMediaNestedInput
  }

  export type TraceMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type TraceMediaCreateManyInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    field: string
  }

  export type TraceMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type TraceMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationMediaCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    observationId: string
    field: string
    project: ProjectCreateNestedOneWithoutObservationMediaInput
    media: MediaCreateNestedOneWithoutObservationMediaInput
  }

  export type ObservationMediaUncheckedCreateInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    observationId: string
    field: string
  }

  export type ObservationMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutObservationMediaNestedInput
    media?: MediaUpdateOneRequiredWithoutObservationMediaNestedInput
  }

  export type ObservationMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationMediaCreateManyInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    observationId: string
    field: string
  }

  export type ObservationMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type TraceViewCreateInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    projectId: string
    public?: boolean
    bookmarked?: boolean
    tags?: TraceViewCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    duration?: number | null
  }

  export type TraceViewUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    projectId: string
    public?: boolean
    bookmarked?: boolean
    tags?: TraceViewCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    duration?: number | null
  }

  export type TraceViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceViewUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TraceViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceViewUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TraceViewCreateManyInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    projectId: string
    public?: boolean
    bookmarked?: boolean
    tags?: TraceViewCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    duration?: number | null
  }

  export type TraceViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceViewUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TraceViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceViewUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ObservationViewCreateInput = {
    id?: string
    traceId?: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    model?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
    promptName?: string | null
    promptVersion?: number | null
    modelId?: string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    latency?: number | null
    timeToFirstToken?: number | null
  }

  export type ObservationViewUncheckedCreateInput = {
    id?: string
    traceId?: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    model?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
    promptName?: string | null
    promptVersion?: number | null
    modelId?: string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    latency?: number | null
    timeToFirstToken?: number | null
  }

  export type ObservationViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latency?: NullableFloatFieldUpdateOperationsInput | number | null
    timeToFirstToken?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ObservationViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latency?: NullableFloatFieldUpdateOperationsInput | number | null
    timeToFirstToken?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ObservationViewCreateManyInput = {
    id?: string
    traceId?: string | null
    projectId: string
    type: $Enums.ObservationType
    startTime: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    model?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
    promptName?: string | null
    promptVersion?: number | null
    modelId?: string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    latency?: number | null
    timeToFirstToken?: number | null
  }

  export type ObservationViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latency?: NullableFloatFieldUpdateOperationsInput | number | null
    timeToFirstToken?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ObservationViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latency?: NullableFloatFieldUpdateOperationsInput | number | null
    timeToFirstToken?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    expires_in?: SortOrder
    ext_expires_in?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
    created_at?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
    expires_in?: SortOrder
    ext_expires_in?: SortOrder
    refresh_token_expires_in?: SortOrder
    created_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    expires_in?: SortOrder
    ext_expires_in?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
    created_at?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    expires_in?: SortOrder
    ext_expires_in?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
    created_at?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
    expires_in?: SortOrder
    ext_expires_in?: SortOrder
    refresh_token_expires_in?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type OrganizationMembershipListRelationFilter = {
    every?: OrganizationMembershipWhereInput
    some?: OrganizationMembershipWhereInput
    none?: OrganizationMembershipWhereInput
  }

  export type ProjectMembershipListRelationFilter = {
    every?: ProjectMembershipWhereInput
    some?: ProjectMembershipWhereInput
    none?: ProjectMembershipWhereInput
  }

  export type MembershipInvitationListRelationFilter = {
    every?: MembershipInvitationWhereInput
    some?: MembershipInvitationWhereInput
    none?: MembershipInvitationWhereInput
  }

  export type AnnotationQueueItemListRelationFilter = {
    every?: AnnotationQueueItemWhereInput
    some?: AnnotationQueueItemWhereInput
    none?: AnnotationQueueItemWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnotationQueueItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureFlags?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cloudConfig?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type TraceListRelationFilter = {
    every?: TraceWhereInput
    some?: TraceWhereInput
    none?: TraceWhereInput
  }

  export type ObservationListRelationFilter = {
    every?: ObservationWhereInput
    some?: ObservationWhereInput
    none?: ObservationWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type DatasetListRelationFilter = {
    every?: DatasetWhereInput
    some?: DatasetWhereInput
    none?: DatasetWhereInput
  }

  export type EventsListRelationFilter = {
    every?: EventsWhereInput
    some?: EventsWhereInput
    none?: EventsWhereInput
  }

  export type TraceSessionListRelationFilter = {
    every?: TraceSessionWhereInput
    some?: TraceSessionWhereInput
    none?: TraceSessionWhereInput
  }

  export type PromptListRelationFilter = {
    every?: PromptWhereInput
    some?: PromptWhereInput
    none?: PromptWhereInput
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type EvalTemplateListRelationFilter = {
    every?: EvalTemplateWhereInput
    some?: EvalTemplateWhereInput
    none?: EvalTemplateWhereInput
  }

  export type JobConfigurationListRelationFilter = {
    every?: JobConfigurationWhereInput
    some?: JobConfigurationWhereInput
    none?: JobConfigurationWhereInput
  }

  export type JobExecutionListRelationFilter = {
    every?: JobExecutionWhereInput
    some?: JobExecutionWhereInput
    none?: JobExecutionWhereInput
  }

  export type LlmApiKeysListRelationFilter = {
    every?: LlmApiKeysWhereInput
    some?: LlmApiKeysWhereInput
    none?: LlmApiKeysWhereInput
  }

  export type PosthogIntegrationListRelationFilter = {
    every?: PosthogIntegrationWhereInput
    some?: PosthogIntegrationWhereInput
    none?: PosthogIntegrationWhereInput
  }

  export type ScoreListRelationFilter = {
    every?: ScoreWhereInput
    some?: ScoreWhereInput
    none?: ScoreWhereInput
  }

  export type ScoreConfigListRelationFilter = {
    every?: ScoreConfigWhereInput
    some?: ScoreConfigWhereInput
    none?: ScoreConfigWhereInput
  }

  export type BatchExportListRelationFilter = {
    every?: BatchExportWhereInput
    some?: BatchExportWhereInput
    none?: BatchExportWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type AnnotationQueueListRelationFilter = {
    every?: AnnotationQueueWhereInput
    some?: AnnotationQueueWhereInput
    none?: AnnotationQueueWhereInput
  }

  export type TraceMediaListRelationFilter = {
    every?: TraceMediaWhereInput
    some?: TraceMediaWhereInput
    none?: TraceMediaWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ObservationMediaListRelationFilter = {
    every?: ObservationMediaWhereInput
    some?: ObservationMediaWhereInput
    none?: ObservationMediaWhereInput
  }

  export type TraceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TraceSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvalTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LlmApiKeysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosthogIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScoreConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnotationQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TraceMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObservationMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    name?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    name?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    name?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
    publicKey?: SortOrder
    hashedSecretKey?: SortOrder
    fastHashedSecretKey?: SortOrder
    displaySecretKey?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    projectId?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
    publicKey?: SortOrder
    hashedSecretKey?: SortOrder
    fastHashedSecretKey?: SortOrder
    displaySecretKey?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    projectId?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
    publicKey?: SortOrder
    hashedSecretKey?: SortOrder
    fastHashedSecretKey?: SortOrder
    displaySecretKey?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    projectId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BackgroundMigrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    script?: SortOrder
    args?: SortOrder
    state?: SortOrder
    finishedAt?: SortOrder
    failedAt?: SortOrder
    failedReason?: SortOrder
    workerId?: SortOrder
    lockedAt?: SortOrder
  }

  export type BackgroundMigrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    script?: SortOrder
    finishedAt?: SortOrder
    failedAt?: SortOrder
    failedReason?: SortOrder
    workerId?: SortOrder
    lockedAt?: SortOrder
  }

  export type BackgroundMigrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    script?: SortOrder
    finishedAt?: SortOrder
    failedAt?: SortOrder
    failedReason?: SortOrder
    workerId?: SortOrder
    lockedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type LlmApiKeysProjectIdProviderCompoundUniqueInput = {
    projectId: string
    provider: string
  }

  export type LlmApiKeysCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    adapter?: SortOrder
    displaySecretKey?: SortOrder
    secretKey?: SortOrder
    baseURL?: SortOrder
    customModels?: SortOrder
    withDefaultModels?: SortOrder
    config?: SortOrder
    projectId?: SortOrder
  }

  export type LlmApiKeysMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    adapter?: SortOrder
    displaySecretKey?: SortOrder
    secretKey?: SortOrder
    baseURL?: SortOrder
    withDefaultModels?: SortOrder
    projectId?: SortOrder
  }

  export type LlmApiKeysMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    adapter?: SortOrder
    displaySecretKey?: SortOrder
    secretKey?: SortOrder
    baseURL?: SortOrder
    withDefaultModels?: SortOrder
    projectId?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type OrganizationMembershipOrgIdUserIdCompoundUniqueInput = {
    orgId: string
    userId: string
  }

  export type OrganizationMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type OrganizationMembershipRelationFilter = {
    is?: OrganizationMembershipWhereInput
    isNot?: OrganizationMembershipWhereInput
  }

  export type ProjectMembershipProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMembershipCountOrderByAggregateInput = {
    orgMembershipId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMembershipMaxOrderByAggregateInput = {
    orgMembershipId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMembershipMinOrderByAggregateInput = {
    orgMembershipId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MembershipInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    orgRole?: SortOrder
    projectId?: SortOrder
    projectRole?: SortOrder
    invitedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    orgRole?: SortOrder
    projectId?: SortOrder
    projectRole?: SortOrder
    invitedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    orgRole?: SortOrder
    projectId?: SortOrder
    projectRole?: SortOrder
    invitedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type TraceSessionIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type TraceSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    bookmarked?: SortOrder
    public?: SortOrder
  }

  export type TraceSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    bookmarked?: SortOrder
    public?: SortOrder
  }

  export type TraceSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    bookmarked?: SortOrder
    public?: SortOrder
  }

  export type TraceSessionNullableRelationFilter = {
    is?: TraceSessionWhereInput | null
    isNot?: TraceSessionWhereInput | null
  }

  export type TraceCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    metadata?: SortOrder
    release?: SortOrder
    version?: SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    tags?: SortOrder
    input?: SortOrder
    output?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TraceMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    release?: SortOrder
    version?: SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TraceMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    release?: SortOrder
    version?: SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumObservationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationType | EnumObservationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationTypeFilter<$PrismaModel> | $Enums.ObservationType
  }

  export type EnumObservationLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationLevel | EnumObservationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationLevelFilter<$PrismaModel> | $Enums.ObservationLevel
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ObservationIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type ObservationCountOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    name?: SortOrder
    metadata?: SortOrder
    parentObservationId?: SortOrder
    level?: SortOrder
    statusMessage?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrder
    internalModel?: SortOrder
    internalModelId?: SortOrder
    modelParameters?: SortOrder
    input?: SortOrder
    output?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    totalCost?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    completionStartTime?: SortOrder
    promptId?: SortOrder
  }

  export type ObservationAvgOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    totalCost?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
  }

  export type ObservationMaxOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    name?: SortOrder
    parentObservationId?: SortOrder
    level?: SortOrder
    statusMessage?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrder
    internalModel?: SortOrder
    internalModelId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    totalCost?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    completionStartTime?: SortOrder
    promptId?: SortOrder
  }

  export type ObservationMinOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    name?: SortOrder
    parentObservationId?: SortOrder
    level?: SortOrder
    statusMessage?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrder
    internalModel?: SortOrder
    internalModelId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    totalCost?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    completionStartTime?: SortOrder
    promptId?: SortOrder
  }

  export type ObservationSumOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    totalCost?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
  }

  export type EnumObservationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationType | EnumObservationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObservationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObservationTypeFilter<$PrismaModel>
    _max?: NestedEnumObservationTypeFilter<$PrismaModel>
  }

  export type EnumObservationLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationLevel | EnumObservationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationLevelWithAggregatesFilter<$PrismaModel> | $Enums.ObservationLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObservationLevelFilter<$PrismaModel>
    _max?: NestedEnumObservationLevelFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumScoreSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreSource | EnumScoreSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreSourceFilter<$PrismaModel> | $Enums.ScoreSource
  }

  export type EnumScoreDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreDataType | EnumScoreDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreDataTypeFilter<$PrismaModel> | $Enums.ScoreDataType
  }

  export type ScoreConfigNullableRelationFilter = {
    is?: ScoreConfigWhereInput | null
    isNot?: ScoreConfigWhereInput | null
  }

  export type ScoreIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type ScoreCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    source?: SortOrder
    authorUserId?: SortOrder
    comment?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    configId?: SortOrder
    stringValue?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataType?: SortOrder
  }

  export type ScoreAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    source?: SortOrder
    authorUserId?: SortOrder
    comment?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    configId?: SortOrder
    stringValue?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataType?: SortOrder
  }

  export type ScoreMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    source?: SortOrder
    authorUserId?: SortOrder
    comment?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    configId?: SortOrder
    stringValue?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataType?: SortOrder
  }

  export type ScoreSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumScoreSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreSource | EnumScoreSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreSourceWithAggregatesFilter<$PrismaModel> | $Enums.ScoreSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreSourceFilter<$PrismaModel>
    _max?: NestedEnumScoreSourceFilter<$PrismaModel>
  }

  export type EnumScoreDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreDataType | EnumScoreDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoreDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreDataTypeFilter<$PrismaModel>
    _max?: NestedEnumScoreDataTypeFilter<$PrismaModel>
  }

  export type ScoreConfigIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type ScoreConfigCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    dataType?: SortOrder
    isArchived?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    categories?: SortOrder
    description?: SortOrder
  }

  export type ScoreConfigAvgOrderByAggregateInput = {
    minValue?: SortOrder
    maxValue?: SortOrder
  }

  export type ScoreConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    dataType?: SortOrder
    isArchived?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    description?: SortOrder
  }

  export type ScoreConfigMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    dataType?: SortOrder
    isArchived?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    description?: SortOrder
  }

  export type ScoreConfigSumOrderByAggregateInput = {
    minValue?: SortOrder
    maxValue?: SortOrder
  }

  export type AnnotationQueueProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type AnnotationQueueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scoreConfigIds?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnotationQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnotationQueueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnnotationQueueObjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueObjectType | EnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel> | $Enums.AnnotationQueueObjectType
  }

  export type EnumAnnotationQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueStatus | EnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueStatusFilter<$PrismaModel> | $Enums.AnnotationQueueStatus
  }

  export type AnnotationQueueRelationFilter = {
    is?: AnnotationQueueWhereInput
    isNot?: AnnotationQueueWhereInput
  }

  export type AnnotationQueueItemCountOrderByAggregateInput = {
    id?: SortOrder
    queueId?: SortOrder
    objectId?: SortOrder
    objectType?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrder
    lockedByUserId?: SortOrder
    annotatorUserId?: SortOrder
    completedAt?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnotationQueueItemMaxOrderByAggregateInput = {
    id?: SortOrder
    queueId?: SortOrder
    objectId?: SortOrder
    objectType?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrder
    lockedByUserId?: SortOrder
    annotatorUserId?: SortOrder
    completedAt?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnotationQueueItemMinOrderByAggregateInput = {
    id?: SortOrder
    queueId?: SortOrder
    objectId?: SortOrder
    objectType?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrder
    lockedByUserId?: SortOrder
    annotatorUserId?: SortOrder
    completedAt?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnnotationQueueObjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueObjectType | EnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueObjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnnotationQueueObjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel>
    _max?: NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel>
  }

  export type EnumAnnotationQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueStatus | EnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.AnnotationQueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnotationQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumAnnotationQueueStatusFilter<$PrismaModel>
  }

  export type CronJobsCountOrderByAggregateInput = {
    name?: SortOrder
    lastRun?: SortOrder
    jobStartedAt?: SortOrder
    state?: SortOrder
  }

  export type CronJobsMaxOrderByAggregateInput = {
    name?: SortOrder
    lastRun?: SortOrder
    jobStartedAt?: SortOrder
    state?: SortOrder
  }

  export type CronJobsMinOrderByAggregateInput = {
    name?: SortOrder
    lastRun?: SortOrder
    jobStartedAt?: SortOrder
    state?: SortOrder
  }

  export type DatasetItemListRelationFilter = {
    every?: DatasetItemWhereInput
    some?: DatasetItemWhereInput
    none?: DatasetItemWhereInput
  }

  export type DatasetRunsListRelationFilter = {
    every?: DatasetRunsWhereInput
    some?: DatasetRunsWhereInput
    none?: DatasetRunsWhereInput
  }

  export type DatasetItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetRunsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type DatasetIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type DatasetCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDatasetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusFilter<$PrismaModel> | $Enums.DatasetStatus
  }

  export type DatasetRelationFilter = {
    is?: DatasetWhereInput
    isNot?: DatasetWhereInput
  }

  export type DatasetRunItemsListRelationFilter = {
    every?: DatasetRunItemsWhereInput
    some?: DatasetRunItemsWhereInput
    none?: DatasetRunItemsWhereInput
  }

  export type DatasetRunItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetItemIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type DatasetItemCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    input?: SortOrder
    expectedOutput?: SortOrder
    metadata?: SortOrder
    sourceTraceId?: SortOrder
    sourceObservationId?: SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetItemMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    sourceTraceId?: SortOrder
    sourceObservationId?: SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetItemMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    sourceTraceId?: SortOrder
    sourceObservationId?: SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDatasetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel> | $Enums.DatasetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetStatusFilter<$PrismaModel>
    _max?: NestedEnumDatasetStatusFilter<$PrismaModel>
  }

  export type DatasetRunsDatasetIdProjectIdNameCompoundUniqueInput = {
    datasetId: string
    projectId: string
    name: string
  }

  export type DatasetRunsIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type DatasetRunsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetRunsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetRunsMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    datasetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetRunsRelationFilter = {
    is?: DatasetRunsWhereInput
    isNot?: DatasetRunsWhereInput
  }

  export type DatasetItemRelationFilter = {
    is?: DatasetItemWhereInput
    isNot?: DatasetItemWhereInput
  }

  export type DatasetRunItemsIdProjectIdCompoundUniqueInput = {
    id: string
    projectId: string
  }

  export type DatasetRunItemsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    datasetRunId?: SortOrder
    datasetItemId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetRunItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    datasetRunId?: SortOrder
    datasetItemId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetRunItemsMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    datasetRunId?: SortOrder
    datasetItemId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    data?: SortOrder
    headers?: SortOrder
    url?: SortOrder
    method?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    method?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    method?: SortOrder
  }

  export type EnumCommentObjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentObjectType | EnumCommentObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentObjectTypeFilter<$PrismaModel> | $Enums.CommentObjectType
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    authorUserId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    authorUserId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    authorUserId?: SortOrder
  }

  export type EnumCommentObjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentObjectType | EnumCommentObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentObjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommentObjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentObjectTypeFilter<$PrismaModel>
    _max?: NestedEnumCommentObjectTypeFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PromptProjectIdNameVersionCompoundUniqueInput = {
    projectId: string
    name: string
    version: number
  }

  export type PromptCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    prompt?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    tags?: SortOrder
    labels?: SortOrder
  }

  export type PromptAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type PromptMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
  }

  export type PromptMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
  }

  export type PromptSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PriceListRelationFilter = {
    every?: PriceWhereInput
    some?: PriceWhereInput
    none?: PriceWhereInput
  }

  export type PriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelProjectIdModelNameStartDateUnitCompoundUniqueInput = {
    projectId: string
    modelName: string
    startDate: Date | string
    unit: string
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    modelName?: SortOrder
    matchPattern?: SortOrder
    startDate?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    unit?: SortOrder
    tokenizerId?: SortOrder
    tokenizerConfig?: SortOrder
  }

  export type ModelAvgOrderByAggregateInput = {
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    modelName?: SortOrder
    matchPattern?: SortOrder
    startDate?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    unit?: SortOrder
    tokenizerId?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    modelName?: SortOrder
    matchPattern?: SortOrder
    startDate?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    unit?: SortOrder
    tokenizerId?: SortOrder
  }

  export type ModelSumOrderByAggregateInput = {
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ModelRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type PriceModelIdUsageTypeCompoundUniqueInput = {
    modelId: string
    usageType: string
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modelId?: SortOrder
    usageType?: SortOrder
    price?: SortOrder
  }

  export type PriceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modelId?: SortOrder
    usageType?: SortOrder
    price?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modelId?: SortOrder
    usageType?: SortOrder
    price?: SortOrder
  }

  export type PriceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    userOrgRole?: SortOrder
    projectId?: SortOrder
    userProjectRole?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    before?: SortOrder
    after?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    userOrgRole?: SortOrder
    projectId?: SortOrder
    userProjectRole?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    before?: SortOrder
    after?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    userOrgRole?: SortOrder
    projectId?: SortOrder
    userProjectRole?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    before?: SortOrder
    after?: SortOrder
  }

  export type EvalTemplateProjectIdNameVersionCompoundUniqueInput = {
    projectId: string
    name: string
    version: number
  }

  export type EvalTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    modelParams?: SortOrder
    vars?: SortOrder
    outputSchema?: SortOrder
  }

  export type EvalTemplateAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EvalTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
  }

  export type EvalTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
  }

  export type EvalTemplateSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type EnumJobConfigStateFilter<$PrismaModel = never> = {
    equals?: $Enums.JobConfigState | EnumJobConfigStateFieldRefInput<$PrismaModel>
    in?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    not?: NestedEnumJobConfigStateFilter<$PrismaModel> | $Enums.JobConfigState
  }

  export type EvalTemplateNullableRelationFilter = {
    is?: EvalTemplateWhereInput | null
    isNot?: EvalTemplateWhereInput | null
  }

  export type JobConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    evalTemplateId?: SortOrder
    scoreName?: SortOrder
    filter?: SortOrder
    targetObject?: SortOrder
    variableMapping?: SortOrder
    sampling?: SortOrder
    delay?: SortOrder
  }

  export type JobConfigurationAvgOrderByAggregateInput = {
    sampling?: SortOrder
    delay?: SortOrder
  }

  export type JobConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    evalTemplateId?: SortOrder
    scoreName?: SortOrder
    targetObject?: SortOrder
    sampling?: SortOrder
    delay?: SortOrder
  }

  export type JobConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    evalTemplateId?: SortOrder
    scoreName?: SortOrder
    targetObject?: SortOrder
    sampling?: SortOrder
    delay?: SortOrder
  }

  export type JobConfigurationSumOrderByAggregateInput = {
    sampling?: SortOrder
    delay?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type EnumJobConfigStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobConfigState | EnumJobConfigStateFieldRefInput<$PrismaModel>
    in?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    not?: NestedEnumJobConfigStateWithAggregatesFilter<$PrismaModel> | $Enums.JobConfigState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobConfigStateFilter<$PrismaModel>
    _max?: NestedEnumJobConfigStateFilter<$PrismaModel>
  }

  export type EnumJobExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobExecutionStatus | EnumJobExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobExecutionStatusFilter<$PrismaModel> | $Enums.JobExecutionStatus
  }

  export type JobConfigurationRelationFilter = {
    is?: JobConfigurationWhereInput
    isNot?: JobConfigurationWhereInput
  }

  export type JobExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobConfigurationId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    jobInputTraceId?: SortOrder
    jobInputObservationId?: SortOrder
    jobInputDatasetItemId?: SortOrder
    jobOutputScoreId?: SortOrder
  }

  export type JobExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobConfigurationId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    jobInputTraceId?: SortOrder
    jobInputObservationId?: SortOrder
    jobInputDatasetItemId?: SortOrder
    jobOutputScoreId?: SortOrder
  }

  export type JobExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    jobConfigurationId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    jobInputTraceId?: SortOrder
    jobInputObservationId?: SortOrder
    jobInputDatasetItemId?: SortOrder
    jobOutputScoreId?: SortOrder
  }

  export type EnumJobExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobExecutionStatus | EnumJobExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumJobExecutionStatusFilter<$PrismaModel>
  }

  export type SsoConfigCountOrderByAggregateInput = {
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    authConfig?: SortOrder
  }

  export type SsoConfigMaxOrderByAggregateInput = {
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
  }

  export type SsoConfigMinOrderByAggregateInput = {
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
  }

  export type PosthogIntegrationCountOrderByAggregateInput = {
    projectId?: SortOrder
    encryptedPosthogApiKey?: SortOrder
    posthogHostName?: SortOrder
    lastSyncAt?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type PosthogIntegrationMaxOrderByAggregateInput = {
    projectId?: SortOrder
    encryptedPosthogApiKey?: SortOrder
    posthogHostName?: SortOrder
    lastSyncAt?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type PosthogIntegrationMinOrderByAggregateInput = {
    projectId?: SortOrder
    encryptedPosthogApiKey?: SortOrder
    posthogHostName?: SortOrder
    lastSyncAt?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchExportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    finishedAt?: SortOrder
    expiresAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    query?: SortOrder
    format?: SortOrder
    url?: SortOrder
    log?: SortOrder
  }

  export type BatchExportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    finishedAt?: SortOrder
    expiresAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    format?: SortOrder
    url?: SortOrder
    log?: SortOrder
  }

  export type BatchExportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    finishedAt?: SortOrder
    expiresAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    format?: SortOrder
    url?: SortOrder
    log?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type MediaProjectIdSha256HashCompoundUniqueInput = {
    projectId: string
    sha256Hash: string
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    sha256Hash?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedAt?: SortOrder
    uploadHttpStatus?: SortOrder
    uploadHttpError?: SortOrder
    bucketPath?: SortOrder
    bucketName?: SortOrder
    contentType?: SortOrder
    contentLength?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    uploadHttpStatus?: SortOrder
    contentLength?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    sha256Hash?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedAt?: SortOrder
    uploadHttpStatus?: SortOrder
    uploadHttpError?: SortOrder
    bucketPath?: SortOrder
    bucketName?: SortOrder
    contentType?: SortOrder
    contentLength?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    sha256Hash?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedAt?: SortOrder
    uploadHttpStatus?: SortOrder
    uploadHttpError?: SortOrder
    bucketPath?: SortOrder
    bucketName?: SortOrder
    contentType?: SortOrder
    contentLength?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    uploadHttpStatus?: SortOrder
    contentLength?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type MediaRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type TraceMediaProjectIdTraceIdMediaIdFieldCompoundUniqueInput = {
    projectId: string
    traceId: string
    mediaId: string
    field: string
  }

  export type TraceMediaCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    field?: SortOrder
  }

  export type TraceMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    field?: SortOrder
  }

  export type TraceMediaMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    field?: SortOrder
  }

  export type ObservationMediaProjectIdTraceIdObservationIdMediaIdFieldCompoundUniqueInput = {
    projectId: string
    traceId: string
    observationId: string
    mediaId: string
    field: string
  }

  export type ObservationMediaCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    field?: SortOrder
  }

  export type ObservationMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    field?: SortOrder
  }

  export type ObservationMediaMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaId?: SortOrder
    traceId?: SortOrder
    observationId?: SortOrder
    field?: SortOrder
  }

  export type TraceViewCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    metadata?: SortOrder
    release?: SortOrder
    version?: SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    tags?: SortOrder
    input?: SortOrder
    output?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
  }

  export type TraceViewAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TraceViewMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    release?: SortOrder
    version?: SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
  }

  export type TraceViewMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    release?: SortOrder
    version?: SortOrder
    projectId?: SortOrder
    public?: SortOrder
    bookmarked?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
  }

  export type TraceViewSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ObservationViewCountOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    name?: SortOrder
    metadata?: SortOrder
    parentObservationId?: SortOrder
    level?: SortOrder
    statusMessage?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrder
    modelParameters?: SortOrder
    input?: SortOrder
    output?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrder
    completionStartTime?: SortOrder
    promptId?: SortOrder
    promptName?: SortOrder
    promptVersion?: SortOrder
    modelId?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    latency?: SortOrder
    timeToFirstToken?: SortOrder
  }

  export type ObservationViewAvgOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    promptVersion?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    latency?: SortOrder
    timeToFirstToken?: SortOrder
  }

  export type ObservationViewMaxOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    name?: SortOrder
    parentObservationId?: SortOrder
    level?: SortOrder
    statusMessage?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrder
    completionStartTime?: SortOrder
    promptId?: SortOrder
    promptName?: SortOrder
    promptVersion?: SortOrder
    modelId?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    latency?: SortOrder
    timeToFirstToken?: SortOrder
  }

  export type ObservationViewMinOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    name?: SortOrder
    parentObservationId?: SortOrder
    level?: SortOrder
    statusMessage?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    unit?: SortOrder
    completionStartTime?: SortOrder
    promptId?: SortOrder
    promptName?: SortOrder
    promptVersion?: SortOrder
    modelId?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    latency?: SortOrder
    timeToFirstToken?: SortOrder
  }

  export type ObservationViewSumOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    promptVersion?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    totalPrice?: SortOrder
    calculatedInputCost?: SortOrder
    calculatedOutputCost?: SortOrder
    calculatedTotalCost?: SortOrder
    latency?: SortOrder
    timeToFirstToken?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreatefeatureFlagsInput = {
    set: string[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrganizationMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type ProjectMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMembershipCreateWithoutUserInput, ProjectMembershipUncheckedCreateWithoutUserInput> | ProjectMembershipCreateWithoutUserInput[] | ProjectMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutUserInput | ProjectMembershipCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMembershipCreateManyUserInputEnvelope
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
  }

  export type MembershipInvitationCreateNestedManyWithoutInvitedByUserInput = {
    create?: XOR<MembershipInvitationCreateWithoutInvitedByUserInput, MembershipInvitationUncheckedCreateWithoutInvitedByUserInput> | MembershipInvitationCreateWithoutInvitedByUserInput[] | MembershipInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutInvitedByUserInput | MembershipInvitationCreateOrConnectWithoutInvitedByUserInput[]
    createMany?: MembershipInvitationCreateManyInvitedByUserInputEnvelope
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
  }

  export type AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutLockedByUserInput, AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput> | AnnotationQueueItemCreateWithoutLockedByUserInput[] | AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput | AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput[]
    createMany?: AnnotationQueueItemCreateManyLockedByUserInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput> | AnnotationQueueItemCreateWithoutAnnotatorUserInput[] | AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput | AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput[]
    createMany?: AnnotationQueueItemCreateManyAnnotatorUserInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type ProjectMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMembershipCreateWithoutUserInput, ProjectMembershipUncheckedCreateWithoutUserInput> | ProjectMembershipCreateWithoutUserInput[] | ProjectMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutUserInput | ProjectMembershipCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMembershipCreateManyUserInputEnvelope
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
  }

  export type MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput = {
    create?: XOR<MembershipInvitationCreateWithoutInvitedByUserInput, MembershipInvitationUncheckedCreateWithoutInvitedByUserInput> | MembershipInvitationCreateWithoutInvitedByUserInput[] | MembershipInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutInvitedByUserInput | MembershipInvitationCreateOrConnectWithoutInvitedByUserInput[]
    createMany?: MembershipInvitationCreateManyInvitedByUserInputEnvelope
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
  }

  export type AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutLockedByUserInput, AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput> | AnnotationQueueItemCreateWithoutLockedByUserInput[] | AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput | AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput[]
    createMany?: AnnotationQueueItemCreateManyLockedByUserInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput> | AnnotationQueueItemCreateWithoutAnnotatorUserInput[] | AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput | AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput[]
    createMany?: AnnotationQueueItemCreateManyAnnotatorUserInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdatefeatureFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrganizationMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput | OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput | OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutUserInput | OrganizationMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type ProjectMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMembershipCreateWithoutUserInput, ProjectMembershipUncheckedCreateWithoutUserInput> | ProjectMembershipCreateWithoutUserInput[] | ProjectMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutUserInput | ProjectMembershipCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMembershipUpsertWithWhereUniqueWithoutUserInput | ProjectMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMembershipCreateManyUserInputEnvelope
    set?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    disconnect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    delete?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    update?: ProjectMembershipUpdateWithWhereUniqueWithoutUserInput | ProjectMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMembershipUpdateManyWithWhereWithoutUserInput | ProjectMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
  }

  export type MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput = {
    create?: XOR<MembershipInvitationCreateWithoutInvitedByUserInput, MembershipInvitationUncheckedCreateWithoutInvitedByUserInput> | MembershipInvitationCreateWithoutInvitedByUserInput[] | MembershipInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutInvitedByUserInput | MembershipInvitationCreateOrConnectWithoutInvitedByUserInput[]
    upsert?: MembershipInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput | MembershipInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput[]
    createMany?: MembershipInvitationCreateManyInvitedByUserInputEnvelope
    set?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    disconnect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    delete?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    update?: MembershipInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput | MembershipInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput[]
    updateMany?: MembershipInvitationUpdateManyWithWhereWithoutInvitedByUserInput | MembershipInvitationUpdateManyWithWhereWithoutInvitedByUserInput[]
    deleteMany?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
  }

  export type AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutLockedByUserInput, AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput> | AnnotationQueueItemCreateWithoutLockedByUserInput[] | AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput | AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutLockedByUserInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutLockedByUserInput[]
    createMany?: AnnotationQueueItemCreateManyLockedByUserInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutLockedByUserInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutLockedByUserInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutLockedByUserInput | AnnotationQueueItemUpdateManyWithWhereWithoutLockedByUserInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput> | AnnotationQueueItemCreateWithoutAnnotatorUserInput[] | AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput | AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutAnnotatorUserInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutAnnotatorUserInput[]
    createMany?: AnnotationQueueItemCreateManyAnnotatorUserInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutAnnotatorUserInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutAnnotatorUserInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutAnnotatorUserInput | AnnotationQueueItemUpdateManyWithWhereWithoutAnnotatorUserInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput | OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput | OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutUserInput | OrganizationMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMembershipCreateWithoutUserInput, ProjectMembershipUncheckedCreateWithoutUserInput> | ProjectMembershipCreateWithoutUserInput[] | ProjectMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutUserInput | ProjectMembershipCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMembershipUpsertWithWhereUniqueWithoutUserInput | ProjectMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMembershipCreateManyUserInputEnvelope
    set?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    disconnect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    delete?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    update?: ProjectMembershipUpdateWithWhereUniqueWithoutUserInput | ProjectMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMembershipUpdateManyWithWhereWithoutUserInput | ProjectMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
  }

  export type MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput = {
    create?: XOR<MembershipInvitationCreateWithoutInvitedByUserInput, MembershipInvitationUncheckedCreateWithoutInvitedByUserInput> | MembershipInvitationCreateWithoutInvitedByUserInput[] | MembershipInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutInvitedByUserInput | MembershipInvitationCreateOrConnectWithoutInvitedByUserInput[]
    upsert?: MembershipInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput | MembershipInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput[]
    createMany?: MembershipInvitationCreateManyInvitedByUserInputEnvelope
    set?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    disconnect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    delete?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    update?: MembershipInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput | MembershipInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput[]
    updateMany?: MembershipInvitationUpdateManyWithWhereWithoutInvitedByUserInput | MembershipInvitationUpdateManyWithWhereWithoutInvitedByUserInput[]
    deleteMany?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutLockedByUserInput, AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput> | AnnotationQueueItemCreateWithoutLockedByUserInput[] | AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput | AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutLockedByUserInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutLockedByUserInput[]
    createMany?: AnnotationQueueItemCreateManyLockedByUserInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutLockedByUserInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutLockedByUserInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutLockedByUserInput | AnnotationQueueItemUpdateManyWithWhereWithoutLockedByUserInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput> | AnnotationQueueItemCreateWithoutAnnotatorUserInput[] | AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput | AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutAnnotatorUserInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutAnnotatorUserInput[]
    createMany?: AnnotationQueueItemCreateManyAnnotatorUserInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutAnnotatorUserInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutAnnotatorUserInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutAnnotatorUserInput | AnnotationQueueItemUpdateManyWithWhereWithoutAnnotatorUserInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type OrganizationMembershipCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type MembershipInvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MembershipInvitationCreateWithoutOrganizationInput, MembershipInvitationUncheckedCreateWithoutOrganizationInput> | MembershipInvitationCreateWithoutOrganizationInput[] | MembershipInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutOrganizationInput | MembershipInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: MembershipInvitationCreateManyOrganizationInputEnvelope
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
  }

  export type OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type MembershipInvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MembershipInvitationCreateWithoutOrganizationInput, MembershipInvitationUncheckedCreateWithoutOrganizationInput> | MembershipInvitationCreateWithoutOrganizationInput[] | MembershipInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutOrganizationInput | MembershipInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: MembershipInvitationCreateManyOrganizationInputEnvelope
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
  }

  export type OrganizationMembershipUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput | OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type MembershipInvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MembershipInvitationCreateWithoutOrganizationInput, MembershipInvitationUncheckedCreateWithoutOrganizationInput> | MembershipInvitationCreateWithoutOrganizationInput[] | MembershipInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutOrganizationInput | MembershipInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: MembershipInvitationUpsertWithWhereUniqueWithoutOrganizationInput | MembershipInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MembershipInvitationCreateManyOrganizationInputEnvelope
    set?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    disconnect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    delete?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    update?: MembershipInvitationUpdateWithWhereUniqueWithoutOrganizationInput | MembershipInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MembershipInvitationUpdateManyWithWhereWithoutOrganizationInput | MembershipInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput | OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type MembershipInvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MembershipInvitationCreateWithoutOrganizationInput, MembershipInvitationUncheckedCreateWithoutOrganizationInput> | MembershipInvitationCreateWithoutOrganizationInput[] | MembershipInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutOrganizationInput | MembershipInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: MembershipInvitationUpsertWithWhereUniqueWithoutOrganizationInput | MembershipInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MembershipInvitationCreateManyOrganizationInputEnvelope
    set?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    disconnect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    delete?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    update?: MembershipInvitationUpdateWithWhereUniqueWithoutOrganizationInput | MembershipInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MembershipInvitationUpdateManyWithWhereWithoutOrganizationInput | MembershipInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
  }

  export type ProjectMembershipCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMembershipCreateWithoutProjectInput, ProjectMembershipUncheckedCreateWithoutProjectInput> | ProjectMembershipCreateWithoutProjectInput[] | ProjectMembershipUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutProjectInput | ProjectMembershipCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMembershipCreateManyProjectInputEnvelope
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TraceCreateNestedManyWithoutProjectInput = {
    create?: XOR<TraceCreateWithoutProjectInput, TraceUncheckedCreateWithoutProjectInput> | TraceCreateWithoutProjectInput[] | TraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutProjectInput | TraceCreateOrConnectWithoutProjectInput[]
    createMany?: TraceCreateManyProjectInputEnvelope
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
  }

  export type ObservationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ObservationCreateWithoutProjectInput, ObservationUncheckedCreateWithoutProjectInput> | ObservationCreateWithoutProjectInput[] | ObservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutProjectInput | ObservationCreateOrConnectWithoutProjectInput[]
    createMany?: ObservationCreateManyProjectInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type DatasetCreateNestedManyWithoutProjectInput = {
    create?: XOR<DatasetCreateWithoutProjectInput, DatasetUncheckedCreateWithoutProjectInput> | DatasetCreateWithoutProjectInput[] | DatasetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatasetCreateOrConnectWithoutProjectInput | DatasetCreateOrConnectWithoutProjectInput[]
    createMany?: DatasetCreateManyProjectInputEnvelope
    connect?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
  }

  export type EventsCreateNestedManyWithoutProjectInput = {
    create?: XOR<EventsCreateWithoutProjectInput, EventsUncheckedCreateWithoutProjectInput> | EventsCreateWithoutProjectInput[] | EventsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutProjectInput | EventsCreateOrConnectWithoutProjectInput[]
    createMany?: EventsCreateManyProjectInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type MembershipInvitationCreateNestedManyWithoutProjectInput = {
    create?: XOR<MembershipInvitationCreateWithoutProjectInput, MembershipInvitationUncheckedCreateWithoutProjectInput> | MembershipInvitationCreateWithoutProjectInput[] | MembershipInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutProjectInput | MembershipInvitationCreateOrConnectWithoutProjectInput[]
    createMany?: MembershipInvitationCreateManyProjectInputEnvelope
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
  }

  export type TraceSessionCreateNestedManyWithoutProjectInput = {
    create?: XOR<TraceSessionCreateWithoutProjectInput, TraceSessionUncheckedCreateWithoutProjectInput> | TraceSessionCreateWithoutProjectInput[] | TraceSessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceSessionCreateOrConnectWithoutProjectInput | TraceSessionCreateOrConnectWithoutProjectInput[]
    createMany?: TraceSessionCreateManyProjectInputEnvelope
    connect?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
  }

  export type PromptCreateNestedManyWithoutProjectInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type ModelCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModelCreateWithoutProjectInput, ModelUncheckedCreateWithoutProjectInput> | ModelCreateWithoutProjectInput[] | ModelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProjectInput | ModelCreateOrConnectWithoutProjectInput[]
    createMany?: ModelCreateManyProjectInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type EvalTemplateCreateNestedManyWithoutProjectInput = {
    create?: XOR<EvalTemplateCreateWithoutProjectInput, EvalTemplateUncheckedCreateWithoutProjectInput> | EvalTemplateCreateWithoutProjectInput[] | EvalTemplateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EvalTemplateCreateOrConnectWithoutProjectInput | EvalTemplateCreateOrConnectWithoutProjectInput[]
    createMany?: EvalTemplateCreateManyProjectInputEnvelope
    connect?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
  }

  export type JobConfigurationCreateNestedManyWithoutProjectInput = {
    create?: XOR<JobConfigurationCreateWithoutProjectInput, JobConfigurationUncheckedCreateWithoutProjectInput> | JobConfigurationCreateWithoutProjectInput[] | JobConfigurationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutProjectInput | JobConfigurationCreateOrConnectWithoutProjectInput[]
    createMany?: JobConfigurationCreateManyProjectInputEnvelope
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
  }

  export type JobExecutionCreateNestedManyWithoutProjectInput = {
    create?: XOR<JobExecutionCreateWithoutProjectInput, JobExecutionUncheckedCreateWithoutProjectInput> | JobExecutionCreateWithoutProjectInput[] | JobExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutProjectInput | JobExecutionCreateOrConnectWithoutProjectInput[]
    createMany?: JobExecutionCreateManyProjectInputEnvelope
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
  }

  export type LlmApiKeysCreateNestedManyWithoutProjectInput = {
    create?: XOR<LlmApiKeysCreateWithoutProjectInput, LlmApiKeysUncheckedCreateWithoutProjectInput> | LlmApiKeysCreateWithoutProjectInput[] | LlmApiKeysUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LlmApiKeysCreateOrConnectWithoutProjectInput | LlmApiKeysCreateOrConnectWithoutProjectInput[]
    createMany?: LlmApiKeysCreateManyProjectInputEnvelope
    connect?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
  }

  export type PosthogIntegrationCreateNestedManyWithoutProjectInput = {
    create?: XOR<PosthogIntegrationCreateWithoutProjectInput, PosthogIntegrationUncheckedCreateWithoutProjectInput> | PosthogIntegrationCreateWithoutProjectInput[] | PosthogIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PosthogIntegrationCreateOrConnectWithoutProjectInput | PosthogIntegrationCreateOrConnectWithoutProjectInput[]
    createMany?: PosthogIntegrationCreateManyProjectInputEnvelope
    connect?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
  }

  export type ScoreCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScoreCreateWithoutProjectInput, ScoreUncheckedCreateWithoutProjectInput> | ScoreCreateWithoutProjectInput[] | ScoreUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutProjectInput | ScoreCreateOrConnectWithoutProjectInput[]
    createMany?: ScoreCreateManyProjectInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type ScoreConfigCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScoreConfigCreateWithoutProjectInput, ScoreConfigUncheckedCreateWithoutProjectInput> | ScoreConfigCreateWithoutProjectInput[] | ScoreConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreConfigCreateOrConnectWithoutProjectInput | ScoreConfigCreateOrConnectWithoutProjectInput[]
    createMany?: ScoreConfigCreateManyProjectInputEnvelope
    connect?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
  }

  export type BatchExportCreateNestedManyWithoutProjectInput = {
    create?: XOR<BatchExportCreateWithoutProjectInput, BatchExportUncheckedCreateWithoutProjectInput> | BatchExportCreateWithoutProjectInput[] | BatchExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BatchExportCreateOrConnectWithoutProjectInput | BatchExportCreateOrConnectWithoutProjectInput[]
    createMany?: BatchExportCreateManyProjectInputEnvelope
    connect?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AnnotationQueueCreateNestedManyWithoutProjectInput = {
    create?: XOR<AnnotationQueueCreateWithoutProjectInput, AnnotationQueueUncheckedCreateWithoutProjectInput> | AnnotationQueueCreateWithoutProjectInput[] | AnnotationQueueUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueCreateOrConnectWithoutProjectInput | AnnotationQueueCreateOrConnectWithoutProjectInput[]
    createMany?: AnnotationQueueCreateManyProjectInputEnvelope
    connect?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
  }

  export type AnnotationQueueItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutProjectInput, AnnotationQueueItemUncheckedCreateWithoutProjectInput> | AnnotationQueueItemCreateWithoutProjectInput[] | AnnotationQueueItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutProjectInput | AnnotationQueueItemCreateOrConnectWithoutProjectInput[]
    createMany?: AnnotationQueueItemCreateManyProjectInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type TraceMediaCreateNestedManyWithoutProjectInput = {
    create?: XOR<TraceMediaCreateWithoutProjectInput, TraceMediaUncheckedCreateWithoutProjectInput> | TraceMediaCreateWithoutProjectInput[] | TraceMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutProjectInput | TraceMediaCreateOrConnectWithoutProjectInput[]
    createMany?: TraceMediaCreateManyProjectInputEnvelope
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutProjectInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ObservationMediaCreateNestedManyWithoutProjectInput = {
    create?: XOR<ObservationMediaCreateWithoutProjectInput, ObservationMediaUncheckedCreateWithoutProjectInput> | ObservationMediaCreateWithoutProjectInput[] | ObservationMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutProjectInput | ObservationMediaCreateOrConnectWithoutProjectInput[]
    createMany?: ObservationMediaCreateManyProjectInputEnvelope
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
  }

  export type ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMembershipCreateWithoutProjectInput, ProjectMembershipUncheckedCreateWithoutProjectInput> | ProjectMembershipCreateWithoutProjectInput[] | ProjectMembershipUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutProjectInput | ProjectMembershipCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMembershipCreateManyProjectInputEnvelope
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
  }

  export type TraceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TraceCreateWithoutProjectInput, TraceUncheckedCreateWithoutProjectInput> | TraceCreateWithoutProjectInput[] | TraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutProjectInput | TraceCreateOrConnectWithoutProjectInput[]
    createMany?: TraceCreateManyProjectInputEnvelope
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
  }

  export type ObservationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ObservationCreateWithoutProjectInput, ObservationUncheckedCreateWithoutProjectInput> | ObservationCreateWithoutProjectInput[] | ObservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutProjectInput | ObservationCreateOrConnectWithoutProjectInput[]
    createMany?: ObservationCreateManyProjectInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type DatasetUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DatasetCreateWithoutProjectInput, DatasetUncheckedCreateWithoutProjectInput> | DatasetCreateWithoutProjectInput[] | DatasetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatasetCreateOrConnectWithoutProjectInput | DatasetCreateOrConnectWithoutProjectInput[]
    createMany?: DatasetCreateManyProjectInputEnvelope
    connect?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EventsCreateWithoutProjectInput, EventsUncheckedCreateWithoutProjectInput> | EventsCreateWithoutProjectInput[] | EventsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutProjectInput | EventsCreateOrConnectWithoutProjectInput[]
    createMany?: EventsCreateManyProjectInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MembershipInvitationCreateWithoutProjectInput, MembershipInvitationUncheckedCreateWithoutProjectInput> | MembershipInvitationCreateWithoutProjectInput[] | MembershipInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutProjectInput | MembershipInvitationCreateOrConnectWithoutProjectInput[]
    createMany?: MembershipInvitationCreateManyProjectInputEnvelope
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
  }

  export type TraceSessionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TraceSessionCreateWithoutProjectInput, TraceSessionUncheckedCreateWithoutProjectInput> | TraceSessionCreateWithoutProjectInput[] | TraceSessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceSessionCreateOrConnectWithoutProjectInput | TraceSessionCreateOrConnectWithoutProjectInput[]
    createMany?: TraceSessionCreateManyProjectInputEnvelope
    connect?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
  }

  export type PromptUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModelCreateWithoutProjectInput, ModelUncheckedCreateWithoutProjectInput> | ModelCreateWithoutProjectInput[] | ModelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProjectInput | ModelCreateOrConnectWithoutProjectInput[]
    createMany?: ModelCreateManyProjectInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type EvalTemplateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EvalTemplateCreateWithoutProjectInput, EvalTemplateUncheckedCreateWithoutProjectInput> | EvalTemplateCreateWithoutProjectInput[] | EvalTemplateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EvalTemplateCreateOrConnectWithoutProjectInput | EvalTemplateCreateOrConnectWithoutProjectInput[]
    createMany?: EvalTemplateCreateManyProjectInputEnvelope
    connect?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
  }

  export type JobConfigurationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<JobConfigurationCreateWithoutProjectInput, JobConfigurationUncheckedCreateWithoutProjectInput> | JobConfigurationCreateWithoutProjectInput[] | JobConfigurationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutProjectInput | JobConfigurationCreateOrConnectWithoutProjectInput[]
    createMany?: JobConfigurationCreateManyProjectInputEnvelope
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
  }

  export type JobExecutionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<JobExecutionCreateWithoutProjectInput, JobExecutionUncheckedCreateWithoutProjectInput> | JobExecutionCreateWithoutProjectInput[] | JobExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutProjectInput | JobExecutionCreateOrConnectWithoutProjectInput[]
    createMany?: JobExecutionCreateManyProjectInputEnvelope
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
  }

  export type LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LlmApiKeysCreateWithoutProjectInput, LlmApiKeysUncheckedCreateWithoutProjectInput> | LlmApiKeysCreateWithoutProjectInput[] | LlmApiKeysUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LlmApiKeysCreateOrConnectWithoutProjectInput | LlmApiKeysCreateOrConnectWithoutProjectInput[]
    createMany?: LlmApiKeysCreateManyProjectInputEnvelope
    connect?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
  }

  export type PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PosthogIntegrationCreateWithoutProjectInput, PosthogIntegrationUncheckedCreateWithoutProjectInput> | PosthogIntegrationCreateWithoutProjectInput[] | PosthogIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PosthogIntegrationCreateOrConnectWithoutProjectInput | PosthogIntegrationCreateOrConnectWithoutProjectInput[]
    createMany?: PosthogIntegrationCreateManyProjectInputEnvelope
    connect?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
  }

  export type ScoreUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScoreCreateWithoutProjectInput, ScoreUncheckedCreateWithoutProjectInput> | ScoreCreateWithoutProjectInput[] | ScoreUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutProjectInput | ScoreCreateOrConnectWithoutProjectInput[]
    createMany?: ScoreCreateManyProjectInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type ScoreConfigUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScoreConfigCreateWithoutProjectInput, ScoreConfigUncheckedCreateWithoutProjectInput> | ScoreConfigCreateWithoutProjectInput[] | ScoreConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreConfigCreateOrConnectWithoutProjectInput | ScoreConfigCreateOrConnectWithoutProjectInput[]
    createMany?: ScoreConfigCreateManyProjectInputEnvelope
    connect?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
  }

  export type BatchExportUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BatchExportCreateWithoutProjectInput, BatchExportUncheckedCreateWithoutProjectInput> | BatchExportCreateWithoutProjectInput[] | BatchExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BatchExportCreateOrConnectWithoutProjectInput | BatchExportCreateOrConnectWithoutProjectInput[]
    createMany?: BatchExportCreateManyProjectInputEnvelope
    connect?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AnnotationQueueCreateWithoutProjectInput, AnnotationQueueUncheckedCreateWithoutProjectInput> | AnnotationQueueCreateWithoutProjectInput[] | AnnotationQueueUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueCreateOrConnectWithoutProjectInput | AnnotationQueueCreateOrConnectWithoutProjectInput[]
    createMany?: AnnotationQueueCreateManyProjectInputEnvelope
    connect?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
  }

  export type AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutProjectInput, AnnotationQueueItemUncheckedCreateWithoutProjectInput> | AnnotationQueueItemCreateWithoutProjectInput[] | AnnotationQueueItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutProjectInput | AnnotationQueueItemCreateOrConnectWithoutProjectInput[]
    createMany?: AnnotationQueueItemCreateManyProjectInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type TraceMediaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TraceMediaCreateWithoutProjectInput, TraceMediaUncheckedCreateWithoutProjectInput> | TraceMediaCreateWithoutProjectInput[] | TraceMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutProjectInput | TraceMediaCreateOrConnectWithoutProjectInput[]
    createMany?: TraceMediaCreateManyProjectInputEnvelope
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ObservationMediaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ObservationMediaCreateWithoutProjectInput, ObservationMediaUncheckedCreateWithoutProjectInput> | ObservationMediaCreateWithoutProjectInput[] | ObservationMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutProjectInput | ObservationMediaCreateOrConnectWithoutProjectInput[]
    createMany?: ObservationMediaCreateManyProjectInputEnvelope
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
  }

  export type ProjectMembershipUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMembershipCreateWithoutProjectInput, ProjectMembershipUncheckedCreateWithoutProjectInput> | ProjectMembershipCreateWithoutProjectInput[] | ProjectMembershipUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutProjectInput | ProjectMembershipCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMembershipUpsertWithWhereUniqueWithoutProjectInput | ProjectMembershipUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMembershipCreateManyProjectInputEnvelope
    set?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    disconnect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    delete?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    update?: ProjectMembershipUpdateWithWhereUniqueWithoutProjectInput | ProjectMembershipUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMembershipUpdateManyWithWhereWithoutProjectInput | ProjectMembershipUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectsInput, OrganizationUpdateWithoutProjectsInput>, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type TraceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TraceCreateWithoutProjectInput, TraceUncheckedCreateWithoutProjectInput> | TraceCreateWithoutProjectInput[] | TraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutProjectInput | TraceCreateOrConnectWithoutProjectInput[]
    upsert?: TraceUpsertWithWhereUniqueWithoutProjectInput | TraceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TraceCreateManyProjectInputEnvelope
    set?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    disconnect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    delete?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    update?: TraceUpdateWithWhereUniqueWithoutProjectInput | TraceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TraceUpdateManyWithWhereWithoutProjectInput | TraceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TraceScalarWhereInput | TraceScalarWhereInput[]
  }

  export type ObservationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ObservationCreateWithoutProjectInput, ObservationUncheckedCreateWithoutProjectInput> | ObservationCreateWithoutProjectInput[] | ObservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutProjectInput | ObservationCreateOrConnectWithoutProjectInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutProjectInput | ObservationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ObservationCreateManyProjectInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutProjectInput | ObservationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutProjectInput | ObservationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutProjectInput | ApiKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutProjectInput | ApiKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutProjectInput | ApiKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type DatasetUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DatasetCreateWithoutProjectInput, DatasetUncheckedCreateWithoutProjectInput> | DatasetCreateWithoutProjectInput[] | DatasetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatasetCreateOrConnectWithoutProjectInput | DatasetCreateOrConnectWithoutProjectInput[]
    upsert?: DatasetUpsertWithWhereUniqueWithoutProjectInput | DatasetUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DatasetCreateManyProjectInputEnvelope
    set?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    disconnect?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    delete?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    connect?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    update?: DatasetUpdateWithWhereUniqueWithoutProjectInput | DatasetUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DatasetUpdateManyWithWhereWithoutProjectInput | DatasetUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DatasetScalarWhereInput | DatasetScalarWhereInput[]
  }

  export type EventsUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EventsCreateWithoutProjectInput, EventsUncheckedCreateWithoutProjectInput> | EventsCreateWithoutProjectInput[] | EventsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutProjectInput | EventsCreateOrConnectWithoutProjectInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutProjectInput | EventsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EventsCreateManyProjectInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutProjectInput | EventsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutProjectInput | EventsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type MembershipInvitationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MembershipInvitationCreateWithoutProjectInput, MembershipInvitationUncheckedCreateWithoutProjectInput> | MembershipInvitationCreateWithoutProjectInput[] | MembershipInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutProjectInput | MembershipInvitationCreateOrConnectWithoutProjectInput[]
    upsert?: MembershipInvitationUpsertWithWhereUniqueWithoutProjectInput | MembershipInvitationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MembershipInvitationCreateManyProjectInputEnvelope
    set?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    disconnect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    delete?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    update?: MembershipInvitationUpdateWithWhereUniqueWithoutProjectInput | MembershipInvitationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MembershipInvitationUpdateManyWithWhereWithoutProjectInput | MembershipInvitationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
  }

  export type TraceSessionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TraceSessionCreateWithoutProjectInput, TraceSessionUncheckedCreateWithoutProjectInput> | TraceSessionCreateWithoutProjectInput[] | TraceSessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceSessionCreateOrConnectWithoutProjectInput | TraceSessionCreateOrConnectWithoutProjectInput[]
    upsert?: TraceSessionUpsertWithWhereUniqueWithoutProjectInput | TraceSessionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TraceSessionCreateManyProjectInputEnvelope
    set?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    disconnect?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    delete?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    connect?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    update?: TraceSessionUpdateWithWhereUniqueWithoutProjectInput | TraceSessionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TraceSessionUpdateManyWithWhereWithoutProjectInput | TraceSessionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TraceSessionScalarWhereInput | TraceSessionScalarWhereInput[]
  }

  export type PromptUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutProjectInput | PromptUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutProjectInput | PromptUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutProjectInput | PromptUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type ModelUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModelCreateWithoutProjectInput, ModelUncheckedCreateWithoutProjectInput> | ModelCreateWithoutProjectInput[] | ModelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProjectInput | ModelCreateOrConnectWithoutProjectInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutProjectInput | ModelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModelCreateManyProjectInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutProjectInput | ModelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutProjectInput | ModelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type EvalTemplateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EvalTemplateCreateWithoutProjectInput, EvalTemplateUncheckedCreateWithoutProjectInput> | EvalTemplateCreateWithoutProjectInput[] | EvalTemplateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EvalTemplateCreateOrConnectWithoutProjectInput | EvalTemplateCreateOrConnectWithoutProjectInput[]
    upsert?: EvalTemplateUpsertWithWhereUniqueWithoutProjectInput | EvalTemplateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EvalTemplateCreateManyProjectInputEnvelope
    set?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    disconnect?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    delete?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    connect?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    update?: EvalTemplateUpdateWithWhereUniqueWithoutProjectInput | EvalTemplateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EvalTemplateUpdateManyWithWhereWithoutProjectInput | EvalTemplateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EvalTemplateScalarWhereInput | EvalTemplateScalarWhereInput[]
  }

  export type JobConfigurationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<JobConfigurationCreateWithoutProjectInput, JobConfigurationUncheckedCreateWithoutProjectInput> | JobConfigurationCreateWithoutProjectInput[] | JobConfigurationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutProjectInput | JobConfigurationCreateOrConnectWithoutProjectInput[]
    upsert?: JobConfigurationUpsertWithWhereUniqueWithoutProjectInput | JobConfigurationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: JobConfigurationCreateManyProjectInputEnvelope
    set?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    disconnect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    delete?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    update?: JobConfigurationUpdateWithWhereUniqueWithoutProjectInput | JobConfigurationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: JobConfigurationUpdateManyWithWhereWithoutProjectInput | JobConfigurationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: JobConfigurationScalarWhereInput | JobConfigurationScalarWhereInput[]
  }

  export type JobExecutionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<JobExecutionCreateWithoutProjectInput, JobExecutionUncheckedCreateWithoutProjectInput> | JobExecutionCreateWithoutProjectInput[] | JobExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutProjectInput | JobExecutionCreateOrConnectWithoutProjectInput[]
    upsert?: JobExecutionUpsertWithWhereUniqueWithoutProjectInput | JobExecutionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: JobExecutionCreateManyProjectInputEnvelope
    set?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    disconnect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    delete?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    update?: JobExecutionUpdateWithWhereUniqueWithoutProjectInput | JobExecutionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: JobExecutionUpdateManyWithWhereWithoutProjectInput | JobExecutionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: JobExecutionScalarWhereInput | JobExecutionScalarWhereInput[]
  }

  export type LlmApiKeysUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LlmApiKeysCreateWithoutProjectInput, LlmApiKeysUncheckedCreateWithoutProjectInput> | LlmApiKeysCreateWithoutProjectInput[] | LlmApiKeysUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LlmApiKeysCreateOrConnectWithoutProjectInput | LlmApiKeysCreateOrConnectWithoutProjectInput[]
    upsert?: LlmApiKeysUpsertWithWhereUniqueWithoutProjectInput | LlmApiKeysUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LlmApiKeysCreateManyProjectInputEnvelope
    set?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    disconnect?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    delete?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    connect?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    update?: LlmApiKeysUpdateWithWhereUniqueWithoutProjectInput | LlmApiKeysUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LlmApiKeysUpdateManyWithWhereWithoutProjectInput | LlmApiKeysUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LlmApiKeysScalarWhereInput | LlmApiKeysScalarWhereInput[]
  }

  export type PosthogIntegrationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PosthogIntegrationCreateWithoutProjectInput, PosthogIntegrationUncheckedCreateWithoutProjectInput> | PosthogIntegrationCreateWithoutProjectInput[] | PosthogIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PosthogIntegrationCreateOrConnectWithoutProjectInput | PosthogIntegrationCreateOrConnectWithoutProjectInput[]
    upsert?: PosthogIntegrationUpsertWithWhereUniqueWithoutProjectInput | PosthogIntegrationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PosthogIntegrationCreateManyProjectInputEnvelope
    set?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    disconnect?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    delete?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    connect?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    update?: PosthogIntegrationUpdateWithWhereUniqueWithoutProjectInput | PosthogIntegrationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PosthogIntegrationUpdateManyWithWhereWithoutProjectInput | PosthogIntegrationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PosthogIntegrationScalarWhereInput | PosthogIntegrationScalarWhereInput[]
  }

  export type ScoreUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScoreCreateWithoutProjectInput, ScoreUncheckedCreateWithoutProjectInput> | ScoreCreateWithoutProjectInput[] | ScoreUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutProjectInput | ScoreCreateOrConnectWithoutProjectInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutProjectInput | ScoreUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScoreCreateManyProjectInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutProjectInput | ScoreUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutProjectInput | ScoreUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type ScoreConfigUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScoreConfigCreateWithoutProjectInput, ScoreConfigUncheckedCreateWithoutProjectInput> | ScoreConfigCreateWithoutProjectInput[] | ScoreConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreConfigCreateOrConnectWithoutProjectInput | ScoreConfigCreateOrConnectWithoutProjectInput[]
    upsert?: ScoreConfigUpsertWithWhereUniqueWithoutProjectInput | ScoreConfigUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScoreConfigCreateManyProjectInputEnvelope
    set?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    disconnect?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    delete?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    connect?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    update?: ScoreConfigUpdateWithWhereUniqueWithoutProjectInput | ScoreConfigUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScoreConfigUpdateManyWithWhereWithoutProjectInput | ScoreConfigUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScoreConfigScalarWhereInput | ScoreConfigScalarWhereInput[]
  }

  export type BatchExportUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BatchExportCreateWithoutProjectInput, BatchExportUncheckedCreateWithoutProjectInput> | BatchExportCreateWithoutProjectInput[] | BatchExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BatchExportCreateOrConnectWithoutProjectInput | BatchExportCreateOrConnectWithoutProjectInput[]
    upsert?: BatchExportUpsertWithWhereUniqueWithoutProjectInput | BatchExportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BatchExportCreateManyProjectInputEnvelope
    set?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    disconnect?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    delete?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    connect?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    update?: BatchExportUpdateWithWhereUniqueWithoutProjectInput | BatchExportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BatchExportUpdateManyWithWhereWithoutProjectInput | BatchExportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BatchExportScalarWhereInput | BatchExportScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProjectInput | CommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProjectInput | CommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProjectInput | CommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AnnotationQueueUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AnnotationQueueCreateWithoutProjectInput, AnnotationQueueUncheckedCreateWithoutProjectInput> | AnnotationQueueCreateWithoutProjectInput[] | AnnotationQueueUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueCreateOrConnectWithoutProjectInput | AnnotationQueueCreateOrConnectWithoutProjectInput[]
    upsert?: AnnotationQueueUpsertWithWhereUniqueWithoutProjectInput | AnnotationQueueUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AnnotationQueueCreateManyProjectInputEnvelope
    set?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    disconnect?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    delete?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    connect?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    update?: AnnotationQueueUpdateWithWhereUniqueWithoutProjectInput | AnnotationQueueUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AnnotationQueueUpdateManyWithWhereWithoutProjectInput | AnnotationQueueUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AnnotationQueueScalarWhereInput | AnnotationQueueScalarWhereInput[]
  }

  export type AnnotationQueueItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutProjectInput, AnnotationQueueItemUncheckedCreateWithoutProjectInput> | AnnotationQueueItemCreateWithoutProjectInput[] | AnnotationQueueItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutProjectInput | AnnotationQueueItemCreateOrConnectWithoutProjectInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutProjectInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AnnotationQueueItemCreateManyProjectInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutProjectInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutProjectInput | AnnotationQueueItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type TraceMediaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TraceMediaCreateWithoutProjectInput, TraceMediaUncheckedCreateWithoutProjectInput> | TraceMediaCreateWithoutProjectInput[] | TraceMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutProjectInput | TraceMediaCreateOrConnectWithoutProjectInput[]
    upsert?: TraceMediaUpsertWithWhereUniqueWithoutProjectInput | TraceMediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TraceMediaCreateManyProjectInputEnvelope
    set?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    disconnect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    delete?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    update?: TraceMediaUpdateWithWhereUniqueWithoutProjectInput | TraceMediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TraceMediaUpdateManyWithWhereWithoutProjectInput | TraceMediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TraceMediaScalarWhereInput | TraceMediaScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProjectInput | MediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProjectInput | MediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProjectInput | MediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ObservationMediaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ObservationMediaCreateWithoutProjectInput, ObservationMediaUncheckedCreateWithoutProjectInput> | ObservationMediaCreateWithoutProjectInput[] | ObservationMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutProjectInput | ObservationMediaCreateOrConnectWithoutProjectInput[]
    upsert?: ObservationMediaUpsertWithWhereUniqueWithoutProjectInput | ObservationMediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ObservationMediaCreateManyProjectInputEnvelope
    set?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    disconnect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    delete?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    update?: ObservationMediaUpdateWithWhereUniqueWithoutProjectInput | ObservationMediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ObservationMediaUpdateManyWithWhereWithoutProjectInput | ObservationMediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ObservationMediaScalarWhereInput | ObservationMediaScalarWhereInput[]
  }

  export type ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMembershipCreateWithoutProjectInput, ProjectMembershipUncheckedCreateWithoutProjectInput> | ProjectMembershipCreateWithoutProjectInput[] | ProjectMembershipUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutProjectInput | ProjectMembershipCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMembershipUpsertWithWhereUniqueWithoutProjectInput | ProjectMembershipUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMembershipCreateManyProjectInputEnvelope
    set?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    disconnect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    delete?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    update?: ProjectMembershipUpdateWithWhereUniqueWithoutProjectInput | ProjectMembershipUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMembershipUpdateManyWithWhereWithoutProjectInput | ProjectMembershipUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
  }

  export type TraceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TraceCreateWithoutProjectInput, TraceUncheckedCreateWithoutProjectInput> | TraceCreateWithoutProjectInput[] | TraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutProjectInput | TraceCreateOrConnectWithoutProjectInput[]
    upsert?: TraceUpsertWithWhereUniqueWithoutProjectInput | TraceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TraceCreateManyProjectInputEnvelope
    set?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    disconnect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    delete?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    update?: TraceUpdateWithWhereUniqueWithoutProjectInput | TraceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TraceUpdateManyWithWhereWithoutProjectInput | TraceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TraceScalarWhereInput | TraceScalarWhereInput[]
  }

  export type ObservationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ObservationCreateWithoutProjectInput, ObservationUncheckedCreateWithoutProjectInput> | ObservationCreateWithoutProjectInput[] | ObservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutProjectInput | ObservationCreateOrConnectWithoutProjectInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutProjectInput | ObservationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ObservationCreateManyProjectInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutProjectInput | ObservationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutProjectInput | ObservationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutProjectInput | ApiKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutProjectInput | ApiKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutProjectInput | ApiKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type DatasetUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DatasetCreateWithoutProjectInput, DatasetUncheckedCreateWithoutProjectInput> | DatasetCreateWithoutProjectInput[] | DatasetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatasetCreateOrConnectWithoutProjectInput | DatasetCreateOrConnectWithoutProjectInput[]
    upsert?: DatasetUpsertWithWhereUniqueWithoutProjectInput | DatasetUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DatasetCreateManyProjectInputEnvelope
    set?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    disconnect?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    delete?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    connect?: DatasetWhereUniqueInput | DatasetWhereUniqueInput[]
    update?: DatasetUpdateWithWhereUniqueWithoutProjectInput | DatasetUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DatasetUpdateManyWithWhereWithoutProjectInput | DatasetUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DatasetScalarWhereInput | DatasetScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EventsCreateWithoutProjectInput, EventsUncheckedCreateWithoutProjectInput> | EventsCreateWithoutProjectInput[] | EventsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutProjectInput | EventsCreateOrConnectWithoutProjectInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutProjectInput | EventsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EventsCreateManyProjectInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutProjectInput | EventsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutProjectInput | EventsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MembershipInvitationCreateWithoutProjectInput, MembershipInvitationUncheckedCreateWithoutProjectInput> | MembershipInvitationCreateWithoutProjectInput[] | MembershipInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MembershipInvitationCreateOrConnectWithoutProjectInput | MembershipInvitationCreateOrConnectWithoutProjectInput[]
    upsert?: MembershipInvitationUpsertWithWhereUniqueWithoutProjectInput | MembershipInvitationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MembershipInvitationCreateManyProjectInputEnvelope
    set?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    disconnect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    delete?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    connect?: MembershipInvitationWhereUniqueInput | MembershipInvitationWhereUniqueInput[]
    update?: MembershipInvitationUpdateWithWhereUniqueWithoutProjectInput | MembershipInvitationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MembershipInvitationUpdateManyWithWhereWithoutProjectInput | MembershipInvitationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
  }

  export type TraceSessionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TraceSessionCreateWithoutProjectInput, TraceSessionUncheckedCreateWithoutProjectInput> | TraceSessionCreateWithoutProjectInput[] | TraceSessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceSessionCreateOrConnectWithoutProjectInput | TraceSessionCreateOrConnectWithoutProjectInput[]
    upsert?: TraceSessionUpsertWithWhereUniqueWithoutProjectInput | TraceSessionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TraceSessionCreateManyProjectInputEnvelope
    set?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    disconnect?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    delete?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    connect?: TraceSessionWhereUniqueInput | TraceSessionWhereUniqueInput[]
    update?: TraceSessionUpdateWithWhereUniqueWithoutProjectInput | TraceSessionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TraceSessionUpdateManyWithWhereWithoutProjectInput | TraceSessionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TraceSessionScalarWhereInput | TraceSessionScalarWhereInput[]
  }

  export type PromptUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutProjectInput | PromptUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutProjectInput | PromptUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutProjectInput | PromptUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModelCreateWithoutProjectInput, ModelUncheckedCreateWithoutProjectInput> | ModelCreateWithoutProjectInput[] | ModelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProjectInput | ModelCreateOrConnectWithoutProjectInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutProjectInput | ModelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModelCreateManyProjectInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutProjectInput | ModelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutProjectInput | ModelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EvalTemplateCreateWithoutProjectInput, EvalTemplateUncheckedCreateWithoutProjectInput> | EvalTemplateCreateWithoutProjectInput[] | EvalTemplateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EvalTemplateCreateOrConnectWithoutProjectInput | EvalTemplateCreateOrConnectWithoutProjectInput[]
    upsert?: EvalTemplateUpsertWithWhereUniqueWithoutProjectInput | EvalTemplateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EvalTemplateCreateManyProjectInputEnvelope
    set?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    disconnect?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    delete?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    connect?: EvalTemplateWhereUniqueInput | EvalTemplateWhereUniqueInput[]
    update?: EvalTemplateUpdateWithWhereUniqueWithoutProjectInput | EvalTemplateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EvalTemplateUpdateManyWithWhereWithoutProjectInput | EvalTemplateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EvalTemplateScalarWhereInput | EvalTemplateScalarWhereInput[]
  }

  export type JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<JobConfigurationCreateWithoutProjectInput, JobConfigurationUncheckedCreateWithoutProjectInput> | JobConfigurationCreateWithoutProjectInput[] | JobConfigurationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutProjectInput | JobConfigurationCreateOrConnectWithoutProjectInput[]
    upsert?: JobConfigurationUpsertWithWhereUniqueWithoutProjectInput | JobConfigurationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: JobConfigurationCreateManyProjectInputEnvelope
    set?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    disconnect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    delete?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    update?: JobConfigurationUpdateWithWhereUniqueWithoutProjectInput | JobConfigurationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: JobConfigurationUpdateManyWithWhereWithoutProjectInput | JobConfigurationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: JobConfigurationScalarWhereInput | JobConfigurationScalarWhereInput[]
  }

  export type JobExecutionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<JobExecutionCreateWithoutProjectInput, JobExecutionUncheckedCreateWithoutProjectInput> | JobExecutionCreateWithoutProjectInput[] | JobExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutProjectInput | JobExecutionCreateOrConnectWithoutProjectInput[]
    upsert?: JobExecutionUpsertWithWhereUniqueWithoutProjectInput | JobExecutionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: JobExecutionCreateManyProjectInputEnvelope
    set?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    disconnect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    delete?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    update?: JobExecutionUpdateWithWhereUniqueWithoutProjectInput | JobExecutionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: JobExecutionUpdateManyWithWhereWithoutProjectInput | JobExecutionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: JobExecutionScalarWhereInput | JobExecutionScalarWhereInput[]
  }

  export type LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LlmApiKeysCreateWithoutProjectInput, LlmApiKeysUncheckedCreateWithoutProjectInput> | LlmApiKeysCreateWithoutProjectInput[] | LlmApiKeysUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LlmApiKeysCreateOrConnectWithoutProjectInput | LlmApiKeysCreateOrConnectWithoutProjectInput[]
    upsert?: LlmApiKeysUpsertWithWhereUniqueWithoutProjectInput | LlmApiKeysUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LlmApiKeysCreateManyProjectInputEnvelope
    set?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    disconnect?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    delete?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    connect?: LlmApiKeysWhereUniqueInput | LlmApiKeysWhereUniqueInput[]
    update?: LlmApiKeysUpdateWithWhereUniqueWithoutProjectInput | LlmApiKeysUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LlmApiKeysUpdateManyWithWhereWithoutProjectInput | LlmApiKeysUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LlmApiKeysScalarWhereInput | LlmApiKeysScalarWhereInput[]
  }

  export type PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PosthogIntegrationCreateWithoutProjectInput, PosthogIntegrationUncheckedCreateWithoutProjectInput> | PosthogIntegrationCreateWithoutProjectInput[] | PosthogIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PosthogIntegrationCreateOrConnectWithoutProjectInput | PosthogIntegrationCreateOrConnectWithoutProjectInput[]
    upsert?: PosthogIntegrationUpsertWithWhereUniqueWithoutProjectInput | PosthogIntegrationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PosthogIntegrationCreateManyProjectInputEnvelope
    set?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    disconnect?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    delete?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    connect?: PosthogIntegrationWhereUniqueInput | PosthogIntegrationWhereUniqueInput[]
    update?: PosthogIntegrationUpdateWithWhereUniqueWithoutProjectInput | PosthogIntegrationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PosthogIntegrationUpdateManyWithWhereWithoutProjectInput | PosthogIntegrationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PosthogIntegrationScalarWhereInput | PosthogIntegrationScalarWhereInput[]
  }

  export type ScoreUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScoreCreateWithoutProjectInput, ScoreUncheckedCreateWithoutProjectInput> | ScoreCreateWithoutProjectInput[] | ScoreUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutProjectInput | ScoreCreateOrConnectWithoutProjectInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutProjectInput | ScoreUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScoreCreateManyProjectInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutProjectInput | ScoreUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutProjectInput | ScoreUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScoreConfigCreateWithoutProjectInput, ScoreConfigUncheckedCreateWithoutProjectInput> | ScoreConfigCreateWithoutProjectInput[] | ScoreConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScoreConfigCreateOrConnectWithoutProjectInput | ScoreConfigCreateOrConnectWithoutProjectInput[]
    upsert?: ScoreConfigUpsertWithWhereUniqueWithoutProjectInput | ScoreConfigUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScoreConfigCreateManyProjectInputEnvelope
    set?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    disconnect?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    delete?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    connect?: ScoreConfigWhereUniqueInput | ScoreConfigWhereUniqueInput[]
    update?: ScoreConfigUpdateWithWhereUniqueWithoutProjectInput | ScoreConfigUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScoreConfigUpdateManyWithWhereWithoutProjectInput | ScoreConfigUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScoreConfigScalarWhereInput | ScoreConfigScalarWhereInput[]
  }

  export type BatchExportUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BatchExportCreateWithoutProjectInput, BatchExportUncheckedCreateWithoutProjectInput> | BatchExportCreateWithoutProjectInput[] | BatchExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BatchExportCreateOrConnectWithoutProjectInput | BatchExportCreateOrConnectWithoutProjectInput[]
    upsert?: BatchExportUpsertWithWhereUniqueWithoutProjectInput | BatchExportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BatchExportCreateManyProjectInputEnvelope
    set?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    disconnect?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    delete?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    connect?: BatchExportWhereUniqueInput | BatchExportWhereUniqueInput[]
    update?: BatchExportUpdateWithWhereUniqueWithoutProjectInput | BatchExportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BatchExportUpdateManyWithWhereWithoutProjectInput | BatchExportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BatchExportScalarWhereInput | BatchExportScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProjectInput | CommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProjectInput | CommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProjectInput | CommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AnnotationQueueCreateWithoutProjectInput, AnnotationQueueUncheckedCreateWithoutProjectInput> | AnnotationQueueCreateWithoutProjectInput[] | AnnotationQueueUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueCreateOrConnectWithoutProjectInput | AnnotationQueueCreateOrConnectWithoutProjectInput[]
    upsert?: AnnotationQueueUpsertWithWhereUniqueWithoutProjectInput | AnnotationQueueUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AnnotationQueueCreateManyProjectInputEnvelope
    set?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    disconnect?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    delete?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    connect?: AnnotationQueueWhereUniqueInput | AnnotationQueueWhereUniqueInput[]
    update?: AnnotationQueueUpdateWithWhereUniqueWithoutProjectInput | AnnotationQueueUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AnnotationQueueUpdateManyWithWhereWithoutProjectInput | AnnotationQueueUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AnnotationQueueScalarWhereInput | AnnotationQueueScalarWhereInput[]
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutProjectInput, AnnotationQueueItemUncheckedCreateWithoutProjectInput> | AnnotationQueueItemCreateWithoutProjectInput[] | AnnotationQueueItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutProjectInput | AnnotationQueueItemCreateOrConnectWithoutProjectInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutProjectInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AnnotationQueueItemCreateManyProjectInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutProjectInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutProjectInput | AnnotationQueueItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type TraceMediaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TraceMediaCreateWithoutProjectInput, TraceMediaUncheckedCreateWithoutProjectInput> | TraceMediaCreateWithoutProjectInput[] | TraceMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutProjectInput | TraceMediaCreateOrConnectWithoutProjectInput[]
    upsert?: TraceMediaUpsertWithWhereUniqueWithoutProjectInput | TraceMediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TraceMediaCreateManyProjectInputEnvelope
    set?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    disconnect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    delete?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    update?: TraceMediaUpdateWithWhereUniqueWithoutProjectInput | TraceMediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TraceMediaUpdateManyWithWhereWithoutProjectInput | TraceMediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TraceMediaScalarWhereInput | TraceMediaScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProjectInput | MediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProjectInput | MediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProjectInput | MediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ObservationMediaCreateWithoutProjectInput, ObservationMediaUncheckedCreateWithoutProjectInput> | ObservationMediaCreateWithoutProjectInput[] | ObservationMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutProjectInput | ObservationMediaCreateOrConnectWithoutProjectInput[]
    upsert?: ObservationMediaUpsertWithWhereUniqueWithoutProjectInput | ObservationMediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ObservationMediaCreateManyProjectInputEnvelope
    set?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    disconnect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    delete?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    update?: ObservationMediaUpdateWithWhereUniqueWithoutProjectInput | ObservationMediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ObservationMediaUpdateManyWithWhereWithoutProjectInput | ObservationMediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ObservationMediaScalarWhereInput | ObservationMediaScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiKeysInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiKeysInput
    upsert?: ProjectUpsertWithoutApiKeysInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiKeysInput, ProjectUpdateWithoutApiKeysInput>, ProjectUncheckedUpdateWithoutApiKeysInput>
  }

  export type LlmApiKeysCreatecustomModelsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutLlmApiKeysInput = {
    create?: XOR<ProjectCreateWithoutLlmApiKeysInput, ProjectUncheckedCreateWithoutLlmApiKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLlmApiKeysInput
    connect?: ProjectWhereUniqueInput
  }

  export type LlmApiKeysUpdatecustomModelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutLlmApiKeysNestedInput = {
    create?: XOR<ProjectCreateWithoutLlmApiKeysInput, ProjectUncheckedCreateWithoutLlmApiKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLlmApiKeysInput
    upsert?: ProjectUpsertWithoutLlmApiKeysInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLlmApiKeysInput, ProjectUpdateWithoutLlmApiKeysInput>, ProjectUncheckedUpdateWithoutLlmApiKeysInput>
  }

  export type OrganizationCreateNestedOneWithoutOrganizationMembershipsInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationMembershipsInput, OrganizationUncheckedCreateWithoutOrganizationMembershipsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationMembershipsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationMembershipsInput = {
    create?: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMembershipCreateNestedManyWithoutOrganizationMembershipInput = {
    create?: XOR<ProjectMembershipCreateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput> | ProjectMembershipCreateWithoutOrganizationMembershipInput[] | ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput | ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput[]
    createMany?: ProjectMembershipCreateManyOrganizationMembershipInputEnvelope
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
  }

  export type ProjectMembershipUncheckedCreateNestedManyWithoutOrganizationMembershipInput = {
    create?: XOR<ProjectMembershipCreateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput> | ProjectMembershipCreateWithoutOrganizationMembershipInput[] | ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput | ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput[]
    createMany?: ProjectMembershipCreateManyOrganizationMembershipInputEnvelope
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type OrganizationUpdateOneRequiredWithoutOrganizationMembershipsNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationMembershipsInput, OrganizationUncheckedCreateWithoutOrganizationMembershipsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationMembershipsInput
    upsert?: OrganizationUpsertWithoutOrganizationMembershipsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrganizationMembershipsInput, OrganizationUpdateWithoutOrganizationMembershipsInput>, OrganizationUncheckedUpdateWithoutOrganizationMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationMembershipsInput
    upsert?: UserUpsertWithoutOrganizationMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationMembershipsInput, UserUpdateWithoutOrganizationMembershipsInput>, UserUncheckedUpdateWithoutOrganizationMembershipsInput>
  }

  export type ProjectMembershipUpdateManyWithoutOrganizationMembershipNestedInput = {
    create?: XOR<ProjectMembershipCreateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput> | ProjectMembershipCreateWithoutOrganizationMembershipInput[] | ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput | ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput[]
    upsert?: ProjectMembershipUpsertWithWhereUniqueWithoutOrganizationMembershipInput | ProjectMembershipUpsertWithWhereUniqueWithoutOrganizationMembershipInput[]
    createMany?: ProjectMembershipCreateManyOrganizationMembershipInputEnvelope
    set?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    disconnect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    delete?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    update?: ProjectMembershipUpdateWithWhereUniqueWithoutOrganizationMembershipInput | ProjectMembershipUpdateWithWhereUniqueWithoutOrganizationMembershipInput[]
    updateMany?: ProjectMembershipUpdateManyWithWhereWithoutOrganizationMembershipInput | ProjectMembershipUpdateManyWithWhereWithoutOrganizationMembershipInput[]
    deleteMany?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
  }

  export type ProjectMembershipUncheckedUpdateManyWithoutOrganizationMembershipNestedInput = {
    create?: XOR<ProjectMembershipCreateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput> | ProjectMembershipCreateWithoutOrganizationMembershipInput[] | ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput[]
    connectOrCreate?: ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput | ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput[]
    upsert?: ProjectMembershipUpsertWithWhereUniqueWithoutOrganizationMembershipInput | ProjectMembershipUpsertWithWhereUniqueWithoutOrganizationMembershipInput[]
    createMany?: ProjectMembershipCreateManyOrganizationMembershipInputEnvelope
    set?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    disconnect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    delete?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    connect?: ProjectMembershipWhereUniqueInput | ProjectMembershipWhereUniqueInput[]
    update?: ProjectMembershipUpdateWithWhereUniqueWithoutOrganizationMembershipInput | ProjectMembershipUpdateWithWhereUniqueWithoutOrganizationMembershipInput[]
    updateMany?: ProjectMembershipUpdateManyWithWhereWithoutOrganizationMembershipInput | ProjectMembershipUpdateManyWithWhereWithoutOrganizationMembershipInput[]
    deleteMany?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
  }

  export type OrganizationMembershipCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<OrganizationMembershipCreateWithoutProjectMembershipsInput, OrganizationMembershipUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutProjectMembershipsInput
    connect?: OrganizationMembershipWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationMembershipUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutProjectMembershipsInput, OrganizationMembershipUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutProjectMembershipsInput
    upsert?: OrganizationMembershipUpsertWithoutProjectMembershipsInput
    connect?: OrganizationMembershipWhereUniqueInput
    update?: XOR<XOR<OrganizationMembershipUpdateToOneWithWhereWithoutProjectMembershipsInput, OrganizationMembershipUpdateWithoutProjectMembershipsInput>, OrganizationMembershipUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectMembersInput
    upsert?: ProjectUpsertWithoutProjectMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectMembersInput, ProjectUpdateWithoutProjectMembersInput>, ProjectUncheckedUpdateWithoutProjectMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    upsert?: UserUpsertWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembershipsInput, UserUpdateWithoutProjectMembershipsInput>, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type OrganizationCreateNestedOneWithoutMembershipInvitationInput = {
    create?: XOR<OrganizationCreateWithoutMembershipInvitationInput, OrganizationUncheckedCreateWithoutMembershipInvitationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipInvitationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvitationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type OrganizationUpdateOneRequiredWithoutMembershipInvitationNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembershipInvitationInput, OrganizationUncheckedCreateWithoutMembershipInvitationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipInvitationInput
    upsert?: OrganizationUpsertWithoutMembershipInvitationInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembershipInvitationInput, OrganizationUpdateWithoutMembershipInvitationInput>, OrganizationUncheckedUpdateWithoutMembershipInvitationInput>
  }

  export type ProjectUpdateOneWithoutInvitationsNestedInput = {
    create?: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvitationsInput
    upsert?: ProjectUpsertWithoutInvitationsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInvitationsInput, ProjectUpdateWithoutInvitationsInput>, ProjectUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type ProjectCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSessionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TraceCreateNestedManyWithoutSessionInput = {
    create?: XOR<TraceCreateWithoutSessionInput, TraceUncheckedCreateWithoutSessionInput> | TraceCreateWithoutSessionInput[] | TraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutSessionInput | TraceCreateOrConnectWithoutSessionInput[]
    createMany?: TraceCreateManySessionInputEnvelope
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
  }

  export type TraceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TraceCreateWithoutSessionInput, TraceUncheckedCreateWithoutSessionInput> | TraceCreateWithoutSessionInput[] | TraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutSessionInput | TraceCreateOrConnectWithoutSessionInput[]
    createMany?: TraceCreateManySessionInputEnvelope
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSessionsInput
    upsert?: ProjectUpsertWithoutSessionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSessionsInput, ProjectUpdateWithoutSessionsInput>, ProjectUncheckedUpdateWithoutSessionsInput>
  }

  export type TraceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TraceCreateWithoutSessionInput, TraceUncheckedCreateWithoutSessionInput> | TraceCreateWithoutSessionInput[] | TraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutSessionInput | TraceCreateOrConnectWithoutSessionInput[]
    upsert?: TraceUpsertWithWhereUniqueWithoutSessionInput | TraceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TraceCreateManySessionInputEnvelope
    set?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    disconnect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    delete?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    update?: TraceUpdateWithWhereUniqueWithoutSessionInput | TraceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TraceUpdateManyWithWhereWithoutSessionInput | TraceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TraceScalarWhereInput | TraceScalarWhereInput[]
  }

  export type TraceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TraceCreateWithoutSessionInput, TraceUncheckedCreateWithoutSessionInput> | TraceCreateWithoutSessionInput[] | TraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TraceCreateOrConnectWithoutSessionInput | TraceCreateOrConnectWithoutSessionInput[]
    upsert?: TraceUpsertWithWhereUniqueWithoutSessionInput | TraceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TraceCreateManySessionInputEnvelope
    set?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    disconnect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    delete?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    connect?: TraceWhereUniqueInput | TraceWhereUniqueInput[]
    update?: TraceUpdateWithWhereUniqueWithoutSessionInput | TraceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TraceUpdateManyWithWhereWithoutSessionInput | TraceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TraceScalarWhereInput | TraceScalarWhereInput[]
  }

  export type TraceCreatetagsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutTracesInput = {
    create?: XOR<ProjectCreateWithoutTracesInput, ProjectUncheckedCreateWithoutTracesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTracesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TraceSessionCreateNestedOneWithoutTracesInput = {
    create?: XOR<TraceSessionCreateWithoutTracesInput, TraceSessionUncheckedCreateWithoutTracesInput>
    connectOrCreate?: TraceSessionCreateOrConnectWithoutTracesInput
    connect?: TraceSessionWhereUniqueInput
  }

  export type TraceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutTracesNestedInput = {
    create?: XOR<ProjectCreateWithoutTracesInput, ProjectUncheckedCreateWithoutTracesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTracesInput
    upsert?: ProjectUpsertWithoutTracesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTracesInput, ProjectUpdateWithoutTracesInput>, ProjectUncheckedUpdateWithoutTracesInput>
  }

  export type TraceSessionUpdateOneWithoutTracesNestedInput = {
    create?: XOR<TraceSessionCreateWithoutTracesInput, TraceSessionUncheckedCreateWithoutTracesInput>
    connectOrCreate?: TraceSessionCreateOrConnectWithoutTracesInput
    upsert?: TraceSessionUpsertWithoutTracesInput
    disconnect?: TraceSessionWhereInput | boolean
    delete?: TraceSessionWhereInput | boolean
    connect?: TraceSessionWhereUniqueInput
    update?: XOR<XOR<TraceSessionUpdateToOneWithWhereWithoutTracesInput, TraceSessionUpdateWithoutTracesInput>, TraceSessionUncheckedUpdateWithoutTracesInput>
  }

  export type ProjectCreateNestedOneWithoutObservationsInput = {
    create?: XOR<ProjectCreateWithoutObservationsInput, ProjectUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutObservationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumObservationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ObservationType
  }

  export type EnumObservationLevelFieldUpdateOperationsInput = {
    set?: $Enums.ObservationLevel
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProjectUpdateOneRequiredWithoutObservationsNestedInput = {
    create?: XOR<ProjectCreateWithoutObservationsInput, ProjectUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutObservationsInput
    upsert?: ProjectUpsertWithoutObservationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutObservationsInput, ProjectUpdateWithoutObservationsInput>, ProjectUncheckedUpdateWithoutObservationsInput>
  }

  export type ProjectCreateNestedOneWithoutScoreInput = {
    create?: XOR<ProjectCreateWithoutScoreInput, ProjectUncheckedCreateWithoutScoreInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScoreInput
    connect?: ProjectWhereUniqueInput
  }

  export type ScoreConfigCreateNestedOneWithoutScoreInput = {
    create?: XOR<ScoreConfigCreateWithoutScoreInput, ScoreConfigUncheckedCreateWithoutScoreInput>
    connectOrCreate?: ScoreConfigCreateOrConnectWithoutScoreInput
    connect?: ScoreConfigWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumScoreSourceFieldUpdateOperationsInput = {
    set?: $Enums.ScoreSource
  }

  export type EnumScoreDataTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScoreDataType
  }

  export type ProjectUpdateOneRequiredWithoutScoreNestedInput = {
    create?: XOR<ProjectCreateWithoutScoreInput, ProjectUncheckedCreateWithoutScoreInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScoreInput
    upsert?: ProjectUpsertWithoutScoreInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutScoreInput, ProjectUpdateWithoutScoreInput>, ProjectUncheckedUpdateWithoutScoreInput>
  }

  export type ScoreConfigUpdateOneWithoutScoreNestedInput = {
    create?: XOR<ScoreConfigCreateWithoutScoreInput, ScoreConfigUncheckedCreateWithoutScoreInput>
    connectOrCreate?: ScoreConfigCreateOrConnectWithoutScoreInput
    upsert?: ScoreConfigUpsertWithoutScoreInput
    disconnect?: ScoreConfigWhereInput | boolean
    delete?: ScoreConfigWhereInput | boolean
    connect?: ScoreConfigWhereUniqueInput
    update?: XOR<XOR<ScoreConfigUpdateToOneWithWhereWithoutScoreInput, ScoreConfigUpdateWithoutScoreInput>, ScoreConfigUncheckedUpdateWithoutScoreInput>
  }

  export type ProjectCreateNestedOneWithoutScoreConfigInput = {
    create?: XOR<ProjectCreateWithoutScoreConfigInput, ProjectUncheckedCreateWithoutScoreConfigInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScoreConfigInput
    connect?: ProjectWhereUniqueInput
  }

  export type ScoreCreateNestedManyWithoutScoreConfigInput = {
    create?: XOR<ScoreCreateWithoutScoreConfigInput, ScoreUncheckedCreateWithoutScoreConfigInput> | ScoreCreateWithoutScoreConfigInput[] | ScoreUncheckedCreateWithoutScoreConfigInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutScoreConfigInput | ScoreCreateOrConnectWithoutScoreConfigInput[]
    createMany?: ScoreCreateManyScoreConfigInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type ScoreUncheckedCreateNestedManyWithoutScoreConfigInput = {
    create?: XOR<ScoreCreateWithoutScoreConfigInput, ScoreUncheckedCreateWithoutScoreConfigInput> | ScoreCreateWithoutScoreConfigInput[] | ScoreUncheckedCreateWithoutScoreConfigInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutScoreConfigInput | ScoreCreateOrConnectWithoutScoreConfigInput[]
    createMany?: ScoreCreateManyScoreConfigInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutScoreConfigNestedInput = {
    create?: XOR<ProjectCreateWithoutScoreConfigInput, ProjectUncheckedCreateWithoutScoreConfigInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScoreConfigInput
    upsert?: ProjectUpsertWithoutScoreConfigInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutScoreConfigInput, ProjectUpdateWithoutScoreConfigInput>, ProjectUncheckedUpdateWithoutScoreConfigInput>
  }

  export type ScoreUpdateManyWithoutScoreConfigNestedInput = {
    create?: XOR<ScoreCreateWithoutScoreConfigInput, ScoreUncheckedCreateWithoutScoreConfigInput> | ScoreCreateWithoutScoreConfigInput[] | ScoreUncheckedCreateWithoutScoreConfigInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutScoreConfigInput | ScoreCreateOrConnectWithoutScoreConfigInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutScoreConfigInput | ScoreUpsertWithWhereUniqueWithoutScoreConfigInput[]
    createMany?: ScoreCreateManyScoreConfigInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutScoreConfigInput | ScoreUpdateWithWhereUniqueWithoutScoreConfigInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutScoreConfigInput | ScoreUpdateManyWithWhereWithoutScoreConfigInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type ScoreUncheckedUpdateManyWithoutScoreConfigNestedInput = {
    create?: XOR<ScoreCreateWithoutScoreConfigInput, ScoreUncheckedCreateWithoutScoreConfigInput> | ScoreCreateWithoutScoreConfigInput[] | ScoreUncheckedCreateWithoutScoreConfigInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutScoreConfigInput | ScoreCreateOrConnectWithoutScoreConfigInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutScoreConfigInput | ScoreUpsertWithWhereUniqueWithoutScoreConfigInput[]
    createMany?: ScoreCreateManyScoreConfigInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutScoreConfigInput | ScoreUpdateWithWhereUniqueWithoutScoreConfigInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutScoreConfigInput | ScoreUpdateManyWithWhereWithoutScoreConfigInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type AnnotationQueueCreatescoreConfigIdsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutAnnotationQueueInput = {
    create?: XOR<ProjectCreateWithoutAnnotationQueueInput, ProjectUncheckedCreateWithoutAnnotationQueueInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAnnotationQueueInput
    connect?: ProjectWhereUniqueInput
  }

  export type AnnotationQueueItemCreateNestedManyWithoutQueueInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutQueueInput, AnnotationQueueItemUncheckedCreateWithoutQueueInput> | AnnotationQueueItemCreateWithoutQueueInput[] | AnnotationQueueItemUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutQueueInput | AnnotationQueueItemCreateOrConnectWithoutQueueInput[]
    createMany?: AnnotationQueueItemCreateManyQueueInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type AnnotationQueueItemUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutQueueInput, AnnotationQueueItemUncheckedCreateWithoutQueueInput> | AnnotationQueueItemCreateWithoutQueueInput[] | AnnotationQueueItemUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutQueueInput | AnnotationQueueItemCreateOrConnectWithoutQueueInput[]
    createMany?: AnnotationQueueItemCreateManyQueueInputEnvelope
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
  }

  export type AnnotationQueueUpdatescoreConfigIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutAnnotationQueueNestedInput = {
    create?: XOR<ProjectCreateWithoutAnnotationQueueInput, ProjectUncheckedCreateWithoutAnnotationQueueInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAnnotationQueueInput
    upsert?: ProjectUpsertWithoutAnnotationQueueInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAnnotationQueueInput, ProjectUpdateWithoutAnnotationQueueInput>, ProjectUncheckedUpdateWithoutAnnotationQueueInput>
  }

  export type AnnotationQueueItemUpdateManyWithoutQueueNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutQueueInput, AnnotationQueueItemUncheckedCreateWithoutQueueInput> | AnnotationQueueItemCreateWithoutQueueInput[] | AnnotationQueueItemUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutQueueInput | AnnotationQueueItemCreateOrConnectWithoutQueueInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutQueueInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: AnnotationQueueItemCreateManyQueueInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutQueueInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutQueueInput | AnnotationQueueItemUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<AnnotationQueueItemCreateWithoutQueueInput, AnnotationQueueItemUncheckedCreateWithoutQueueInput> | AnnotationQueueItemCreateWithoutQueueInput[] | AnnotationQueueItemUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: AnnotationQueueItemCreateOrConnectWithoutQueueInput | AnnotationQueueItemCreateOrConnectWithoutQueueInput[]
    upsert?: AnnotationQueueItemUpsertWithWhereUniqueWithoutQueueInput | AnnotationQueueItemUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: AnnotationQueueItemCreateManyQueueInputEnvelope
    set?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    disconnect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    delete?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    connect?: AnnotationQueueItemWhereUniqueInput | AnnotationQueueItemWhereUniqueInput[]
    update?: AnnotationQueueItemUpdateWithWhereUniqueWithoutQueueInput | AnnotationQueueItemUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: AnnotationQueueItemUpdateManyWithWhereWithoutQueueInput | AnnotationQueueItemUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
  }

  export type AnnotationQueueCreateNestedOneWithoutAnnotationQueueItemInput = {
    create?: XOR<AnnotationQueueCreateWithoutAnnotationQueueItemInput, AnnotationQueueUncheckedCreateWithoutAnnotationQueueItemInput>
    connectOrCreate?: AnnotationQueueCreateOrConnectWithoutAnnotationQueueItemInput
    connect?: AnnotationQueueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnotatedLockedItemInput = {
    create?: XOR<UserCreateWithoutAnnotatedLockedItemInput, UserUncheckedCreateWithoutAnnotatedLockedItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotatedLockedItemInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnotatedCompletedItemInput = {
    create?: XOR<UserCreateWithoutAnnotatedCompletedItemInput, UserUncheckedCreateWithoutAnnotatedCompletedItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotatedCompletedItemInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAnnotationQueueItemInput = {
    create?: XOR<ProjectCreateWithoutAnnotationQueueItemInput, ProjectUncheckedCreateWithoutAnnotationQueueItemInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAnnotationQueueItemInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnnotationQueueObjectType
  }

  export type EnumAnnotationQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.AnnotationQueueStatus
  }

  export type AnnotationQueueUpdateOneRequiredWithoutAnnotationQueueItemNestedInput = {
    create?: XOR<AnnotationQueueCreateWithoutAnnotationQueueItemInput, AnnotationQueueUncheckedCreateWithoutAnnotationQueueItemInput>
    connectOrCreate?: AnnotationQueueCreateOrConnectWithoutAnnotationQueueItemInput
    upsert?: AnnotationQueueUpsertWithoutAnnotationQueueItemInput
    connect?: AnnotationQueueWhereUniqueInput
    update?: XOR<XOR<AnnotationQueueUpdateToOneWithWhereWithoutAnnotationQueueItemInput, AnnotationQueueUpdateWithoutAnnotationQueueItemInput>, AnnotationQueueUncheckedUpdateWithoutAnnotationQueueItemInput>
  }

  export type UserUpdateOneWithoutAnnotatedLockedItemNestedInput = {
    create?: XOR<UserCreateWithoutAnnotatedLockedItemInput, UserUncheckedCreateWithoutAnnotatedLockedItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotatedLockedItemInput
    upsert?: UserUpsertWithoutAnnotatedLockedItemInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnotatedLockedItemInput, UserUpdateWithoutAnnotatedLockedItemInput>, UserUncheckedUpdateWithoutAnnotatedLockedItemInput>
  }

  export type UserUpdateOneWithoutAnnotatedCompletedItemNestedInput = {
    create?: XOR<UserCreateWithoutAnnotatedCompletedItemInput, UserUncheckedCreateWithoutAnnotatedCompletedItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotatedCompletedItemInput
    upsert?: UserUpsertWithoutAnnotatedCompletedItemInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnotatedCompletedItemInput, UserUpdateWithoutAnnotatedCompletedItemInput>, UserUncheckedUpdateWithoutAnnotatedCompletedItemInput>
  }

  export type ProjectUpdateOneRequiredWithoutAnnotationQueueItemNestedInput = {
    create?: XOR<ProjectCreateWithoutAnnotationQueueItemInput, ProjectUncheckedCreateWithoutAnnotationQueueItemInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAnnotationQueueItemInput
    upsert?: ProjectUpsertWithoutAnnotationQueueItemInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAnnotationQueueItemInput, ProjectUpdateWithoutAnnotationQueueItemInput>, ProjectUncheckedUpdateWithoutAnnotationQueueItemInput>
  }

  export type ProjectCreateNestedOneWithoutDatasetInput = {
    create?: XOR<ProjectCreateWithoutDatasetInput, ProjectUncheckedCreateWithoutDatasetInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDatasetInput
    connect?: ProjectWhereUniqueInput
  }

  export type DatasetItemCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetItemCreateWithoutDatasetInput, DatasetItemUncheckedCreateWithoutDatasetInput> | DatasetItemCreateWithoutDatasetInput[] | DatasetItemUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetItemCreateOrConnectWithoutDatasetInput | DatasetItemCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetItemCreateManyDatasetInputEnvelope
    connect?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
  }

  export type DatasetRunsCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetRunsCreateWithoutDatasetInput, DatasetRunsUncheckedCreateWithoutDatasetInput> | DatasetRunsCreateWithoutDatasetInput[] | DatasetRunsUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetRunsCreateOrConnectWithoutDatasetInput | DatasetRunsCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetRunsCreateManyDatasetInputEnvelope
    connect?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
  }

  export type DatasetItemUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetItemCreateWithoutDatasetInput, DatasetItemUncheckedCreateWithoutDatasetInput> | DatasetItemCreateWithoutDatasetInput[] | DatasetItemUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetItemCreateOrConnectWithoutDatasetInput | DatasetItemCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetItemCreateManyDatasetInputEnvelope
    connect?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
  }

  export type DatasetRunsUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetRunsCreateWithoutDatasetInput, DatasetRunsUncheckedCreateWithoutDatasetInput> | DatasetRunsCreateWithoutDatasetInput[] | DatasetRunsUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetRunsCreateOrConnectWithoutDatasetInput | DatasetRunsCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetRunsCreateManyDatasetInputEnvelope
    connect?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutDatasetNestedInput = {
    create?: XOR<ProjectCreateWithoutDatasetInput, ProjectUncheckedCreateWithoutDatasetInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDatasetInput
    upsert?: ProjectUpsertWithoutDatasetInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDatasetInput, ProjectUpdateWithoutDatasetInput>, ProjectUncheckedUpdateWithoutDatasetInput>
  }

  export type DatasetItemUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetItemCreateWithoutDatasetInput, DatasetItemUncheckedCreateWithoutDatasetInput> | DatasetItemCreateWithoutDatasetInput[] | DatasetItemUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetItemCreateOrConnectWithoutDatasetInput | DatasetItemCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetItemUpsertWithWhereUniqueWithoutDatasetInput | DatasetItemUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetItemCreateManyDatasetInputEnvelope
    set?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    disconnect?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    delete?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    connect?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    update?: DatasetItemUpdateWithWhereUniqueWithoutDatasetInput | DatasetItemUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetItemUpdateManyWithWhereWithoutDatasetInput | DatasetItemUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetItemScalarWhereInput | DatasetItemScalarWhereInput[]
  }

  export type DatasetRunsUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetRunsCreateWithoutDatasetInput, DatasetRunsUncheckedCreateWithoutDatasetInput> | DatasetRunsCreateWithoutDatasetInput[] | DatasetRunsUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetRunsCreateOrConnectWithoutDatasetInput | DatasetRunsCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetRunsUpsertWithWhereUniqueWithoutDatasetInput | DatasetRunsUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetRunsCreateManyDatasetInputEnvelope
    set?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    disconnect?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    delete?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    connect?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    update?: DatasetRunsUpdateWithWhereUniqueWithoutDatasetInput | DatasetRunsUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetRunsUpdateManyWithWhereWithoutDatasetInput | DatasetRunsUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetRunsScalarWhereInput | DatasetRunsScalarWhereInput[]
  }

  export type DatasetItemUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetItemCreateWithoutDatasetInput, DatasetItemUncheckedCreateWithoutDatasetInput> | DatasetItemCreateWithoutDatasetInput[] | DatasetItemUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetItemCreateOrConnectWithoutDatasetInput | DatasetItemCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetItemUpsertWithWhereUniqueWithoutDatasetInput | DatasetItemUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetItemCreateManyDatasetInputEnvelope
    set?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    disconnect?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    delete?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    connect?: DatasetItemWhereUniqueInput | DatasetItemWhereUniqueInput[]
    update?: DatasetItemUpdateWithWhereUniqueWithoutDatasetInput | DatasetItemUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetItemUpdateManyWithWhereWithoutDatasetInput | DatasetItemUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetItemScalarWhereInput | DatasetItemScalarWhereInput[]
  }

  export type DatasetRunsUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetRunsCreateWithoutDatasetInput, DatasetRunsUncheckedCreateWithoutDatasetInput> | DatasetRunsCreateWithoutDatasetInput[] | DatasetRunsUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetRunsCreateOrConnectWithoutDatasetInput | DatasetRunsCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetRunsUpsertWithWhereUniqueWithoutDatasetInput | DatasetRunsUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetRunsCreateManyDatasetInputEnvelope
    set?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    disconnect?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    delete?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    connect?: DatasetRunsWhereUniqueInput | DatasetRunsWhereUniqueInput[]
    update?: DatasetRunsUpdateWithWhereUniqueWithoutDatasetInput | DatasetRunsUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetRunsUpdateManyWithWhereWithoutDatasetInput | DatasetRunsUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetRunsScalarWhereInput | DatasetRunsScalarWhereInput[]
  }

  export type DatasetCreateNestedOneWithoutDatasetItemsInput = {
    create?: XOR<DatasetCreateWithoutDatasetItemsInput, DatasetUncheckedCreateWithoutDatasetItemsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutDatasetItemsInput
    connect?: DatasetWhereUniqueInput
  }

  export type DatasetRunItemsCreateNestedManyWithoutDatasetItemInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetItemInput, DatasetRunItemsUncheckedCreateWithoutDatasetItemInput> | DatasetRunItemsCreateWithoutDatasetItemInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetItemInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetItemInput | DatasetRunItemsCreateOrConnectWithoutDatasetItemInput[]
    createMany?: DatasetRunItemsCreateManyDatasetItemInputEnvelope
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
  }

  export type DatasetRunItemsUncheckedCreateNestedManyWithoutDatasetItemInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetItemInput, DatasetRunItemsUncheckedCreateWithoutDatasetItemInput> | DatasetRunItemsCreateWithoutDatasetItemInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetItemInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetItemInput | DatasetRunItemsCreateOrConnectWithoutDatasetItemInput[]
    createMany?: DatasetRunItemsCreateManyDatasetItemInputEnvelope
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
  }

  export type EnumDatasetStatusFieldUpdateOperationsInput = {
    set?: $Enums.DatasetStatus
  }

  export type DatasetUpdateOneRequiredWithoutDatasetItemsNestedInput = {
    create?: XOR<DatasetCreateWithoutDatasetItemsInput, DatasetUncheckedCreateWithoutDatasetItemsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutDatasetItemsInput
    upsert?: DatasetUpsertWithoutDatasetItemsInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutDatasetItemsInput, DatasetUpdateWithoutDatasetItemsInput>, DatasetUncheckedUpdateWithoutDatasetItemsInput>
  }

  export type DatasetRunItemsUpdateManyWithoutDatasetItemNestedInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetItemInput, DatasetRunItemsUncheckedCreateWithoutDatasetItemInput> | DatasetRunItemsCreateWithoutDatasetItemInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetItemInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetItemInput | DatasetRunItemsCreateOrConnectWithoutDatasetItemInput[]
    upsert?: DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetItemInput | DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetItemInput[]
    createMany?: DatasetRunItemsCreateManyDatasetItemInputEnvelope
    set?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    disconnect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    delete?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    update?: DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetItemInput | DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetItemInput[]
    updateMany?: DatasetRunItemsUpdateManyWithWhereWithoutDatasetItemInput | DatasetRunItemsUpdateManyWithWhereWithoutDatasetItemInput[]
    deleteMany?: DatasetRunItemsScalarWhereInput | DatasetRunItemsScalarWhereInput[]
  }

  export type DatasetRunItemsUncheckedUpdateManyWithoutDatasetItemNestedInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetItemInput, DatasetRunItemsUncheckedCreateWithoutDatasetItemInput> | DatasetRunItemsCreateWithoutDatasetItemInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetItemInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetItemInput | DatasetRunItemsCreateOrConnectWithoutDatasetItemInput[]
    upsert?: DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetItemInput | DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetItemInput[]
    createMany?: DatasetRunItemsCreateManyDatasetItemInputEnvelope
    set?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    disconnect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    delete?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    update?: DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetItemInput | DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetItemInput[]
    updateMany?: DatasetRunItemsUpdateManyWithWhereWithoutDatasetItemInput | DatasetRunItemsUpdateManyWithWhereWithoutDatasetItemInput[]
    deleteMany?: DatasetRunItemsScalarWhereInput | DatasetRunItemsScalarWhereInput[]
  }

  export type DatasetCreateNestedOneWithoutDatasetRunsInput = {
    create?: XOR<DatasetCreateWithoutDatasetRunsInput, DatasetUncheckedCreateWithoutDatasetRunsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutDatasetRunsInput
    connect?: DatasetWhereUniqueInput
  }

  export type DatasetRunItemsCreateNestedManyWithoutDatasetRunInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetRunInput, DatasetRunItemsUncheckedCreateWithoutDatasetRunInput> | DatasetRunItemsCreateWithoutDatasetRunInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetRunInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetRunInput | DatasetRunItemsCreateOrConnectWithoutDatasetRunInput[]
    createMany?: DatasetRunItemsCreateManyDatasetRunInputEnvelope
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
  }

  export type DatasetRunItemsUncheckedCreateNestedManyWithoutDatasetRunInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetRunInput, DatasetRunItemsUncheckedCreateWithoutDatasetRunInput> | DatasetRunItemsCreateWithoutDatasetRunInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetRunInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetRunInput | DatasetRunItemsCreateOrConnectWithoutDatasetRunInput[]
    createMany?: DatasetRunItemsCreateManyDatasetRunInputEnvelope
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
  }

  export type DatasetUpdateOneRequiredWithoutDatasetRunsNestedInput = {
    create?: XOR<DatasetCreateWithoutDatasetRunsInput, DatasetUncheckedCreateWithoutDatasetRunsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutDatasetRunsInput
    upsert?: DatasetUpsertWithoutDatasetRunsInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutDatasetRunsInput, DatasetUpdateWithoutDatasetRunsInput>, DatasetUncheckedUpdateWithoutDatasetRunsInput>
  }

  export type DatasetRunItemsUpdateManyWithoutDatasetRunNestedInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetRunInput, DatasetRunItemsUncheckedCreateWithoutDatasetRunInput> | DatasetRunItemsCreateWithoutDatasetRunInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetRunInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetRunInput | DatasetRunItemsCreateOrConnectWithoutDatasetRunInput[]
    upsert?: DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetRunInput | DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetRunInput[]
    createMany?: DatasetRunItemsCreateManyDatasetRunInputEnvelope
    set?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    disconnect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    delete?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    update?: DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetRunInput | DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetRunInput[]
    updateMany?: DatasetRunItemsUpdateManyWithWhereWithoutDatasetRunInput | DatasetRunItemsUpdateManyWithWhereWithoutDatasetRunInput[]
    deleteMany?: DatasetRunItemsScalarWhereInput | DatasetRunItemsScalarWhereInput[]
  }

  export type DatasetRunItemsUncheckedUpdateManyWithoutDatasetRunNestedInput = {
    create?: XOR<DatasetRunItemsCreateWithoutDatasetRunInput, DatasetRunItemsUncheckedCreateWithoutDatasetRunInput> | DatasetRunItemsCreateWithoutDatasetRunInput[] | DatasetRunItemsUncheckedCreateWithoutDatasetRunInput[]
    connectOrCreate?: DatasetRunItemsCreateOrConnectWithoutDatasetRunInput | DatasetRunItemsCreateOrConnectWithoutDatasetRunInput[]
    upsert?: DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetRunInput | DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetRunInput[]
    createMany?: DatasetRunItemsCreateManyDatasetRunInputEnvelope
    set?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    disconnect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    delete?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    connect?: DatasetRunItemsWhereUniqueInput | DatasetRunItemsWhereUniqueInput[]
    update?: DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetRunInput | DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetRunInput[]
    updateMany?: DatasetRunItemsUpdateManyWithWhereWithoutDatasetRunInput | DatasetRunItemsUpdateManyWithWhereWithoutDatasetRunInput[]
    deleteMany?: DatasetRunItemsScalarWhereInput | DatasetRunItemsScalarWhereInput[]
  }

  export type DatasetRunsCreateNestedOneWithoutDatasetRunItemsInput = {
    create?: XOR<DatasetRunsCreateWithoutDatasetRunItemsInput, DatasetRunsUncheckedCreateWithoutDatasetRunItemsInput>
    connectOrCreate?: DatasetRunsCreateOrConnectWithoutDatasetRunItemsInput
    connect?: DatasetRunsWhereUniqueInput
  }

  export type DatasetItemCreateNestedOneWithoutDatasetRunItemsInput = {
    create?: XOR<DatasetItemCreateWithoutDatasetRunItemsInput, DatasetItemUncheckedCreateWithoutDatasetRunItemsInput>
    connectOrCreate?: DatasetItemCreateOrConnectWithoutDatasetRunItemsInput
    connect?: DatasetItemWhereUniqueInput
  }

  export type DatasetRunsUpdateOneRequiredWithoutDatasetRunItemsNestedInput = {
    create?: XOR<DatasetRunsCreateWithoutDatasetRunItemsInput, DatasetRunsUncheckedCreateWithoutDatasetRunItemsInput>
    connectOrCreate?: DatasetRunsCreateOrConnectWithoutDatasetRunItemsInput
    upsert?: DatasetRunsUpsertWithoutDatasetRunItemsInput
    connect?: DatasetRunsWhereUniqueInput
    update?: XOR<XOR<DatasetRunsUpdateToOneWithWhereWithoutDatasetRunItemsInput, DatasetRunsUpdateWithoutDatasetRunItemsInput>, DatasetRunsUncheckedUpdateWithoutDatasetRunItemsInput>
  }

  export type DatasetItemUpdateOneRequiredWithoutDatasetRunItemsNestedInput = {
    create?: XOR<DatasetItemCreateWithoutDatasetRunItemsInput, DatasetItemUncheckedCreateWithoutDatasetRunItemsInput>
    connectOrCreate?: DatasetItemCreateOrConnectWithoutDatasetRunItemsInput
    upsert?: DatasetItemUpsertWithoutDatasetRunItemsInput
    connect?: DatasetItemWhereUniqueInput
    update?: XOR<XOR<DatasetItemUpdateToOneWithWhereWithoutDatasetRunItemsInput, DatasetItemUpdateWithoutDatasetRunItemsInput>, DatasetItemUncheckedUpdateWithoutDatasetRunItemsInput>
  }

  export type ProjectCreateNestedOneWithoutRawEventsInput = {
    create?: XOR<ProjectCreateWithoutRawEventsInput, ProjectUncheckedCreateWithoutRawEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRawEventsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutRawEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutRawEventsInput, ProjectUncheckedCreateWithoutRawEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRawEventsInput
    upsert?: ProjectUpsertWithoutRawEventsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRawEventsInput, ProjectUpdateWithoutRawEventsInput>, ProjectUncheckedUpdateWithoutRawEventsInput>
  }

  export type ProjectCreateNestedOneWithoutCommentInput = {
    create?: XOR<ProjectCreateWithoutCommentInput, ProjectUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumCommentObjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommentObjectType
  }

  export type ProjectUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<ProjectCreateWithoutCommentInput, ProjectUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentInput
    upsert?: ProjectUpsertWithoutCommentInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCommentInput, ProjectUpdateWithoutCommentInput>, ProjectUncheckedUpdateWithoutCommentInput>
  }

  export type PromptCreatetagsInput = {
    set: string[]
  }

  export type PromptCreatelabelsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutPromptInput = {
    create?: XOR<ProjectCreateWithoutPromptInput, ProjectUncheckedCreateWithoutPromptInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPromptInput
    connect?: ProjectWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PromptUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PromptUpdatelabelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutPromptNestedInput = {
    create?: XOR<ProjectCreateWithoutPromptInput, ProjectUncheckedCreateWithoutPromptInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPromptInput
    upsert?: ProjectUpsertWithoutPromptInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPromptInput, ProjectUpdateWithoutPromptInput>, ProjectUncheckedUpdateWithoutPromptInput>
  }

  export type ProjectCreateNestedOneWithoutModelInput = {
    create?: XOR<ProjectCreateWithoutModelInput, ProjectUncheckedCreateWithoutModelInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModelInput
    connect?: ProjectWhereUniqueInput
  }

  export type PriceCreateNestedManyWithoutModelInput = {
    create?: XOR<PriceCreateWithoutModelInput, PriceUncheckedCreateWithoutModelInput> | PriceCreateWithoutModelInput[] | PriceUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutModelInput | PriceCreateOrConnectWithoutModelInput[]
    createMany?: PriceCreateManyModelInputEnvelope
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
  }

  export type PriceUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<PriceCreateWithoutModelInput, PriceUncheckedCreateWithoutModelInput> | PriceCreateWithoutModelInput[] | PriceUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutModelInput | PriceCreateOrConnectWithoutModelInput[]
    createMany?: PriceCreateManyModelInputEnvelope
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutModelNestedInput = {
    create?: XOR<ProjectCreateWithoutModelInput, ProjectUncheckedCreateWithoutModelInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModelInput
    upsert?: ProjectUpsertWithoutModelInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutModelInput, ProjectUpdateWithoutModelInput>, ProjectUncheckedUpdateWithoutModelInput>
  }

  export type PriceUpdateManyWithoutModelNestedInput = {
    create?: XOR<PriceCreateWithoutModelInput, PriceUncheckedCreateWithoutModelInput> | PriceCreateWithoutModelInput[] | PriceUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutModelInput | PriceCreateOrConnectWithoutModelInput[]
    upsert?: PriceUpsertWithWhereUniqueWithoutModelInput | PriceUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: PriceCreateManyModelInputEnvelope
    set?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    disconnect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    delete?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    update?: PriceUpdateWithWhereUniqueWithoutModelInput | PriceUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: PriceUpdateManyWithWhereWithoutModelInput | PriceUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: PriceScalarWhereInput | PriceScalarWhereInput[]
  }

  export type PriceUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<PriceCreateWithoutModelInput, PriceUncheckedCreateWithoutModelInput> | PriceCreateWithoutModelInput[] | PriceUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutModelInput | PriceCreateOrConnectWithoutModelInput[]
    upsert?: PriceUpsertWithWhereUniqueWithoutModelInput | PriceUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: PriceCreateManyModelInputEnvelope
    set?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    disconnect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    delete?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    update?: PriceUpdateWithWhereUniqueWithoutModelInput | PriceUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: PriceUpdateManyWithWhereWithoutModelInput | PriceUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: PriceScalarWhereInput | PriceScalarWhereInput[]
  }

  export type ModelCreateNestedOneWithoutPriceInput = {
    create?: XOR<ModelCreateWithoutPriceInput, ModelUncheckedCreateWithoutPriceInput>
    connectOrCreate?: ModelCreateOrConnectWithoutPriceInput
    connect?: ModelWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ModelUpdateOneRequiredWithoutPriceNestedInput = {
    create?: XOR<ModelCreateWithoutPriceInput, ModelUncheckedCreateWithoutPriceInput>
    connectOrCreate?: ModelCreateOrConnectWithoutPriceInput
    upsert?: ModelUpsertWithoutPriceInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutPriceInput, ModelUpdateWithoutPriceInput>, ModelUncheckedUpdateWithoutPriceInput>
  }

  export type EvalTemplateCreatevarsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutEvalTemplateInput = {
    create?: XOR<ProjectCreateWithoutEvalTemplateInput, ProjectUncheckedCreateWithoutEvalTemplateInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEvalTemplateInput
    connect?: ProjectWhereUniqueInput
  }

  export type JobConfigurationCreateNestedManyWithoutEvalTemplateInput = {
    create?: XOR<JobConfigurationCreateWithoutEvalTemplateInput, JobConfigurationUncheckedCreateWithoutEvalTemplateInput> | JobConfigurationCreateWithoutEvalTemplateInput[] | JobConfigurationUncheckedCreateWithoutEvalTemplateInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutEvalTemplateInput | JobConfigurationCreateOrConnectWithoutEvalTemplateInput[]
    createMany?: JobConfigurationCreateManyEvalTemplateInputEnvelope
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
  }

  export type JobConfigurationUncheckedCreateNestedManyWithoutEvalTemplateInput = {
    create?: XOR<JobConfigurationCreateWithoutEvalTemplateInput, JobConfigurationUncheckedCreateWithoutEvalTemplateInput> | JobConfigurationCreateWithoutEvalTemplateInput[] | JobConfigurationUncheckedCreateWithoutEvalTemplateInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutEvalTemplateInput | JobConfigurationCreateOrConnectWithoutEvalTemplateInput[]
    createMany?: JobConfigurationCreateManyEvalTemplateInputEnvelope
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
  }

  export type EvalTemplateUpdatevarsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutEvalTemplateNestedInput = {
    create?: XOR<ProjectCreateWithoutEvalTemplateInput, ProjectUncheckedCreateWithoutEvalTemplateInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEvalTemplateInput
    upsert?: ProjectUpsertWithoutEvalTemplateInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEvalTemplateInput, ProjectUpdateWithoutEvalTemplateInput>, ProjectUncheckedUpdateWithoutEvalTemplateInput>
  }

  export type JobConfigurationUpdateManyWithoutEvalTemplateNestedInput = {
    create?: XOR<JobConfigurationCreateWithoutEvalTemplateInput, JobConfigurationUncheckedCreateWithoutEvalTemplateInput> | JobConfigurationCreateWithoutEvalTemplateInput[] | JobConfigurationUncheckedCreateWithoutEvalTemplateInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutEvalTemplateInput | JobConfigurationCreateOrConnectWithoutEvalTemplateInput[]
    upsert?: JobConfigurationUpsertWithWhereUniqueWithoutEvalTemplateInput | JobConfigurationUpsertWithWhereUniqueWithoutEvalTemplateInput[]
    createMany?: JobConfigurationCreateManyEvalTemplateInputEnvelope
    set?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    disconnect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    delete?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    update?: JobConfigurationUpdateWithWhereUniqueWithoutEvalTemplateInput | JobConfigurationUpdateWithWhereUniqueWithoutEvalTemplateInput[]
    updateMany?: JobConfigurationUpdateManyWithWhereWithoutEvalTemplateInput | JobConfigurationUpdateManyWithWhereWithoutEvalTemplateInput[]
    deleteMany?: JobConfigurationScalarWhereInput | JobConfigurationScalarWhereInput[]
  }

  export type JobConfigurationUncheckedUpdateManyWithoutEvalTemplateNestedInput = {
    create?: XOR<JobConfigurationCreateWithoutEvalTemplateInput, JobConfigurationUncheckedCreateWithoutEvalTemplateInput> | JobConfigurationCreateWithoutEvalTemplateInput[] | JobConfigurationUncheckedCreateWithoutEvalTemplateInput[]
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutEvalTemplateInput | JobConfigurationCreateOrConnectWithoutEvalTemplateInput[]
    upsert?: JobConfigurationUpsertWithWhereUniqueWithoutEvalTemplateInput | JobConfigurationUpsertWithWhereUniqueWithoutEvalTemplateInput[]
    createMany?: JobConfigurationCreateManyEvalTemplateInputEnvelope
    set?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    disconnect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    delete?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    connect?: JobConfigurationWhereUniqueInput | JobConfigurationWhereUniqueInput[]
    update?: JobConfigurationUpdateWithWhereUniqueWithoutEvalTemplateInput | JobConfigurationUpdateWithWhereUniqueWithoutEvalTemplateInput[]
    updateMany?: JobConfigurationUpdateManyWithWhereWithoutEvalTemplateInput | JobConfigurationUpdateManyWithWhereWithoutEvalTemplateInput[]
    deleteMany?: JobConfigurationScalarWhereInput | JobConfigurationScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutJobConfigurationInput = {
    create?: XOR<ProjectCreateWithoutJobConfigurationInput, ProjectUncheckedCreateWithoutJobConfigurationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutJobConfigurationInput
    connect?: ProjectWhereUniqueInput
  }

  export type EvalTemplateCreateNestedOneWithoutJobConfigurationInput = {
    create?: XOR<EvalTemplateCreateWithoutJobConfigurationInput, EvalTemplateUncheckedCreateWithoutJobConfigurationInput>
    connectOrCreate?: EvalTemplateCreateOrConnectWithoutJobConfigurationInput
    connect?: EvalTemplateWhereUniqueInput
  }

  export type JobExecutionCreateNestedManyWithoutJobConfigurationInput = {
    create?: XOR<JobExecutionCreateWithoutJobConfigurationInput, JobExecutionUncheckedCreateWithoutJobConfigurationInput> | JobExecutionCreateWithoutJobConfigurationInput[] | JobExecutionUncheckedCreateWithoutJobConfigurationInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutJobConfigurationInput | JobExecutionCreateOrConnectWithoutJobConfigurationInput[]
    createMany?: JobExecutionCreateManyJobConfigurationInputEnvelope
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
  }

  export type JobExecutionUncheckedCreateNestedManyWithoutJobConfigurationInput = {
    create?: XOR<JobExecutionCreateWithoutJobConfigurationInput, JobExecutionUncheckedCreateWithoutJobConfigurationInput> | JobExecutionCreateWithoutJobConfigurationInput[] | JobExecutionUncheckedCreateWithoutJobConfigurationInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutJobConfigurationInput | JobExecutionCreateOrConnectWithoutJobConfigurationInput[]
    createMany?: JobExecutionCreateManyJobConfigurationInputEnvelope
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type EnumJobConfigStateFieldUpdateOperationsInput = {
    set?: $Enums.JobConfigState
  }

  export type ProjectUpdateOneRequiredWithoutJobConfigurationNestedInput = {
    create?: XOR<ProjectCreateWithoutJobConfigurationInput, ProjectUncheckedCreateWithoutJobConfigurationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutJobConfigurationInput
    upsert?: ProjectUpsertWithoutJobConfigurationInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutJobConfigurationInput, ProjectUpdateWithoutJobConfigurationInput>, ProjectUncheckedUpdateWithoutJobConfigurationInput>
  }

  export type EvalTemplateUpdateOneWithoutJobConfigurationNestedInput = {
    create?: XOR<EvalTemplateCreateWithoutJobConfigurationInput, EvalTemplateUncheckedCreateWithoutJobConfigurationInput>
    connectOrCreate?: EvalTemplateCreateOrConnectWithoutJobConfigurationInput
    upsert?: EvalTemplateUpsertWithoutJobConfigurationInput
    disconnect?: EvalTemplateWhereInput | boolean
    delete?: EvalTemplateWhereInput | boolean
    connect?: EvalTemplateWhereUniqueInput
    update?: XOR<XOR<EvalTemplateUpdateToOneWithWhereWithoutJobConfigurationInput, EvalTemplateUpdateWithoutJobConfigurationInput>, EvalTemplateUncheckedUpdateWithoutJobConfigurationInput>
  }

  export type JobExecutionUpdateManyWithoutJobConfigurationNestedInput = {
    create?: XOR<JobExecutionCreateWithoutJobConfigurationInput, JobExecutionUncheckedCreateWithoutJobConfigurationInput> | JobExecutionCreateWithoutJobConfigurationInput[] | JobExecutionUncheckedCreateWithoutJobConfigurationInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutJobConfigurationInput | JobExecutionCreateOrConnectWithoutJobConfigurationInput[]
    upsert?: JobExecutionUpsertWithWhereUniqueWithoutJobConfigurationInput | JobExecutionUpsertWithWhereUniqueWithoutJobConfigurationInput[]
    createMany?: JobExecutionCreateManyJobConfigurationInputEnvelope
    set?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    disconnect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    delete?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    update?: JobExecutionUpdateWithWhereUniqueWithoutJobConfigurationInput | JobExecutionUpdateWithWhereUniqueWithoutJobConfigurationInput[]
    updateMany?: JobExecutionUpdateManyWithWhereWithoutJobConfigurationInput | JobExecutionUpdateManyWithWhereWithoutJobConfigurationInput[]
    deleteMany?: JobExecutionScalarWhereInput | JobExecutionScalarWhereInput[]
  }

  export type JobExecutionUncheckedUpdateManyWithoutJobConfigurationNestedInput = {
    create?: XOR<JobExecutionCreateWithoutJobConfigurationInput, JobExecutionUncheckedCreateWithoutJobConfigurationInput> | JobExecutionCreateWithoutJobConfigurationInput[] | JobExecutionUncheckedCreateWithoutJobConfigurationInput[]
    connectOrCreate?: JobExecutionCreateOrConnectWithoutJobConfigurationInput | JobExecutionCreateOrConnectWithoutJobConfigurationInput[]
    upsert?: JobExecutionUpsertWithWhereUniqueWithoutJobConfigurationInput | JobExecutionUpsertWithWhereUniqueWithoutJobConfigurationInput[]
    createMany?: JobExecutionCreateManyJobConfigurationInputEnvelope
    set?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    disconnect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    delete?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    connect?: JobExecutionWhereUniqueInput | JobExecutionWhereUniqueInput[]
    update?: JobExecutionUpdateWithWhereUniqueWithoutJobConfigurationInput | JobExecutionUpdateWithWhereUniqueWithoutJobConfigurationInput[]
    updateMany?: JobExecutionUpdateManyWithWhereWithoutJobConfigurationInput | JobExecutionUpdateManyWithWhereWithoutJobConfigurationInput[]
    deleteMany?: JobExecutionScalarWhereInput | JobExecutionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutJobExecutionInput = {
    create?: XOR<ProjectCreateWithoutJobExecutionInput, ProjectUncheckedCreateWithoutJobExecutionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutJobExecutionInput
    connect?: ProjectWhereUniqueInput
  }

  export type JobConfigurationCreateNestedOneWithoutJobExecutionInput = {
    create?: XOR<JobConfigurationCreateWithoutJobExecutionInput, JobConfigurationUncheckedCreateWithoutJobExecutionInput>
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutJobExecutionInput
    connect?: JobConfigurationWhereUniqueInput
  }

  export type EnumJobExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobExecutionStatus
  }

  export type ProjectUpdateOneRequiredWithoutJobExecutionNestedInput = {
    create?: XOR<ProjectCreateWithoutJobExecutionInput, ProjectUncheckedCreateWithoutJobExecutionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutJobExecutionInput
    upsert?: ProjectUpsertWithoutJobExecutionInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutJobExecutionInput, ProjectUpdateWithoutJobExecutionInput>, ProjectUncheckedUpdateWithoutJobExecutionInput>
  }

  export type JobConfigurationUpdateOneRequiredWithoutJobExecutionNestedInput = {
    create?: XOR<JobConfigurationCreateWithoutJobExecutionInput, JobConfigurationUncheckedCreateWithoutJobExecutionInput>
    connectOrCreate?: JobConfigurationCreateOrConnectWithoutJobExecutionInput
    upsert?: JobConfigurationUpsertWithoutJobExecutionInput
    connect?: JobConfigurationWhereUniqueInput
    update?: XOR<XOR<JobConfigurationUpdateToOneWithWhereWithoutJobExecutionInput, JobConfigurationUpdateWithoutJobExecutionInput>, JobConfigurationUncheckedUpdateWithoutJobExecutionInput>
  }

  export type ProjectCreateNestedOneWithoutPosthogIntegrationInput = {
    create?: XOR<ProjectCreateWithoutPosthogIntegrationInput, ProjectUncheckedCreateWithoutPosthogIntegrationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPosthogIntegrationInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPosthogIntegrationNestedInput = {
    create?: XOR<ProjectCreateWithoutPosthogIntegrationInput, ProjectUncheckedCreateWithoutPosthogIntegrationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPosthogIntegrationInput
    upsert?: ProjectUpsertWithoutPosthogIntegrationInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPosthogIntegrationInput, ProjectUpdateWithoutPosthogIntegrationInput>, ProjectUncheckedUpdateWithoutPosthogIntegrationInput>
  }

  export type ProjectCreateNestedOneWithoutBatchExportInput = {
    create?: XOR<ProjectCreateWithoutBatchExportInput, ProjectUncheckedCreateWithoutBatchExportInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBatchExportInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutBatchExportNestedInput = {
    create?: XOR<ProjectCreateWithoutBatchExportInput, ProjectUncheckedCreateWithoutBatchExportInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBatchExportInput
    upsert?: ProjectUpsertWithoutBatchExportInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBatchExportInput, ProjectUpdateWithoutBatchExportInput>, ProjectUncheckedUpdateWithoutBatchExportInput>
  }

  export type ProjectCreateNestedOneWithoutMediaInput = {
    create?: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaInput
    connect?: ProjectWhereUniqueInput
  }

  export type TraceMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<TraceMediaCreateWithoutMediaInput, TraceMediaUncheckedCreateWithoutMediaInput> | TraceMediaCreateWithoutMediaInput[] | TraceMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutMediaInput | TraceMediaCreateOrConnectWithoutMediaInput[]
    createMany?: TraceMediaCreateManyMediaInputEnvelope
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
  }

  export type ObservationMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<ObservationMediaCreateWithoutMediaInput, ObservationMediaUncheckedCreateWithoutMediaInput> | ObservationMediaCreateWithoutMediaInput[] | ObservationMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutMediaInput | ObservationMediaCreateOrConnectWithoutMediaInput[]
    createMany?: ObservationMediaCreateManyMediaInputEnvelope
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
  }

  export type TraceMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<TraceMediaCreateWithoutMediaInput, TraceMediaUncheckedCreateWithoutMediaInput> | TraceMediaCreateWithoutMediaInput[] | TraceMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutMediaInput | TraceMediaCreateOrConnectWithoutMediaInput[]
    createMany?: TraceMediaCreateManyMediaInputEnvelope
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
  }

  export type ObservationMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<ObservationMediaCreateWithoutMediaInput, ObservationMediaUncheckedCreateWithoutMediaInput> | ObservationMediaCreateWithoutMediaInput[] | ObservationMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutMediaInput | ObservationMediaCreateOrConnectWithoutMediaInput[]
    createMany?: ObservationMediaCreateManyMediaInputEnvelope
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ProjectUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaInput
    upsert?: ProjectUpsertWithoutMediaInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMediaInput, ProjectUpdateWithoutMediaInput>, ProjectUncheckedUpdateWithoutMediaInput>
  }

  export type TraceMediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<TraceMediaCreateWithoutMediaInput, TraceMediaUncheckedCreateWithoutMediaInput> | TraceMediaCreateWithoutMediaInput[] | TraceMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutMediaInput | TraceMediaCreateOrConnectWithoutMediaInput[]
    upsert?: TraceMediaUpsertWithWhereUniqueWithoutMediaInput | TraceMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: TraceMediaCreateManyMediaInputEnvelope
    set?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    disconnect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    delete?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    update?: TraceMediaUpdateWithWhereUniqueWithoutMediaInput | TraceMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: TraceMediaUpdateManyWithWhereWithoutMediaInput | TraceMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: TraceMediaScalarWhereInput | TraceMediaScalarWhereInput[]
  }

  export type ObservationMediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ObservationMediaCreateWithoutMediaInput, ObservationMediaUncheckedCreateWithoutMediaInput> | ObservationMediaCreateWithoutMediaInput[] | ObservationMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutMediaInput | ObservationMediaCreateOrConnectWithoutMediaInput[]
    upsert?: ObservationMediaUpsertWithWhereUniqueWithoutMediaInput | ObservationMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ObservationMediaCreateManyMediaInputEnvelope
    set?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    disconnect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    delete?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    update?: ObservationMediaUpdateWithWhereUniqueWithoutMediaInput | ObservationMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ObservationMediaUpdateManyWithWhereWithoutMediaInput | ObservationMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ObservationMediaScalarWhereInput | ObservationMediaScalarWhereInput[]
  }

  export type TraceMediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<TraceMediaCreateWithoutMediaInput, TraceMediaUncheckedCreateWithoutMediaInput> | TraceMediaCreateWithoutMediaInput[] | TraceMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: TraceMediaCreateOrConnectWithoutMediaInput | TraceMediaCreateOrConnectWithoutMediaInput[]
    upsert?: TraceMediaUpsertWithWhereUniqueWithoutMediaInput | TraceMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: TraceMediaCreateManyMediaInputEnvelope
    set?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    disconnect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    delete?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    connect?: TraceMediaWhereUniqueInput | TraceMediaWhereUniqueInput[]
    update?: TraceMediaUpdateWithWhereUniqueWithoutMediaInput | TraceMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: TraceMediaUpdateManyWithWhereWithoutMediaInput | TraceMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: TraceMediaScalarWhereInput | TraceMediaScalarWhereInput[]
  }

  export type ObservationMediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ObservationMediaCreateWithoutMediaInput, ObservationMediaUncheckedCreateWithoutMediaInput> | ObservationMediaCreateWithoutMediaInput[] | ObservationMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ObservationMediaCreateOrConnectWithoutMediaInput | ObservationMediaCreateOrConnectWithoutMediaInput[]
    upsert?: ObservationMediaUpsertWithWhereUniqueWithoutMediaInput | ObservationMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ObservationMediaCreateManyMediaInputEnvelope
    set?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    disconnect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    delete?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    connect?: ObservationMediaWhereUniqueInput | ObservationMediaWhereUniqueInput[]
    update?: ObservationMediaUpdateWithWhereUniqueWithoutMediaInput | ObservationMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ObservationMediaUpdateManyWithWhereWithoutMediaInput | ObservationMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ObservationMediaScalarWhereInput | ObservationMediaScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTraceMediaInput = {
    create?: XOR<ProjectCreateWithoutTraceMediaInput, ProjectUncheckedCreateWithoutTraceMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTraceMediaInput
    connect?: ProjectWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutTraceMediaInput = {
    create?: XOR<MediaCreateWithoutTraceMediaInput, MediaUncheckedCreateWithoutTraceMediaInput>
    connectOrCreate?: MediaCreateOrConnectWithoutTraceMediaInput
    connect?: MediaWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTraceMediaNestedInput = {
    create?: XOR<ProjectCreateWithoutTraceMediaInput, ProjectUncheckedCreateWithoutTraceMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTraceMediaInput
    upsert?: ProjectUpsertWithoutTraceMediaInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTraceMediaInput, ProjectUpdateWithoutTraceMediaInput>, ProjectUncheckedUpdateWithoutTraceMediaInput>
  }

  export type MediaUpdateOneRequiredWithoutTraceMediaNestedInput = {
    create?: XOR<MediaCreateWithoutTraceMediaInput, MediaUncheckedCreateWithoutTraceMediaInput>
    connectOrCreate?: MediaCreateOrConnectWithoutTraceMediaInput
    upsert?: MediaUpsertWithoutTraceMediaInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutTraceMediaInput, MediaUpdateWithoutTraceMediaInput>, MediaUncheckedUpdateWithoutTraceMediaInput>
  }

  export type ProjectCreateNestedOneWithoutObservationMediaInput = {
    create?: XOR<ProjectCreateWithoutObservationMediaInput, ProjectUncheckedCreateWithoutObservationMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutObservationMediaInput
    connect?: ProjectWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutObservationMediaInput = {
    create?: XOR<MediaCreateWithoutObservationMediaInput, MediaUncheckedCreateWithoutObservationMediaInput>
    connectOrCreate?: MediaCreateOrConnectWithoutObservationMediaInput
    connect?: MediaWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutObservationMediaNestedInput = {
    create?: XOR<ProjectCreateWithoutObservationMediaInput, ProjectUncheckedCreateWithoutObservationMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutObservationMediaInput
    upsert?: ProjectUpsertWithoutObservationMediaInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutObservationMediaInput, ProjectUpdateWithoutObservationMediaInput>, ProjectUncheckedUpdateWithoutObservationMediaInput>
  }

  export type MediaUpdateOneRequiredWithoutObservationMediaNestedInput = {
    create?: XOR<MediaCreateWithoutObservationMediaInput, MediaUncheckedCreateWithoutObservationMediaInput>
    connectOrCreate?: MediaCreateOrConnectWithoutObservationMediaInput
    upsert?: MediaUpsertWithoutObservationMediaInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutObservationMediaInput, MediaUpdateWithoutObservationMediaInput>, MediaUncheckedUpdateWithoutObservationMediaInput>
  }

  export type TraceViewCreatetagsInput = {
    set: string[]
  }

  export type TraceViewUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumObservationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationType | EnumObservationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationTypeFilter<$PrismaModel> | $Enums.ObservationType
  }

  export type NestedEnumObservationLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationLevel | EnumObservationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationLevelFilter<$PrismaModel> | $Enums.ObservationLevel
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumObservationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationType | EnumObservationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationType[] | ListEnumObservationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObservationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObservationTypeFilter<$PrismaModel>
    _max?: NestedEnumObservationTypeFilter<$PrismaModel>
  }

  export type NestedEnumObservationLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObservationLevel | EnumObservationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObservationLevel[] | ListEnumObservationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumObservationLevelWithAggregatesFilter<$PrismaModel> | $Enums.ObservationLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObservationLevelFilter<$PrismaModel>
    _max?: NestedEnumObservationLevelFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumScoreSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreSource | EnumScoreSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreSourceFilter<$PrismaModel> | $Enums.ScoreSource
  }

  export type NestedEnumScoreDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreDataType | EnumScoreDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreDataTypeFilter<$PrismaModel> | $Enums.ScoreDataType
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumScoreSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreSource | EnumScoreSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreSource[] | ListEnumScoreSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreSourceWithAggregatesFilter<$PrismaModel> | $Enums.ScoreSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreSourceFilter<$PrismaModel>
    _max?: NestedEnumScoreSourceFilter<$PrismaModel>
  }

  export type NestedEnumScoreDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreDataType | EnumScoreDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreDataType[] | ListEnumScoreDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoreDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreDataTypeFilter<$PrismaModel>
    _max?: NestedEnumScoreDataTypeFilter<$PrismaModel>
  }

  export type NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueObjectType | EnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel> | $Enums.AnnotationQueueObjectType
  }

  export type NestedEnumAnnotationQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueStatus | EnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueStatusFilter<$PrismaModel> | $Enums.AnnotationQueueStatus
  }

  export type NestedEnumAnnotationQueueObjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueObjectType | EnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueObjectType[] | ListEnumAnnotationQueueObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueObjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnnotationQueueObjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel>
    _max?: NestedEnumAnnotationQueueObjectTypeFilter<$PrismaModel>
  }

  export type NestedEnumAnnotationQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnotationQueueStatus | EnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnotationQueueStatus[] | ListEnumAnnotationQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnotationQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.AnnotationQueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnotationQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumAnnotationQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumDatasetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusFilter<$PrismaModel> | $Enums.DatasetStatus
  }

  export type NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel> | $Enums.DatasetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetStatusFilter<$PrismaModel>
    _max?: NestedEnumDatasetStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommentObjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentObjectType | EnumCommentObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentObjectTypeFilter<$PrismaModel> | $Enums.CommentObjectType
  }

  export type NestedEnumCommentObjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentObjectType | EnumCommentObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentObjectType[] | ListEnumCommentObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentObjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommentObjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentObjectTypeFilter<$PrismaModel>
    _max?: NestedEnumCommentObjectTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobConfigStateFilter<$PrismaModel = never> = {
    equals?: $Enums.JobConfigState | EnumJobConfigStateFieldRefInput<$PrismaModel>
    in?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    not?: NestedEnumJobConfigStateFilter<$PrismaModel> | $Enums.JobConfigState
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobConfigStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobConfigState | EnumJobConfigStateFieldRefInput<$PrismaModel>
    in?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobConfigState[] | ListEnumJobConfigStateFieldRefInput<$PrismaModel>
    not?: NestedEnumJobConfigStateWithAggregatesFilter<$PrismaModel> | $Enums.JobConfigState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobConfigStateFilter<$PrismaModel>
    _max?: NestedEnumJobConfigStateFilter<$PrismaModel>
  }

  export type NestedEnumJobExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobExecutionStatus | EnumJobExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobExecutionStatusFilter<$PrismaModel> | $Enums.JobExecutionStatus
  }

  export type NestedEnumJobExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobExecutionStatus | EnumJobExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobExecutionStatus[] | ListEnumJobExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumJobExecutionStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    expires_in?: number | null
    ext_expires_in?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    created_at?: number | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    expires_in?: number | null
    ext_expires_in?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    created_at?: number | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMembershipCreateWithoutUserInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutOrganizationMembershipsInput
    ProjectMemberships?: ProjectMembershipCreateNestedManyWithoutOrganizationMembershipInput
  }

  export type OrganizationMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    orgId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    ProjectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutOrganizationMembershipInput
  }

  export type OrganizationMembershipCreateOrConnectWithoutUserInput = {
    where: OrganizationMembershipWhereUniqueInput
    create: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMembershipCreateManyUserInputEnvelope = {
    data: OrganizationMembershipCreateManyUserInput | OrganizationMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMembershipCreateWithoutUserInput = {
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationMembership: OrganizationMembershipCreateNestedOneWithoutProjectMembershipsInput
    project: ProjectCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMembershipUncheckedCreateWithoutUserInput = {
    orgMembershipId: string
    projectId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipCreateOrConnectWithoutUserInput = {
    where: ProjectMembershipWhereUniqueInput
    create: XOR<ProjectMembershipCreateWithoutUserInput, ProjectMembershipUncheckedCreateWithoutUserInput>
  }

  export type ProjectMembershipCreateManyUserInputEnvelope = {
    data: ProjectMembershipCreateManyUserInput | ProjectMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipInvitationCreateWithoutInvitedByUserInput = {
    id?: string
    email: string
    orgRole: $Enums.Role
    projectRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembershipInvitationInput
    project?: ProjectCreateNestedOneWithoutInvitationsInput
  }

  export type MembershipInvitationUncheckedCreateWithoutInvitedByUserInput = {
    id?: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectId?: string | null
    projectRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipInvitationCreateOrConnectWithoutInvitedByUserInput = {
    where: MembershipInvitationWhereUniqueInput
    create: XOR<MembershipInvitationCreateWithoutInvitedByUserInput, MembershipInvitationUncheckedCreateWithoutInvitedByUserInput>
  }

  export type MembershipInvitationCreateManyInvitedByUserInputEnvelope = {
    data: MembershipInvitationCreateManyInvitedByUserInput | MembershipInvitationCreateManyInvitedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationQueueItemCreateWithoutLockedByUserInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: AnnotationQueueCreateNestedOneWithoutAnnotationQueueItemInput
    annotatorUser?: UserCreateNestedOneWithoutAnnotatedCompletedItemInput
    project: ProjectCreateNestedOneWithoutAnnotationQueueItemInput
  }

  export type AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateOrConnectWithoutLockedByUserInput = {
    where: AnnotationQueueItemWhereUniqueInput
    create: XOR<AnnotationQueueItemCreateWithoutLockedByUserInput, AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput>
  }

  export type AnnotationQueueItemCreateManyLockedByUserInputEnvelope = {
    data: AnnotationQueueItemCreateManyLockedByUserInput | AnnotationQueueItemCreateManyLockedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationQueueItemCreateWithoutAnnotatorUserInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: AnnotationQueueCreateNestedOneWithoutAnnotationQueueItemInput
    lockedByUser?: UserCreateNestedOneWithoutAnnotatedLockedItemInput
    project: ProjectCreateNestedOneWithoutAnnotationQueueItemInput
  }

  export type AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateOrConnectWithoutAnnotatorUserInput = {
    where: AnnotationQueueItemWhereUniqueInput
    create: XOR<AnnotationQueueItemCreateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput>
  }

  export type AnnotationQueueItemCreateManyAnnotatorUserInputEnvelope = {
    data: AnnotationQueueItemCreateManyAnnotatorUserInput | AnnotationQueueItemCreateManyAnnotatorUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    expires_in?: IntNullableFilter<"Account"> | number | null
    ext_expires_in?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    created_at?: IntNullableFilter<"Account"> | number | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMembershipWhereUniqueInput
    update: XOR<OrganizationMembershipUpdateWithoutUserInput, OrganizationMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMembershipWhereUniqueInput
    data: XOR<OrganizationMembershipUpdateWithoutUserInput, OrganizationMembershipUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMembershipUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMembershipScalarWhereInput
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMembershipScalarWhereInput = {
    AND?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
    OR?: OrganizationMembershipScalarWhereInput[]
    NOT?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
    id?: StringFilter<"OrganizationMembership"> | string
    orgId?: StringFilter<"OrganizationMembership"> | string
    userId?: StringFilter<"OrganizationMembership"> | string
    role?: EnumRoleFilter<"OrganizationMembership"> | $Enums.Role
    createdAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
  }

  export type ProjectMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMembershipWhereUniqueInput
    update: XOR<ProjectMembershipUpdateWithoutUserInput, ProjectMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMembershipCreateWithoutUserInput, ProjectMembershipUncheckedCreateWithoutUserInput>
  }

  export type ProjectMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMembershipWhereUniqueInput
    data: XOR<ProjectMembershipUpdateWithoutUserInput, ProjectMembershipUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMembershipUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMembershipScalarWhereInput
    data: XOR<ProjectMembershipUpdateManyMutationInput, ProjectMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMembershipScalarWhereInput = {
    AND?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
    OR?: ProjectMembershipScalarWhereInput[]
    NOT?: ProjectMembershipScalarWhereInput | ProjectMembershipScalarWhereInput[]
    orgMembershipId?: StringFilter<"ProjectMembership"> | string
    projectId?: StringFilter<"ProjectMembership"> | string
    userId?: StringFilter<"ProjectMembership"> | string
    role?: EnumRoleFilter<"ProjectMembership"> | $Enums.Role
    createdAt?: DateTimeFilter<"ProjectMembership"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMembership"> | Date | string
  }

  export type MembershipInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput = {
    where: MembershipInvitationWhereUniqueInput
    update: XOR<MembershipInvitationUpdateWithoutInvitedByUserInput, MembershipInvitationUncheckedUpdateWithoutInvitedByUserInput>
    create: XOR<MembershipInvitationCreateWithoutInvitedByUserInput, MembershipInvitationUncheckedCreateWithoutInvitedByUserInput>
  }

  export type MembershipInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput = {
    where: MembershipInvitationWhereUniqueInput
    data: XOR<MembershipInvitationUpdateWithoutInvitedByUserInput, MembershipInvitationUncheckedUpdateWithoutInvitedByUserInput>
  }

  export type MembershipInvitationUpdateManyWithWhereWithoutInvitedByUserInput = {
    where: MembershipInvitationScalarWhereInput
    data: XOR<MembershipInvitationUpdateManyMutationInput, MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserInput>
  }

  export type MembershipInvitationScalarWhereInput = {
    AND?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
    OR?: MembershipInvitationScalarWhereInput[]
    NOT?: MembershipInvitationScalarWhereInput | MembershipInvitationScalarWhereInput[]
    id?: StringFilter<"MembershipInvitation"> | string
    email?: StringFilter<"MembershipInvitation"> | string
    orgId?: StringFilter<"MembershipInvitation"> | string
    orgRole?: EnumRoleFilter<"MembershipInvitation"> | $Enums.Role
    projectId?: StringNullableFilter<"MembershipInvitation"> | string | null
    projectRole?: EnumRoleNullableFilter<"MembershipInvitation"> | $Enums.Role | null
    invitedByUserId?: StringNullableFilter<"MembershipInvitation"> | string | null
    createdAt?: DateTimeFilter<"MembershipInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipInvitation"> | Date | string
  }

  export type AnnotationQueueItemUpsertWithWhereUniqueWithoutLockedByUserInput = {
    where: AnnotationQueueItemWhereUniqueInput
    update: XOR<AnnotationQueueItemUpdateWithoutLockedByUserInput, AnnotationQueueItemUncheckedUpdateWithoutLockedByUserInput>
    create: XOR<AnnotationQueueItemCreateWithoutLockedByUserInput, AnnotationQueueItemUncheckedCreateWithoutLockedByUserInput>
  }

  export type AnnotationQueueItemUpdateWithWhereUniqueWithoutLockedByUserInput = {
    where: AnnotationQueueItemWhereUniqueInput
    data: XOR<AnnotationQueueItemUpdateWithoutLockedByUserInput, AnnotationQueueItemUncheckedUpdateWithoutLockedByUserInput>
  }

  export type AnnotationQueueItemUpdateManyWithWhereWithoutLockedByUserInput = {
    where: AnnotationQueueItemScalarWhereInput
    data: XOR<AnnotationQueueItemUpdateManyMutationInput, AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserInput>
  }

  export type AnnotationQueueItemScalarWhereInput = {
    AND?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
    OR?: AnnotationQueueItemScalarWhereInput[]
    NOT?: AnnotationQueueItemScalarWhereInput | AnnotationQueueItemScalarWhereInput[]
    id?: StringFilter<"AnnotationQueueItem"> | string
    queueId?: StringFilter<"AnnotationQueueItem"> | string
    objectId?: StringFilter<"AnnotationQueueItem"> | string
    objectType?: EnumAnnotationQueueObjectTypeFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFilter<"AnnotationQueueItem"> | $Enums.AnnotationQueueStatus
    lockedAt?: DateTimeNullableFilter<"AnnotationQueueItem"> | Date | string | null
    lockedByUserId?: StringNullableFilter<"AnnotationQueueItem"> | string | null
    annotatorUserId?: StringNullableFilter<"AnnotationQueueItem"> | string | null
    completedAt?: DateTimeNullableFilter<"AnnotationQueueItem"> | Date | string | null
    projectId?: StringFilter<"AnnotationQueueItem"> | string
    createdAt?: DateTimeFilter<"AnnotationQueueItem"> | Date | string
    updatedAt?: DateTimeFilter<"AnnotationQueueItem"> | Date | string
  }

  export type AnnotationQueueItemUpsertWithWhereUniqueWithoutAnnotatorUserInput = {
    where: AnnotationQueueItemWhereUniqueInput
    update: XOR<AnnotationQueueItemUpdateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedUpdateWithoutAnnotatorUserInput>
    create: XOR<AnnotationQueueItemCreateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedCreateWithoutAnnotatorUserInput>
  }

  export type AnnotationQueueItemUpdateWithWhereUniqueWithoutAnnotatorUserInput = {
    where: AnnotationQueueItemWhereUniqueInput
    data: XOR<AnnotationQueueItemUpdateWithoutAnnotatorUserInput, AnnotationQueueItemUncheckedUpdateWithoutAnnotatorUserInput>
  }

  export type AnnotationQueueItemUpdateManyWithWhereWithoutAnnotatorUserInput = {
    where: AnnotationQueueItemScalarWhereInput
    data: XOR<AnnotationQueueItemUpdateManyMutationInput, AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserInput>
  }

  export type OrganizationMembershipCreateWithoutOrganizationInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationMembershipsInput
    ProjectMemberships?: ProjectMembershipCreateNestedManyWithoutOrganizationMembershipInput
  }

  export type OrganizationMembershipUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    ProjectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutOrganizationMembershipInput
  }

  export type OrganizationMembershipCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMembershipWhereUniqueInput
    create: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMembershipCreateManyOrganizationInputEnvelope = {
    data: OrganizationMembershipCreateManyOrganizationInput | OrganizationMembershipCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOrganizationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrganizationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectCreateManyOrganizationInputEnvelope = {
    data: ProjectCreateManyOrganizationInput | ProjectCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MembershipInvitationCreateWithoutOrganizationInput = {
    id?: string
    email: string
    orgRole: $Enums.Role
    projectRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutInvitationsInput
    invitedByUser?: UserCreateNestedOneWithoutInvitationsInput
  }

  export type MembershipInvitationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    orgRole: $Enums.Role
    projectId?: string | null
    projectRole?: $Enums.Role | null
    invitedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipInvitationCreateOrConnectWithoutOrganizationInput = {
    where: MembershipInvitationWhereUniqueInput
    create: XOR<MembershipInvitationCreateWithoutOrganizationInput, MembershipInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type MembershipInvitationCreateManyOrganizationInputEnvelope = {
    data: MembershipInvitationCreateManyOrganizationInput | MembershipInvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMembershipWhereUniqueInput
    update: XOR<OrganizationMembershipUpdateWithoutOrganizationInput, OrganizationMembershipUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMembershipWhereUniqueInput
    data: XOR<OrganizationMembershipUpdateWithoutOrganizationInput, OrganizationMembershipUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMembershipScalarWhereInput
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    orgId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    name?: StringFilter<"Project"> | string
  }

  export type MembershipInvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MembershipInvitationWhereUniqueInput
    update: XOR<MembershipInvitationUpdateWithoutOrganizationInput, MembershipInvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MembershipInvitationCreateWithoutOrganizationInput, MembershipInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type MembershipInvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MembershipInvitationWhereUniqueInput
    data: XOR<MembershipInvitationUpdateWithoutOrganizationInput, MembershipInvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type MembershipInvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: MembershipInvitationScalarWhereInput
    data: XOR<MembershipInvitationUpdateManyMutationInput, MembershipInvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectMembershipCreateWithoutProjectInput = {
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationMembership: OrganizationMembershipCreateNestedOneWithoutProjectMembershipsInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMembershipUncheckedCreateWithoutProjectInput = {
    orgMembershipId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipCreateOrConnectWithoutProjectInput = {
    where: ProjectMembershipWhereUniqueInput
    create: XOR<ProjectMembershipCreateWithoutProjectInput, ProjectMembershipUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMembershipCreateManyProjectInputEnvelope = {
    data: ProjectMembershipCreateManyProjectInput | ProjectMembershipCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutProjectsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    MembershipInvitation?: MembershipInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    MembershipInvitation?: MembershipInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type TraceCreateWithoutProjectInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    session?: TraceSessionCreateNestedOneWithoutTracesInput
  }

  export type TraceUncheckedCreateWithoutProjectInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceCreateOrConnectWithoutProjectInput = {
    where: TraceWhereUniqueInput
    create: XOR<TraceCreateWithoutProjectInput, TraceUncheckedCreateWithoutProjectInput>
  }

  export type TraceCreateManyProjectInputEnvelope = {
    data: TraceCreateManyProjectInput | TraceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ObservationCreateWithoutProjectInput = {
    id?: string
    traceId?: string | null
    type: $Enums.ObservationType
    startTime?: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model?: string | null
    internalModel?: string | null
    internalModelId?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
  }

  export type ObservationUncheckedCreateWithoutProjectInput = {
    id?: string
    traceId?: string | null
    type: $Enums.ObservationType
    startTime?: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model?: string | null
    internalModel?: string | null
    internalModelId?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
  }

  export type ObservationCreateOrConnectWithoutProjectInput = {
    where: ObservationWhereUniqueInput
    create: XOR<ObservationCreateWithoutProjectInput, ObservationUncheckedCreateWithoutProjectInput>
  }

  export type ObservationCreateManyProjectInputEnvelope = {
    data: ObservationCreateManyProjectInput | ObservationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    note?: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey?: string | null
    displaySecretKey: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type ApiKeyUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    note?: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey?: string | null
    displaySecretKey: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type ApiKeyCreateOrConnectWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput>
  }

  export type ApiKeyCreateManyProjectInputEnvelope = {
    data: ApiKeyCreateManyProjectInput | ApiKeyCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DatasetCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetItems?: DatasetItemCreateNestedManyWithoutDatasetInput
    datasetRuns?: DatasetRunsCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetItems?: DatasetItemUncheckedCreateNestedManyWithoutDatasetInput
    datasetRuns?: DatasetRunsUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetCreateOrConnectWithoutProjectInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutProjectInput, DatasetUncheckedCreateWithoutProjectInput>
  }

  export type DatasetCreateManyProjectInputEnvelope = {
    data: DatasetCreateManyProjectInput | DatasetCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type EventsCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
  }

  export type EventsUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
  }

  export type EventsCreateOrConnectWithoutProjectInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutProjectInput, EventsUncheckedCreateWithoutProjectInput>
  }

  export type EventsCreateManyProjectInputEnvelope = {
    data: EventsCreateManyProjectInput | EventsCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MembershipInvitationCreateWithoutProjectInput = {
    id?: string
    email: string
    orgRole: $Enums.Role
    projectRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembershipInvitationInput
    invitedByUser?: UserCreateNestedOneWithoutInvitationsInput
  }

  export type MembershipInvitationUncheckedCreateWithoutProjectInput = {
    id?: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectRole?: $Enums.Role | null
    invitedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipInvitationCreateOrConnectWithoutProjectInput = {
    where: MembershipInvitationWhereUniqueInput
    create: XOR<MembershipInvitationCreateWithoutProjectInput, MembershipInvitationUncheckedCreateWithoutProjectInput>
  }

  export type MembershipInvitationCreateManyProjectInputEnvelope = {
    data: MembershipInvitationCreateManyProjectInput | MembershipInvitationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TraceSessionCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarked?: boolean
    public?: boolean
    traces?: TraceCreateNestedManyWithoutSessionInput
  }

  export type TraceSessionUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarked?: boolean
    public?: boolean
    traces?: TraceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TraceSessionCreateOrConnectWithoutProjectInput = {
    where: TraceSessionWhereUniqueInput
    create: XOR<TraceSessionCreateWithoutProjectInput, TraceSessionUncheckedCreateWithoutProjectInput>
  }

  export type TraceSessionCreateManyProjectInputEnvelope = {
    data: TraceSessionCreateManyProjectInput | TraceSessionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PromptCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    prompt: JsonNullValueInput | InputJsonValue
    name: string
    version: number
    type?: string
    isActive?: boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptCreatetagsInput | string[]
    labels?: PromptCreatelabelsInput | string[]
  }

  export type PromptUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    prompt: JsonNullValueInput | InputJsonValue
    name: string
    version: number
    type?: string
    isActive?: boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptCreatetagsInput | string[]
    labels?: PromptCreatelabelsInput | string[]
  }

  export type PromptCreateOrConnectWithoutProjectInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput>
  }

  export type PromptCreateManyProjectInputEnvelope = {
    data: PromptCreateManyProjectInput | PromptCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ModelCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    Price?: PriceCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    Price?: PriceUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutProjectInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutProjectInput, ModelUncheckedCreateWithoutProjectInput>
  }

  export type ModelCreateManyProjectInputEnvelope = {
    data: ModelCreateManyProjectInput | ModelCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type EvalTemplateCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutEvalTemplateInput
  }

  export type EvalTemplateUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutEvalTemplateInput
  }

  export type EvalTemplateCreateOrConnectWithoutProjectInput = {
    where: EvalTemplateWhereUniqueInput
    create: XOR<EvalTemplateCreateWithoutProjectInput, EvalTemplateUncheckedCreateWithoutProjectInput>
  }

  export type EvalTemplateCreateManyProjectInputEnvelope = {
    data: EvalTemplateCreateManyProjectInput | EvalTemplateCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type JobConfigurationCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    evalTemplate?: EvalTemplateCreateNestedOneWithoutJobConfigurationInput
    JobExecution?: JobExecutionCreateNestedManyWithoutJobConfigurationInput
  }

  export type JobConfigurationUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    evalTemplateId?: string | null
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutJobConfigurationInput
  }

  export type JobConfigurationCreateOrConnectWithoutProjectInput = {
    where: JobConfigurationWhereUniqueInput
    create: XOR<JobConfigurationCreateWithoutProjectInput, JobConfigurationUncheckedCreateWithoutProjectInput>
  }

  export type JobConfigurationCreateManyProjectInputEnvelope = {
    data: JobConfigurationCreateManyProjectInput | JobConfigurationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type JobExecutionCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
    jobConfiguration: JobConfigurationCreateNestedOneWithoutJobExecutionInput
  }

  export type JobExecutionUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobConfigurationId: string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
  }

  export type JobExecutionCreateOrConnectWithoutProjectInput = {
    where: JobExecutionWhereUniqueInput
    create: XOR<JobExecutionCreateWithoutProjectInput, JobExecutionUncheckedCreateWithoutProjectInput>
  }

  export type JobExecutionCreateManyProjectInputEnvelope = {
    data: JobExecutionCreateManyProjectInput | JobExecutionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LlmApiKeysCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL?: string | null
    customModels?: LlmApiKeysCreatecustomModelsInput | string[]
    withDefaultModels?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LlmApiKeysUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL?: string | null
    customModels?: LlmApiKeysCreatecustomModelsInput | string[]
    withDefaultModels?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LlmApiKeysCreateOrConnectWithoutProjectInput = {
    where: LlmApiKeysWhereUniqueInput
    create: XOR<LlmApiKeysCreateWithoutProjectInput, LlmApiKeysUncheckedCreateWithoutProjectInput>
  }

  export type LlmApiKeysCreateManyProjectInputEnvelope = {
    data: LlmApiKeysCreateManyProjectInput | LlmApiKeysCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PosthogIntegrationCreateWithoutProjectInput = {
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt?: Date | string | null
    enabled: boolean
    createdAt?: Date | string
  }

  export type PosthogIntegrationUncheckedCreateWithoutProjectInput = {
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt?: Date | string | null
    enabled: boolean
    createdAt?: Date | string
  }

  export type PosthogIntegrationCreateOrConnectWithoutProjectInput = {
    where: PosthogIntegrationWhereUniqueInput
    create: XOR<PosthogIntegrationCreateWithoutProjectInput, PosthogIntegrationUncheckedCreateWithoutProjectInput>
  }

  export type PosthogIntegrationCreateManyProjectInputEnvelope = {
    data: PosthogIntegrationCreateManyProjectInput | PosthogIntegrationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ScoreCreateWithoutProjectInput = {
    id?: string
    timestamp?: Date | string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
    scoreConfig?: ScoreConfigCreateNestedOneWithoutScoreInput
  }

  export type ScoreUncheckedCreateWithoutProjectInput = {
    id?: string
    timestamp?: Date | string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    configId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
  }

  export type ScoreCreateOrConnectWithoutProjectInput = {
    where: ScoreWhereUniqueInput
    create: XOR<ScoreCreateWithoutProjectInput, ScoreUncheckedCreateWithoutProjectInput>
  }

  export type ScoreCreateManyProjectInputEnvelope = {
    data: ScoreCreateManyProjectInput | ScoreCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ScoreConfigCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    score?: ScoreCreateNestedManyWithoutScoreConfigInput
  }

  export type ScoreConfigUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    score?: ScoreUncheckedCreateNestedManyWithoutScoreConfigInput
  }

  export type ScoreConfigCreateOrConnectWithoutProjectInput = {
    where: ScoreConfigWhereUniqueInput
    create: XOR<ScoreConfigCreateWithoutProjectInput, ScoreConfigUncheckedCreateWithoutProjectInput>
  }

  export type ScoreConfigCreateManyProjectInputEnvelope = {
    data: ScoreConfigCreateManyProjectInput | ScoreConfigCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BatchExportCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    finishedAt?: Date | string | null
    expiresAt?: Date | string | null
    name: string
    status: string
    query: JsonNullValueInput | InputJsonValue
    format: string
    url?: string | null
    log?: string | null
  }

  export type BatchExportUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    finishedAt?: Date | string | null
    expiresAt?: Date | string | null
    name: string
    status: string
    query: JsonNullValueInput | InputJsonValue
    format: string
    url?: string | null
    log?: string | null
  }

  export type BatchExportCreateOrConnectWithoutProjectInput = {
    where: BatchExportWhereUniqueInput
    create: XOR<BatchExportCreateWithoutProjectInput, BatchExportUncheckedCreateWithoutProjectInput>
  }

  export type BatchExportCreateManyProjectInputEnvelope = {
    data: BatchExportCreateManyProjectInput | BatchExportCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutProjectInput = {
    id?: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    authorUserId?: string | null
  }

  export type CommentUncheckedCreateWithoutProjectInput = {
    id?: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    authorUserId?: string | null
  }

  export type CommentCreateOrConnectWithoutProjectInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput>
  }

  export type CommentCreateManyProjectInputEnvelope = {
    data: CommentCreateManyProjectInput | CommentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationQueueCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutQueueInput
  }

  export type AnnotationQueueUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutQueueInput
  }

  export type AnnotationQueueCreateOrConnectWithoutProjectInput = {
    where: AnnotationQueueWhereUniqueInput
    create: XOR<AnnotationQueueCreateWithoutProjectInput, AnnotationQueueUncheckedCreateWithoutProjectInput>
  }

  export type AnnotationQueueCreateManyProjectInputEnvelope = {
    data: AnnotationQueueCreateManyProjectInput | AnnotationQueueCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationQueueItemCreateWithoutProjectInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: AnnotationQueueCreateNestedOneWithoutAnnotationQueueItemInput
    lockedByUser?: UserCreateNestedOneWithoutAnnotatedLockedItemInput
    annotatorUser?: UserCreateNestedOneWithoutAnnotatedCompletedItemInput
  }

  export type AnnotationQueueItemUncheckedCreateWithoutProjectInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateOrConnectWithoutProjectInput = {
    where: AnnotationQueueItemWhereUniqueInput
    create: XOR<AnnotationQueueItemCreateWithoutProjectInput, AnnotationQueueItemUncheckedCreateWithoutProjectInput>
  }

  export type AnnotationQueueItemCreateManyProjectInputEnvelope = {
    data: AnnotationQueueItemCreateManyProjectInput | AnnotationQueueItemCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TraceMediaCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    field: string
    media: MediaCreateNestedOneWithoutTraceMediaInput
  }

  export type TraceMediaUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    field: string
  }

  export type TraceMediaCreateOrConnectWithoutProjectInput = {
    where: TraceMediaWhereUniqueInput
    create: XOR<TraceMediaCreateWithoutProjectInput, TraceMediaUncheckedCreateWithoutProjectInput>
  }

  export type TraceMediaCreateManyProjectInputEnvelope = {
    data: TraceMediaCreateManyProjectInput | TraceMediaCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutProjectInput = {
    id?: string
    sha256Hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    TraceMedia?: TraceMediaCreateNestedManyWithoutMediaInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutProjectInput = {
    id?: string
    sha256Hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutMediaInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutProjectInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput>
  }

  export type MediaCreateManyProjectInputEnvelope = {
    data: MediaCreateManyProjectInput | MediaCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ObservationMediaCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    observationId: string
    field: string
    media: MediaCreateNestedOneWithoutObservationMediaInput
  }

  export type ObservationMediaUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    observationId: string
    field: string
  }

  export type ObservationMediaCreateOrConnectWithoutProjectInput = {
    where: ObservationMediaWhereUniqueInput
    create: XOR<ObservationMediaCreateWithoutProjectInput, ObservationMediaUncheckedCreateWithoutProjectInput>
  }

  export type ObservationMediaCreateManyProjectInputEnvelope = {
    data: ObservationMediaCreateManyProjectInput | ObservationMediaCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMembershipUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMembershipWhereUniqueInput
    update: XOR<ProjectMembershipUpdateWithoutProjectInput, ProjectMembershipUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMembershipCreateWithoutProjectInput, ProjectMembershipUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMembershipUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMembershipWhereUniqueInput
    data: XOR<ProjectMembershipUpdateWithoutProjectInput, ProjectMembershipUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMembershipUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMembershipScalarWhereInput
    data: XOR<ProjectMembershipUpdateManyMutationInput, ProjectMembershipUncheckedUpdateManyWithoutProjectInput>
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    MembershipInvitation?: MembershipInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    MembershipInvitation?: MembershipInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TraceUpsertWithWhereUniqueWithoutProjectInput = {
    where: TraceWhereUniqueInput
    update: XOR<TraceUpdateWithoutProjectInput, TraceUncheckedUpdateWithoutProjectInput>
    create: XOR<TraceCreateWithoutProjectInput, TraceUncheckedCreateWithoutProjectInput>
  }

  export type TraceUpdateWithWhereUniqueWithoutProjectInput = {
    where: TraceWhereUniqueInput
    data: XOR<TraceUpdateWithoutProjectInput, TraceUncheckedUpdateWithoutProjectInput>
  }

  export type TraceUpdateManyWithWhereWithoutProjectInput = {
    where: TraceScalarWhereInput
    data: XOR<TraceUpdateManyMutationInput, TraceUncheckedUpdateManyWithoutProjectInput>
  }

  export type TraceScalarWhereInput = {
    AND?: TraceScalarWhereInput | TraceScalarWhereInput[]
    OR?: TraceScalarWhereInput[]
    NOT?: TraceScalarWhereInput | TraceScalarWhereInput[]
    id?: StringFilter<"Trace"> | string
    externalId?: StringNullableFilter<"Trace"> | string | null
    timestamp?: DateTimeFilter<"Trace"> | Date | string
    name?: StringNullableFilter<"Trace"> | string | null
    userId?: StringNullableFilter<"Trace"> | string | null
    metadata?: JsonNullableFilter<"Trace">
    release?: StringNullableFilter<"Trace"> | string | null
    version?: StringNullableFilter<"Trace"> | string | null
    projectId?: StringFilter<"Trace"> | string
    public?: BoolFilter<"Trace"> | boolean
    bookmarked?: BoolFilter<"Trace"> | boolean
    tags?: StringNullableListFilter<"Trace">
    input?: JsonNullableFilter<"Trace">
    output?: JsonNullableFilter<"Trace">
    sessionId?: StringNullableFilter<"Trace"> | string | null
    createdAt?: DateTimeFilter<"Trace"> | Date | string
    updatedAt?: DateTimeFilter<"Trace"> | Date | string
  }

  export type ObservationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ObservationWhereUniqueInput
    update: XOR<ObservationUpdateWithoutProjectInput, ObservationUncheckedUpdateWithoutProjectInput>
    create: XOR<ObservationCreateWithoutProjectInput, ObservationUncheckedCreateWithoutProjectInput>
  }

  export type ObservationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ObservationWhereUniqueInput
    data: XOR<ObservationUpdateWithoutProjectInput, ObservationUncheckedUpdateWithoutProjectInput>
  }

  export type ObservationUpdateManyWithWhereWithoutProjectInput = {
    where: ObservationScalarWhereInput
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyWithoutProjectInput>
  }

  export type ObservationScalarWhereInput = {
    AND?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    OR?: ObservationScalarWhereInput[]
    NOT?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    id?: StringFilter<"Observation"> | string
    traceId?: StringNullableFilter<"Observation"> | string | null
    projectId?: StringFilter<"Observation"> | string
    type?: EnumObservationTypeFilter<"Observation"> | $Enums.ObservationType
    startTime?: DateTimeFilter<"Observation"> | Date | string
    endTime?: DateTimeNullableFilter<"Observation"> | Date | string | null
    name?: StringNullableFilter<"Observation"> | string | null
    metadata?: JsonNullableFilter<"Observation">
    parentObservationId?: StringNullableFilter<"Observation"> | string | null
    level?: EnumObservationLevelFilter<"Observation"> | $Enums.ObservationLevel
    statusMessage?: StringNullableFilter<"Observation"> | string | null
    version?: StringNullableFilter<"Observation"> | string | null
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    updatedAt?: DateTimeFilter<"Observation"> | Date | string
    model?: StringNullableFilter<"Observation"> | string | null
    internalModel?: StringNullableFilter<"Observation"> | string | null
    internalModelId?: StringNullableFilter<"Observation"> | string | null
    modelParameters?: JsonNullableFilter<"Observation">
    input?: JsonNullableFilter<"Observation">
    output?: JsonNullableFilter<"Observation">
    promptTokens?: IntFilter<"Observation"> | number
    completionTokens?: IntFilter<"Observation"> | number
    totalTokens?: IntFilter<"Observation"> | number
    unit?: StringNullableFilter<"Observation"> | string | null
    inputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: DecimalNullableFilter<"Observation"> | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: DateTimeNullableFilter<"Observation"> | Date | string | null
    promptId?: StringNullableFilter<"Observation"> | string | null
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutProjectInput, ApiKeyUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutProjectInput, ApiKeyUncheckedUpdateWithoutProjectInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutProjectInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    note?: StringNullableFilter<"ApiKey"> | string | null
    publicKey?: StringFilter<"ApiKey"> | string
    hashedSecretKey?: StringFilter<"ApiKey"> | string
    fastHashedSecretKey?: StringNullableFilter<"ApiKey"> | string | null
    displaySecretKey?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    projectId?: StringFilter<"ApiKey"> | string
  }

  export type DatasetUpsertWithWhereUniqueWithoutProjectInput = {
    where: DatasetWhereUniqueInput
    update: XOR<DatasetUpdateWithoutProjectInput, DatasetUncheckedUpdateWithoutProjectInput>
    create: XOR<DatasetCreateWithoutProjectInput, DatasetUncheckedCreateWithoutProjectInput>
  }

  export type DatasetUpdateWithWhereUniqueWithoutProjectInput = {
    where: DatasetWhereUniqueInput
    data: XOR<DatasetUpdateWithoutProjectInput, DatasetUncheckedUpdateWithoutProjectInput>
  }

  export type DatasetUpdateManyWithWhereWithoutProjectInput = {
    where: DatasetScalarWhereInput
    data: XOR<DatasetUpdateManyMutationInput, DatasetUncheckedUpdateManyWithoutProjectInput>
  }

  export type DatasetScalarWhereInput = {
    AND?: DatasetScalarWhereInput | DatasetScalarWhereInput[]
    OR?: DatasetScalarWhereInput[]
    NOT?: DatasetScalarWhereInput | DatasetScalarWhereInput[]
    id?: StringFilter<"Dataset"> | string
    projectId?: StringFilter<"Dataset"> | string
    name?: StringFilter<"Dataset"> | string
    description?: StringNullableFilter<"Dataset"> | string | null
    metadata?: JsonNullableFilter<"Dataset">
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
  }

  export type EventsUpsertWithWhereUniqueWithoutProjectInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutProjectInput, EventsUncheckedUpdateWithoutProjectInput>
    create: XOR<EventsCreateWithoutProjectInput, EventsUncheckedCreateWithoutProjectInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutProjectInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutProjectInput, EventsUncheckedUpdateWithoutProjectInput>
  }

  export type EventsUpdateManyWithWhereWithoutProjectInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutProjectInput>
  }

  export type EventsScalarWhereInput = {
    AND?: EventsScalarWhereInput | EventsScalarWhereInput[]
    OR?: EventsScalarWhereInput[]
    NOT?: EventsScalarWhereInput | EventsScalarWhereInput[]
    id?: StringFilter<"Events"> | string
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
    projectId?: StringFilter<"Events"> | string
    data?: JsonFilter<"Events">
    headers?: JsonFilter<"Events">
    url?: StringNullableFilter<"Events"> | string | null
    method?: StringNullableFilter<"Events"> | string | null
  }

  export type MembershipInvitationUpsertWithWhereUniqueWithoutProjectInput = {
    where: MembershipInvitationWhereUniqueInput
    update: XOR<MembershipInvitationUpdateWithoutProjectInput, MembershipInvitationUncheckedUpdateWithoutProjectInput>
    create: XOR<MembershipInvitationCreateWithoutProjectInput, MembershipInvitationUncheckedCreateWithoutProjectInput>
  }

  export type MembershipInvitationUpdateWithWhereUniqueWithoutProjectInput = {
    where: MembershipInvitationWhereUniqueInput
    data: XOR<MembershipInvitationUpdateWithoutProjectInput, MembershipInvitationUncheckedUpdateWithoutProjectInput>
  }

  export type MembershipInvitationUpdateManyWithWhereWithoutProjectInput = {
    where: MembershipInvitationScalarWhereInput
    data: XOR<MembershipInvitationUpdateManyMutationInput, MembershipInvitationUncheckedUpdateManyWithoutProjectInput>
  }

  export type TraceSessionUpsertWithWhereUniqueWithoutProjectInput = {
    where: TraceSessionWhereUniqueInput
    update: XOR<TraceSessionUpdateWithoutProjectInput, TraceSessionUncheckedUpdateWithoutProjectInput>
    create: XOR<TraceSessionCreateWithoutProjectInput, TraceSessionUncheckedCreateWithoutProjectInput>
  }

  export type TraceSessionUpdateWithWhereUniqueWithoutProjectInput = {
    where: TraceSessionWhereUniqueInput
    data: XOR<TraceSessionUpdateWithoutProjectInput, TraceSessionUncheckedUpdateWithoutProjectInput>
  }

  export type TraceSessionUpdateManyWithWhereWithoutProjectInput = {
    where: TraceSessionScalarWhereInput
    data: XOR<TraceSessionUpdateManyMutationInput, TraceSessionUncheckedUpdateManyWithoutProjectInput>
  }

  export type TraceSessionScalarWhereInput = {
    AND?: TraceSessionScalarWhereInput | TraceSessionScalarWhereInput[]
    OR?: TraceSessionScalarWhereInput[]
    NOT?: TraceSessionScalarWhereInput | TraceSessionScalarWhereInput[]
    id?: StringFilter<"TraceSession"> | string
    createdAt?: DateTimeFilter<"TraceSession"> | Date | string
    updatedAt?: DateTimeFilter<"TraceSession"> | Date | string
    projectId?: StringFilter<"TraceSession"> | string
    bookmarked?: BoolFilter<"TraceSession"> | boolean
    public?: BoolFilter<"TraceSession"> | boolean
  }

  export type PromptUpsertWithWhereUniqueWithoutProjectInput = {
    where: PromptWhereUniqueInput
    update: XOR<PromptUpdateWithoutProjectInput, PromptUncheckedUpdateWithoutProjectInput>
    create: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput>
  }

  export type PromptUpdateWithWhereUniqueWithoutProjectInput = {
    where: PromptWhereUniqueInput
    data: XOR<PromptUpdateWithoutProjectInput, PromptUncheckedUpdateWithoutProjectInput>
  }

  export type PromptUpdateManyWithWhereWithoutProjectInput = {
    where: PromptScalarWhereInput
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyWithoutProjectInput>
  }

  export type PromptScalarWhereInput = {
    AND?: PromptScalarWhereInput | PromptScalarWhereInput[]
    OR?: PromptScalarWhereInput[]
    NOT?: PromptScalarWhereInput | PromptScalarWhereInput[]
    id?: StringFilter<"Prompt"> | string
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    projectId?: StringFilter<"Prompt"> | string
    createdBy?: StringFilter<"Prompt"> | string
    prompt?: JsonFilter<"Prompt">
    name?: StringFilter<"Prompt"> | string
    version?: IntFilter<"Prompt"> | number
    type?: StringFilter<"Prompt"> | string
    isActive?: BoolNullableFilter<"Prompt"> | boolean | null
    config?: JsonFilter<"Prompt">
    tags?: StringNullableListFilter<"Prompt">
    labels?: StringNullableListFilter<"Prompt">
  }

  export type ModelUpsertWithWhereUniqueWithoutProjectInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutProjectInput, ModelUncheckedUpdateWithoutProjectInput>
    create: XOR<ModelCreateWithoutProjectInput, ModelUncheckedCreateWithoutProjectInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutProjectInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutProjectInput, ModelUncheckedUpdateWithoutProjectInput>
  }

  export type ModelUpdateManyWithWhereWithoutProjectInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutProjectInput>
  }

  export type ModelScalarWhereInput = {
    AND?: ModelScalarWhereInput | ModelScalarWhereInput[]
    OR?: ModelScalarWhereInput[]
    NOT?: ModelScalarWhereInput | ModelScalarWhereInput[]
    id?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    projectId?: StringNullableFilter<"Model"> | string | null
    modelName?: StringFilter<"Model"> | string
    matchPattern?: StringFilter<"Model"> | string
    startDate?: DateTimeNullableFilter<"Model"> | Date | string | null
    inputPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    outputPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"Model"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"Model"> | string | null
    tokenizerId?: StringNullableFilter<"Model"> | string | null
    tokenizerConfig?: JsonNullableFilter<"Model">
  }

  export type EvalTemplateUpsertWithWhereUniqueWithoutProjectInput = {
    where: EvalTemplateWhereUniqueInput
    update: XOR<EvalTemplateUpdateWithoutProjectInput, EvalTemplateUncheckedUpdateWithoutProjectInput>
    create: XOR<EvalTemplateCreateWithoutProjectInput, EvalTemplateUncheckedCreateWithoutProjectInput>
  }

  export type EvalTemplateUpdateWithWhereUniqueWithoutProjectInput = {
    where: EvalTemplateWhereUniqueInput
    data: XOR<EvalTemplateUpdateWithoutProjectInput, EvalTemplateUncheckedUpdateWithoutProjectInput>
  }

  export type EvalTemplateUpdateManyWithWhereWithoutProjectInput = {
    where: EvalTemplateScalarWhereInput
    data: XOR<EvalTemplateUpdateManyMutationInput, EvalTemplateUncheckedUpdateManyWithoutProjectInput>
  }

  export type EvalTemplateScalarWhereInput = {
    AND?: EvalTemplateScalarWhereInput | EvalTemplateScalarWhereInput[]
    OR?: EvalTemplateScalarWhereInput[]
    NOT?: EvalTemplateScalarWhereInput | EvalTemplateScalarWhereInput[]
    id?: StringFilter<"EvalTemplate"> | string
    createdAt?: DateTimeFilter<"EvalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EvalTemplate"> | Date | string
    projectId?: StringFilter<"EvalTemplate"> | string
    name?: StringFilter<"EvalTemplate"> | string
    version?: IntFilter<"EvalTemplate"> | number
    prompt?: StringFilter<"EvalTemplate"> | string
    model?: StringFilter<"EvalTemplate"> | string
    provider?: StringFilter<"EvalTemplate"> | string
    modelParams?: JsonFilter<"EvalTemplate">
    vars?: StringNullableListFilter<"EvalTemplate">
    outputSchema?: JsonFilter<"EvalTemplate">
  }

  export type JobConfigurationUpsertWithWhereUniqueWithoutProjectInput = {
    where: JobConfigurationWhereUniqueInput
    update: XOR<JobConfigurationUpdateWithoutProjectInput, JobConfigurationUncheckedUpdateWithoutProjectInput>
    create: XOR<JobConfigurationCreateWithoutProjectInput, JobConfigurationUncheckedCreateWithoutProjectInput>
  }

  export type JobConfigurationUpdateWithWhereUniqueWithoutProjectInput = {
    where: JobConfigurationWhereUniqueInput
    data: XOR<JobConfigurationUpdateWithoutProjectInput, JobConfigurationUncheckedUpdateWithoutProjectInput>
  }

  export type JobConfigurationUpdateManyWithWhereWithoutProjectInput = {
    where: JobConfigurationScalarWhereInput
    data: XOR<JobConfigurationUpdateManyMutationInput, JobConfigurationUncheckedUpdateManyWithoutProjectInput>
  }

  export type JobConfigurationScalarWhereInput = {
    AND?: JobConfigurationScalarWhereInput | JobConfigurationScalarWhereInput[]
    OR?: JobConfigurationScalarWhereInput[]
    NOT?: JobConfigurationScalarWhereInput | JobConfigurationScalarWhereInput[]
    id?: StringFilter<"JobConfiguration"> | string
    createdAt?: DateTimeFilter<"JobConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"JobConfiguration"> | Date | string
    projectId?: StringFilter<"JobConfiguration"> | string
    jobType?: EnumJobTypeFilter<"JobConfiguration"> | $Enums.JobType
    status?: EnumJobConfigStateFilter<"JobConfiguration"> | $Enums.JobConfigState
    evalTemplateId?: StringNullableFilter<"JobConfiguration"> | string | null
    scoreName?: StringFilter<"JobConfiguration"> | string
    filter?: JsonFilter<"JobConfiguration">
    targetObject?: StringFilter<"JobConfiguration"> | string
    variableMapping?: JsonFilter<"JobConfiguration">
    sampling?: DecimalFilter<"JobConfiguration"> | Decimal | DecimalJsLike | number | string
    delay?: IntFilter<"JobConfiguration"> | number
  }

  export type JobExecutionUpsertWithWhereUniqueWithoutProjectInput = {
    where: JobExecutionWhereUniqueInput
    update: XOR<JobExecutionUpdateWithoutProjectInput, JobExecutionUncheckedUpdateWithoutProjectInput>
    create: XOR<JobExecutionCreateWithoutProjectInput, JobExecutionUncheckedCreateWithoutProjectInput>
  }

  export type JobExecutionUpdateWithWhereUniqueWithoutProjectInput = {
    where: JobExecutionWhereUniqueInput
    data: XOR<JobExecutionUpdateWithoutProjectInput, JobExecutionUncheckedUpdateWithoutProjectInput>
  }

  export type JobExecutionUpdateManyWithWhereWithoutProjectInput = {
    where: JobExecutionScalarWhereInput
    data: XOR<JobExecutionUpdateManyMutationInput, JobExecutionUncheckedUpdateManyWithoutProjectInput>
  }

  export type JobExecutionScalarWhereInput = {
    AND?: JobExecutionScalarWhereInput | JobExecutionScalarWhereInput[]
    OR?: JobExecutionScalarWhereInput[]
    NOT?: JobExecutionScalarWhereInput | JobExecutionScalarWhereInput[]
    id?: StringFilter<"JobExecution"> | string
    createdAt?: DateTimeFilter<"JobExecution"> | Date | string
    updatedAt?: DateTimeFilter<"JobExecution"> | Date | string
    projectId?: StringFilter<"JobExecution"> | string
    jobConfigurationId?: StringFilter<"JobExecution"> | string
    status?: EnumJobExecutionStatusFilter<"JobExecution"> | $Enums.JobExecutionStatus
    startTime?: DateTimeNullableFilter<"JobExecution"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobExecution"> | Date | string | null
    error?: StringNullableFilter<"JobExecution"> | string | null
    jobInputTraceId?: StringNullableFilter<"JobExecution"> | string | null
    jobInputObservationId?: StringNullableFilter<"JobExecution"> | string | null
    jobInputDatasetItemId?: StringNullableFilter<"JobExecution"> | string | null
    jobOutputScoreId?: StringNullableFilter<"JobExecution"> | string | null
  }

  export type LlmApiKeysUpsertWithWhereUniqueWithoutProjectInput = {
    where: LlmApiKeysWhereUniqueInput
    update: XOR<LlmApiKeysUpdateWithoutProjectInput, LlmApiKeysUncheckedUpdateWithoutProjectInput>
    create: XOR<LlmApiKeysCreateWithoutProjectInput, LlmApiKeysUncheckedCreateWithoutProjectInput>
  }

  export type LlmApiKeysUpdateWithWhereUniqueWithoutProjectInput = {
    where: LlmApiKeysWhereUniqueInput
    data: XOR<LlmApiKeysUpdateWithoutProjectInput, LlmApiKeysUncheckedUpdateWithoutProjectInput>
  }

  export type LlmApiKeysUpdateManyWithWhereWithoutProjectInput = {
    where: LlmApiKeysScalarWhereInput
    data: XOR<LlmApiKeysUpdateManyMutationInput, LlmApiKeysUncheckedUpdateManyWithoutProjectInput>
  }

  export type LlmApiKeysScalarWhereInput = {
    AND?: LlmApiKeysScalarWhereInput | LlmApiKeysScalarWhereInput[]
    OR?: LlmApiKeysScalarWhereInput[]
    NOT?: LlmApiKeysScalarWhereInput | LlmApiKeysScalarWhereInput[]
    id?: StringFilter<"LlmApiKeys"> | string
    createdAt?: DateTimeFilter<"LlmApiKeys"> | Date | string
    updatedAt?: DateTimeFilter<"LlmApiKeys"> | Date | string
    provider?: StringFilter<"LlmApiKeys"> | string
    adapter?: StringFilter<"LlmApiKeys"> | string
    displaySecretKey?: StringFilter<"LlmApiKeys"> | string
    secretKey?: StringFilter<"LlmApiKeys"> | string
    baseURL?: StringNullableFilter<"LlmApiKeys"> | string | null
    customModels?: StringNullableListFilter<"LlmApiKeys">
    withDefaultModels?: BoolFilter<"LlmApiKeys"> | boolean
    config?: JsonNullableFilter<"LlmApiKeys">
    projectId?: StringFilter<"LlmApiKeys"> | string
  }

  export type PosthogIntegrationUpsertWithWhereUniqueWithoutProjectInput = {
    where: PosthogIntegrationWhereUniqueInput
    update: XOR<PosthogIntegrationUpdateWithoutProjectInput, PosthogIntegrationUncheckedUpdateWithoutProjectInput>
    create: XOR<PosthogIntegrationCreateWithoutProjectInput, PosthogIntegrationUncheckedCreateWithoutProjectInput>
  }

  export type PosthogIntegrationUpdateWithWhereUniqueWithoutProjectInput = {
    where: PosthogIntegrationWhereUniqueInput
    data: XOR<PosthogIntegrationUpdateWithoutProjectInput, PosthogIntegrationUncheckedUpdateWithoutProjectInput>
  }

  export type PosthogIntegrationUpdateManyWithWhereWithoutProjectInput = {
    where: PosthogIntegrationScalarWhereInput
    data: XOR<PosthogIntegrationUpdateManyMutationInput, PosthogIntegrationUncheckedUpdateManyWithoutProjectInput>
  }

  export type PosthogIntegrationScalarWhereInput = {
    AND?: PosthogIntegrationScalarWhereInput | PosthogIntegrationScalarWhereInput[]
    OR?: PosthogIntegrationScalarWhereInput[]
    NOT?: PosthogIntegrationScalarWhereInput | PosthogIntegrationScalarWhereInput[]
    projectId?: StringFilter<"PosthogIntegration"> | string
    encryptedPosthogApiKey?: StringFilter<"PosthogIntegration"> | string
    posthogHostName?: StringFilter<"PosthogIntegration"> | string
    lastSyncAt?: DateTimeNullableFilter<"PosthogIntegration"> | Date | string | null
    enabled?: BoolFilter<"PosthogIntegration"> | boolean
    createdAt?: DateTimeFilter<"PosthogIntegration"> | Date | string
  }

  export type ScoreUpsertWithWhereUniqueWithoutProjectInput = {
    where: ScoreWhereUniqueInput
    update: XOR<ScoreUpdateWithoutProjectInput, ScoreUncheckedUpdateWithoutProjectInput>
    create: XOR<ScoreCreateWithoutProjectInput, ScoreUncheckedCreateWithoutProjectInput>
  }

  export type ScoreUpdateWithWhereUniqueWithoutProjectInput = {
    where: ScoreWhereUniqueInput
    data: XOR<ScoreUpdateWithoutProjectInput, ScoreUncheckedUpdateWithoutProjectInput>
  }

  export type ScoreUpdateManyWithWhereWithoutProjectInput = {
    where: ScoreScalarWhereInput
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScoreScalarWhereInput = {
    AND?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
    OR?: ScoreScalarWhereInput[]
    NOT?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
    id?: StringFilter<"Score"> | string
    timestamp?: DateTimeFilter<"Score"> | Date | string
    projectId?: StringFilter<"Score"> | string
    name?: StringFilter<"Score"> | string
    value?: FloatNullableFilter<"Score"> | number | null
    source?: EnumScoreSourceFilter<"Score"> | $Enums.ScoreSource
    authorUserId?: StringNullableFilter<"Score"> | string | null
    comment?: StringNullableFilter<"Score"> | string | null
    traceId?: StringFilter<"Score"> | string
    observationId?: StringNullableFilter<"Score"> | string | null
    configId?: StringNullableFilter<"Score"> | string | null
    stringValue?: StringNullableFilter<"Score"> | string | null
    queueId?: StringNullableFilter<"Score"> | string | null
    createdAt?: DateTimeFilter<"Score"> | Date | string
    updatedAt?: DateTimeFilter<"Score"> | Date | string
    dataType?: EnumScoreDataTypeFilter<"Score"> | $Enums.ScoreDataType
  }

  export type ScoreConfigUpsertWithWhereUniqueWithoutProjectInput = {
    where: ScoreConfigWhereUniqueInput
    update: XOR<ScoreConfigUpdateWithoutProjectInput, ScoreConfigUncheckedUpdateWithoutProjectInput>
    create: XOR<ScoreConfigCreateWithoutProjectInput, ScoreConfigUncheckedCreateWithoutProjectInput>
  }

  export type ScoreConfigUpdateWithWhereUniqueWithoutProjectInput = {
    where: ScoreConfigWhereUniqueInput
    data: XOR<ScoreConfigUpdateWithoutProjectInput, ScoreConfigUncheckedUpdateWithoutProjectInput>
  }

  export type ScoreConfigUpdateManyWithWhereWithoutProjectInput = {
    where: ScoreConfigScalarWhereInput
    data: XOR<ScoreConfigUpdateManyMutationInput, ScoreConfigUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScoreConfigScalarWhereInput = {
    AND?: ScoreConfigScalarWhereInput | ScoreConfigScalarWhereInput[]
    OR?: ScoreConfigScalarWhereInput[]
    NOT?: ScoreConfigScalarWhereInput | ScoreConfigScalarWhereInput[]
    id?: StringFilter<"ScoreConfig"> | string
    createdAt?: DateTimeFilter<"ScoreConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ScoreConfig"> | Date | string
    projectId?: StringFilter<"ScoreConfig"> | string
    name?: StringFilter<"ScoreConfig"> | string
    dataType?: EnumScoreDataTypeFilter<"ScoreConfig"> | $Enums.ScoreDataType
    isArchived?: BoolFilter<"ScoreConfig"> | boolean
    minValue?: FloatNullableFilter<"ScoreConfig"> | number | null
    maxValue?: FloatNullableFilter<"ScoreConfig"> | number | null
    categories?: JsonNullableFilter<"ScoreConfig">
    description?: StringNullableFilter<"ScoreConfig"> | string | null
  }

  export type BatchExportUpsertWithWhereUniqueWithoutProjectInput = {
    where: BatchExportWhereUniqueInput
    update: XOR<BatchExportUpdateWithoutProjectInput, BatchExportUncheckedUpdateWithoutProjectInput>
    create: XOR<BatchExportCreateWithoutProjectInput, BatchExportUncheckedCreateWithoutProjectInput>
  }

  export type BatchExportUpdateWithWhereUniqueWithoutProjectInput = {
    where: BatchExportWhereUniqueInput
    data: XOR<BatchExportUpdateWithoutProjectInput, BatchExportUncheckedUpdateWithoutProjectInput>
  }

  export type BatchExportUpdateManyWithWhereWithoutProjectInput = {
    where: BatchExportScalarWhereInput
    data: XOR<BatchExportUpdateManyMutationInput, BatchExportUncheckedUpdateManyWithoutProjectInput>
  }

  export type BatchExportScalarWhereInput = {
    AND?: BatchExportScalarWhereInput | BatchExportScalarWhereInput[]
    OR?: BatchExportScalarWhereInput[]
    NOT?: BatchExportScalarWhereInput | BatchExportScalarWhereInput[]
    id?: StringFilter<"BatchExport"> | string
    createdAt?: DateTimeFilter<"BatchExport"> | Date | string
    updatedAt?: DateTimeFilter<"BatchExport"> | Date | string
    projectId?: StringFilter<"BatchExport"> | string
    userId?: StringFilter<"BatchExport"> | string
    finishedAt?: DateTimeNullableFilter<"BatchExport"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"BatchExport"> | Date | string | null
    name?: StringFilter<"BatchExport"> | string
    status?: StringFilter<"BatchExport"> | string
    query?: JsonFilter<"BatchExport">
    format?: StringFilter<"BatchExport"> | string
    url?: StringNullableFilter<"BatchExport"> | string | null
    log?: StringNullableFilter<"BatchExport"> | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutProjectInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProjectInput, CommentUncheckedUpdateWithoutProjectInput>
    create: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProjectInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProjectInput, CommentUncheckedUpdateWithoutProjectInput>
  }

  export type CommentUpdateManyWithWhereWithoutProjectInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProjectInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    projectId?: StringFilter<"Comment"> | string
    objectType?: EnumCommentObjectTypeFilter<"Comment"> | $Enums.CommentObjectType
    objectId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    authorUserId?: StringNullableFilter<"Comment"> | string | null
  }

  export type AnnotationQueueUpsertWithWhereUniqueWithoutProjectInput = {
    where: AnnotationQueueWhereUniqueInput
    update: XOR<AnnotationQueueUpdateWithoutProjectInput, AnnotationQueueUncheckedUpdateWithoutProjectInput>
    create: XOR<AnnotationQueueCreateWithoutProjectInput, AnnotationQueueUncheckedCreateWithoutProjectInput>
  }

  export type AnnotationQueueUpdateWithWhereUniqueWithoutProjectInput = {
    where: AnnotationQueueWhereUniqueInput
    data: XOR<AnnotationQueueUpdateWithoutProjectInput, AnnotationQueueUncheckedUpdateWithoutProjectInput>
  }

  export type AnnotationQueueUpdateManyWithWhereWithoutProjectInput = {
    where: AnnotationQueueScalarWhereInput
    data: XOR<AnnotationQueueUpdateManyMutationInput, AnnotationQueueUncheckedUpdateManyWithoutProjectInput>
  }

  export type AnnotationQueueScalarWhereInput = {
    AND?: AnnotationQueueScalarWhereInput | AnnotationQueueScalarWhereInput[]
    OR?: AnnotationQueueScalarWhereInput[]
    NOT?: AnnotationQueueScalarWhereInput | AnnotationQueueScalarWhereInput[]
    id?: StringFilter<"AnnotationQueue"> | string
    name?: StringFilter<"AnnotationQueue"> | string
    description?: StringNullableFilter<"AnnotationQueue"> | string | null
    scoreConfigIds?: StringNullableListFilter<"AnnotationQueue">
    projectId?: StringFilter<"AnnotationQueue"> | string
    createdAt?: DateTimeFilter<"AnnotationQueue"> | Date | string
    updatedAt?: DateTimeFilter<"AnnotationQueue"> | Date | string
  }

  export type AnnotationQueueItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: AnnotationQueueItemWhereUniqueInput
    update: XOR<AnnotationQueueItemUpdateWithoutProjectInput, AnnotationQueueItemUncheckedUpdateWithoutProjectInput>
    create: XOR<AnnotationQueueItemCreateWithoutProjectInput, AnnotationQueueItemUncheckedCreateWithoutProjectInput>
  }

  export type AnnotationQueueItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: AnnotationQueueItemWhereUniqueInput
    data: XOR<AnnotationQueueItemUpdateWithoutProjectInput, AnnotationQueueItemUncheckedUpdateWithoutProjectInput>
  }

  export type AnnotationQueueItemUpdateManyWithWhereWithoutProjectInput = {
    where: AnnotationQueueItemScalarWhereInput
    data: XOR<AnnotationQueueItemUpdateManyMutationInput, AnnotationQueueItemUncheckedUpdateManyWithoutProjectInput>
  }

  export type TraceMediaUpsertWithWhereUniqueWithoutProjectInput = {
    where: TraceMediaWhereUniqueInput
    update: XOR<TraceMediaUpdateWithoutProjectInput, TraceMediaUncheckedUpdateWithoutProjectInput>
    create: XOR<TraceMediaCreateWithoutProjectInput, TraceMediaUncheckedCreateWithoutProjectInput>
  }

  export type TraceMediaUpdateWithWhereUniqueWithoutProjectInput = {
    where: TraceMediaWhereUniqueInput
    data: XOR<TraceMediaUpdateWithoutProjectInput, TraceMediaUncheckedUpdateWithoutProjectInput>
  }

  export type TraceMediaUpdateManyWithWhereWithoutProjectInput = {
    where: TraceMediaScalarWhereInput
    data: XOR<TraceMediaUpdateManyMutationInput, TraceMediaUncheckedUpdateManyWithoutProjectInput>
  }

  export type TraceMediaScalarWhereInput = {
    AND?: TraceMediaScalarWhereInput | TraceMediaScalarWhereInput[]
    OR?: TraceMediaScalarWhereInput[]
    NOT?: TraceMediaScalarWhereInput | TraceMediaScalarWhereInput[]
    id?: StringFilter<"TraceMedia"> | string
    projectId?: StringFilter<"TraceMedia"> | string
    createdAt?: DateTimeFilter<"TraceMedia"> | Date | string
    updatedAt?: DateTimeFilter<"TraceMedia"> | Date | string
    mediaId?: StringFilter<"TraceMedia"> | string
    traceId?: StringFilter<"TraceMedia"> | string
    field?: StringFilter<"TraceMedia"> | string
  }

  export type MediaUpsertWithWhereUniqueWithoutProjectInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutProjectInput, MediaUncheckedUpdateWithoutProjectInput>
    create: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutProjectInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutProjectInput, MediaUncheckedUpdateWithoutProjectInput>
  }

  export type MediaUpdateManyWithWhereWithoutProjectInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutProjectInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    sha256Hash?: StringFilter<"Media"> | string
    projectId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    uploadedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    uploadHttpStatus?: IntNullableFilter<"Media"> | number | null
    uploadHttpError?: StringNullableFilter<"Media"> | string | null
    bucketPath?: StringFilter<"Media"> | string
    bucketName?: StringFilter<"Media"> | string
    contentType?: StringFilter<"Media"> | string
    contentLength?: BigIntFilter<"Media"> | bigint | number
  }

  export type ObservationMediaUpsertWithWhereUniqueWithoutProjectInput = {
    where: ObservationMediaWhereUniqueInput
    update: XOR<ObservationMediaUpdateWithoutProjectInput, ObservationMediaUncheckedUpdateWithoutProjectInput>
    create: XOR<ObservationMediaCreateWithoutProjectInput, ObservationMediaUncheckedCreateWithoutProjectInput>
  }

  export type ObservationMediaUpdateWithWhereUniqueWithoutProjectInput = {
    where: ObservationMediaWhereUniqueInput
    data: XOR<ObservationMediaUpdateWithoutProjectInput, ObservationMediaUncheckedUpdateWithoutProjectInput>
  }

  export type ObservationMediaUpdateManyWithWhereWithoutProjectInput = {
    where: ObservationMediaScalarWhereInput
    data: XOR<ObservationMediaUpdateManyMutationInput, ObservationMediaUncheckedUpdateManyWithoutProjectInput>
  }

  export type ObservationMediaScalarWhereInput = {
    AND?: ObservationMediaScalarWhereInput | ObservationMediaScalarWhereInput[]
    OR?: ObservationMediaScalarWhereInput[]
    NOT?: ObservationMediaScalarWhereInput | ObservationMediaScalarWhereInput[]
    id?: StringFilter<"ObservationMedia"> | string
    projectId?: StringFilter<"ObservationMedia"> | string
    createdAt?: DateTimeFilter<"ObservationMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ObservationMedia"> | Date | string
    mediaId?: StringFilter<"ObservationMedia"> | string
    traceId?: StringFilter<"ObservationMedia"> | string
    observationId?: StringFilter<"ObservationMedia"> | string
    field?: StringFilter<"ObservationMedia"> | string
  }

  export type ProjectCreateWithoutApiKeysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiKeysInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiKeysInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
  }

  export type ProjectUpsertWithoutApiKeysInput = {
    update: XOR<ProjectUpdateWithoutApiKeysInput, ProjectUncheckedUpdateWithoutApiKeysInput>
    create: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiKeysInput, ProjectUncheckedUpdateWithoutApiKeysInput>
  }

  export type ProjectUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutLlmApiKeysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLlmApiKeysInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLlmApiKeysInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLlmApiKeysInput, ProjectUncheckedCreateWithoutLlmApiKeysInput>
  }

  export type ProjectUpsertWithoutLlmApiKeysInput = {
    update: XOR<ProjectUpdateWithoutLlmApiKeysInput, ProjectUncheckedUpdateWithoutLlmApiKeysInput>
    create: XOR<ProjectCreateWithoutLlmApiKeysInput, ProjectUncheckedCreateWithoutLlmApiKeysInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLlmApiKeysInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLlmApiKeysInput, ProjectUncheckedUpdateWithoutLlmApiKeysInput>
  }

  export type ProjectUpdateWithoutLlmApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLlmApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutOrganizationMembershipsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    MembershipInvitation?: MembershipInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationMembershipsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    MembershipInvitation?: MembershipInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationMembershipsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationMembershipsInput, OrganizationUncheckedCreateWithoutOrganizationMembershipsInput>
  }

  export type UserCreateWithoutOrganizationMembershipsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationMembershipsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
  }

  export type ProjectMembershipCreateWithoutOrganizationMembershipInput = {
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput = {
    projectId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipCreateOrConnectWithoutOrganizationMembershipInput = {
    where: ProjectMembershipWhereUniqueInput
    create: XOR<ProjectMembershipCreateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput>
  }

  export type ProjectMembershipCreateManyOrganizationMembershipInputEnvelope = {
    data: ProjectMembershipCreateManyOrganizationMembershipInput | ProjectMembershipCreateManyOrganizationMembershipInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutOrganizationMembershipsInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationMembershipsInput, OrganizationUncheckedUpdateWithoutOrganizationMembershipsInput>
    create: XOR<OrganizationCreateWithoutOrganizationMembershipsInput, OrganizationUncheckedCreateWithoutOrganizationMembershipsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrganizationMembershipsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrganizationMembershipsInput, OrganizationUncheckedUpdateWithoutOrganizationMembershipsInput>
  }

  export type OrganizationUpdateWithoutOrganizationMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    MembershipInvitation?: MembershipInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    MembershipInvitation?: MembershipInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrganizationMembershipsInput = {
    update: XOR<UserUpdateWithoutOrganizationMembershipsInput, UserUncheckedUpdateWithoutOrganizationMembershipsInput>
    create: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationMembershipsInput, UserUncheckedUpdateWithoutOrganizationMembershipsInput>
  }

  export type UserUpdateWithoutOrganizationMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type ProjectMembershipUpsertWithWhereUniqueWithoutOrganizationMembershipInput = {
    where: ProjectMembershipWhereUniqueInput
    update: XOR<ProjectMembershipUpdateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedUpdateWithoutOrganizationMembershipInput>
    create: XOR<ProjectMembershipCreateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedCreateWithoutOrganizationMembershipInput>
  }

  export type ProjectMembershipUpdateWithWhereUniqueWithoutOrganizationMembershipInput = {
    where: ProjectMembershipWhereUniqueInput
    data: XOR<ProjectMembershipUpdateWithoutOrganizationMembershipInput, ProjectMembershipUncheckedUpdateWithoutOrganizationMembershipInput>
  }

  export type ProjectMembershipUpdateManyWithWhereWithoutOrganizationMembershipInput = {
    where: ProjectMembershipScalarWhereInput
    data: XOR<ProjectMembershipUpdateManyMutationInput, ProjectMembershipUncheckedUpdateManyWithoutOrganizationMembershipInput>
  }

  export type OrganizationMembershipCreateWithoutProjectMembershipsInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutOrganizationMembershipsInput
    user: UserCreateNestedOneWithoutOrganizationMembershipsInput
  }

  export type OrganizationMembershipUncheckedCreateWithoutProjectMembershipsInput = {
    id?: string
    orgId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMembershipCreateOrConnectWithoutProjectMembershipsInput = {
    where: OrganizationMembershipWhereUniqueInput
    create: XOR<OrganizationMembershipCreateWithoutProjectMembershipsInput, OrganizationMembershipUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type ProjectCreateWithoutProjectMembersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectMembersInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
  }

  export type UserCreateWithoutProjectMembershipsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateWithoutProjectMembershipsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserCreateOrConnectWithoutProjectMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type OrganizationMembershipUpsertWithoutProjectMembershipsInput = {
    update: XOR<OrganizationMembershipUpdateWithoutProjectMembershipsInput, OrganizationMembershipUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<OrganizationMembershipCreateWithoutProjectMembershipsInput, OrganizationMembershipUncheckedCreateWithoutProjectMembershipsInput>
    where?: OrganizationMembershipWhereInput
  }

  export type OrganizationMembershipUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: OrganizationMembershipWhereInput
    data: XOR<OrganizationMembershipUpdateWithoutProjectMembershipsInput, OrganizationMembershipUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type OrganizationMembershipUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithoutProjectMembersInput = {
    update: XOR<ProjectUpdateWithoutProjectMembersInput, ProjectUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectMembersInput, ProjectUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembershipsInput = {
    update: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type UserUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type OrganizationCreateWithoutMembershipInvitationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembershipInvitationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembershipInvitationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembershipInvitationInput, OrganizationUncheckedCreateWithoutMembershipInvitationInput>
  }

  export type ProjectCreateWithoutInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInvitationsInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInvitationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutMembershipInvitationInput = {
    update: XOR<OrganizationUpdateWithoutMembershipInvitationInput, OrganizationUncheckedUpdateWithoutMembershipInvitationInput>
    create: XOR<OrganizationCreateWithoutMembershipInvitationInput, OrganizationUncheckedCreateWithoutMembershipInvitationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembershipInvitationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembershipInvitationInput, OrganizationUncheckedUpdateWithoutMembershipInvitationInput>
  }

  export type OrganizationUpdateWithoutMembershipInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembershipInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudConfig?: NullableJsonNullValueInput | InputJsonValue
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithoutInvitationsInput = {
    update: XOR<ProjectUpdateWithoutInvitationsInput, ProjectUncheckedUpdateWithoutInvitationsInput>
    create: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInvitationsInput, ProjectUncheckedUpdateWithoutInvitationsInput>
  }

  export type ProjectUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type ProjectCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSessionsInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSessionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
  }

  export type TraceCreateWithoutSessionInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTracesInput
  }

  export type TraceUncheckedCreateWithoutSessionInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceCreateOrConnectWithoutSessionInput = {
    where: TraceWhereUniqueInput
    create: XOR<TraceCreateWithoutSessionInput, TraceUncheckedCreateWithoutSessionInput>
  }

  export type TraceCreateManySessionInputEnvelope = {
    data: TraceCreateManySessionInput | TraceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSessionsInput = {
    update: XOR<ProjectUpdateWithoutSessionsInput, ProjectUncheckedUpdateWithoutSessionsInput>
    create: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSessionsInput, ProjectUncheckedUpdateWithoutSessionsInput>
  }

  export type ProjectUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TraceUpsertWithWhereUniqueWithoutSessionInput = {
    where: TraceWhereUniqueInput
    update: XOR<TraceUpdateWithoutSessionInput, TraceUncheckedUpdateWithoutSessionInput>
    create: XOR<TraceCreateWithoutSessionInput, TraceUncheckedCreateWithoutSessionInput>
  }

  export type TraceUpdateWithWhereUniqueWithoutSessionInput = {
    where: TraceWhereUniqueInput
    data: XOR<TraceUpdateWithoutSessionInput, TraceUncheckedUpdateWithoutSessionInput>
  }

  export type TraceUpdateManyWithWhereWithoutSessionInput = {
    where: TraceScalarWhereInput
    data: XOR<TraceUpdateManyMutationInput, TraceUncheckedUpdateManyWithoutSessionInput>
  }

  export type ProjectCreateWithoutTracesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTracesInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTracesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTracesInput, ProjectUncheckedCreateWithoutTracesInput>
  }

  export type TraceSessionCreateWithoutTracesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarked?: boolean
    public?: boolean
    project: ProjectCreateNestedOneWithoutSessionsInput
  }

  export type TraceSessionUncheckedCreateWithoutTracesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    bookmarked?: boolean
    public?: boolean
  }

  export type TraceSessionCreateOrConnectWithoutTracesInput = {
    where: TraceSessionWhereUniqueInput
    create: XOR<TraceSessionCreateWithoutTracesInput, TraceSessionUncheckedCreateWithoutTracesInput>
  }

  export type ProjectUpsertWithoutTracesInput = {
    update: XOR<ProjectUpdateWithoutTracesInput, ProjectUncheckedUpdateWithoutTracesInput>
    create: XOR<ProjectCreateWithoutTracesInput, ProjectUncheckedCreateWithoutTracesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTracesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTracesInput, ProjectUncheckedUpdateWithoutTracesInput>
  }

  export type ProjectUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TraceSessionUpsertWithoutTracesInput = {
    update: XOR<TraceSessionUpdateWithoutTracesInput, TraceSessionUncheckedUpdateWithoutTracesInput>
    create: XOR<TraceSessionCreateWithoutTracesInput, TraceSessionUncheckedCreateWithoutTracesInput>
    where?: TraceSessionWhereInput
  }

  export type TraceSessionUpdateToOneWithWhereWithoutTracesInput = {
    where?: TraceSessionWhereInput
    data: XOR<TraceSessionUpdateWithoutTracesInput, TraceSessionUncheckedUpdateWithoutTracesInput>
  }

  export type TraceSessionUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type TraceSessionUncheckedUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectCreateWithoutObservationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutObservationsInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutObservationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutObservationsInput, ProjectUncheckedCreateWithoutObservationsInput>
  }

  export type ProjectUpsertWithoutObservationsInput = {
    update: XOR<ProjectUpdateWithoutObservationsInput, ProjectUncheckedUpdateWithoutObservationsInput>
    create: XOR<ProjectCreateWithoutObservationsInput, ProjectUncheckedCreateWithoutObservationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutObservationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutObservationsInput, ProjectUncheckedUpdateWithoutObservationsInput>
  }

  export type ProjectUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutScoreInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutScoreInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutScoreInput, ProjectUncheckedCreateWithoutScoreInput>
  }

  export type ScoreConfigCreateWithoutScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    project: ProjectCreateNestedOneWithoutScoreConfigInput
  }

  export type ScoreConfigUncheckedCreateWithoutScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
  }

  export type ScoreConfigCreateOrConnectWithoutScoreInput = {
    where: ScoreConfigWhereUniqueInput
    create: XOR<ScoreConfigCreateWithoutScoreInput, ScoreConfigUncheckedCreateWithoutScoreInput>
  }

  export type ProjectUpsertWithoutScoreInput = {
    update: XOR<ProjectUpdateWithoutScoreInput, ProjectUncheckedUpdateWithoutScoreInput>
    create: XOR<ProjectCreateWithoutScoreInput, ProjectUncheckedCreateWithoutScoreInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutScoreInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutScoreInput, ProjectUncheckedUpdateWithoutScoreInput>
  }

  export type ProjectUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ScoreConfigUpsertWithoutScoreInput = {
    update: XOR<ScoreConfigUpdateWithoutScoreInput, ScoreConfigUncheckedUpdateWithoutScoreInput>
    create: XOR<ScoreConfigCreateWithoutScoreInput, ScoreConfigUncheckedCreateWithoutScoreInput>
    where?: ScoreConfigWhereInput
  }

  export type ScoreConfigUpdateToOneWithWhereWithoutScoreInput = {
    where?: ScoreConfigWhereInput
    data: XOR<ScoreConfigUpdateWithoutScoreInput, ScoreConfigUncheckedUpdateWithoutScoreInput>
  }

  export type ScoreConfigUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutScoreConfigNestedInput
  }

  export type ScoreConfigUncheckedUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateWithoutScoreConfigInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutScoreConfigInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutScoreConfigInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutScoreConfigInput, ProjectUncheckedCreateWithoutScoreConfigInput>
  }

  export type ScoreCreateWithoutScoreConfigInput = {
    id?: string
    timestamp?: Date | string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
    project: ProjectCreateNestedOneWithoutScoreInput
  }

  export type ScoreUncheckedCreateWithoutScoreConfigInput = {
    id?: string
    timestamp?: Date | string
    projectId: string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
  }

  export type ScoreCreateOrConnectWithoutScoreConfigInput = {
    where: ScoreWhereUniqueInput
    create: XOR<ScoreCreateWithoutScoreConfigInput, ScoreUncheckedCreateWithoutScoreConfigInput>
  }

  export type ScoreCreateManyScoreConfigInputEnvelope = {
    data: ScoreCreateManyScoreConfigInput | ScoreCreateManyScoreConfigInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutScoreConfigInput = {
    update: XOR<ProjectUpdateWithoutScoreConfigInput, ProjectUncheckedUpdateWithoutScoreConfigInput>
    create: XOR<ProjectCreateWithoutScoreConfigInput, ProjectUncheckedCreateWithoutScoreConfigInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutScoreConfigInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutScoreConfigInput, ProjectUncheckedUpdateWithoutScoreConfigInput>
  }

  export type ProjectUpdateWithoutScoreConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutScoreConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ScoreUpsertWithWhereUniqueWithoutScoreConfigInput = {
    where: ScoreWhereUniqueInput
    update: XOR<ScoreUpdateWithoutScoreConfigInput, ScoreUncheckedUpdateWithoutScoreConfigInput>
    create: XOR<ScoreCreateWithoutScoreConfigInput, ScoreUncheckedCreateWithoutScoreConfigInput>
  }

  export type ScoreUpdateWithWhereUniqueWithoutScoreConfigInput = {
    where: ScoreWhereUniqueInput
    data: XOR<ScoreUpdateWithoutScoreConfigInput, ScoreUncheckedUpdateWithoutScoreConfigInput>
  }

  export type ScoreUpdateManyWithWhereWithoutScoreConfigInput = {
    where: ScoreScalarWhereInput
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutScoreConfigInput>
  }

  export type ProjectCreateWithoutAnnotationQueueInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAnnotationQueueInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAnnotationQueueInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAnnotationQueueInput, ProjectUncheckedCreateWithoutAnnotationQueueInput>
  }

  export type AnnotationQueueItemCreateWithoutQueueInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lockedByUser?: UserCreateNestedOneWithoutAnnotatedLockedItemInput
    annotatorUser?: UserCreateNestedOneWithoutAnnotatedCompletedItemInput
    project: ProjectCreateNestedOneWithoutAnnotationQueueItemInput
  }

  export type AnnotationQueueItemUncheckedCreateWithoutQueueInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateOrConnectWithoutQueueInput = {
    where: AnnotationQueueItemWhereUniqueInput
    create: XOR<AnnotationQueueItemCreateWithoutQueueInput, AnnotationQueueItemUncheckedCreateWithoutQueueInput>
  }

  export type AnnotationQueueItemCreateManyQueueInputEnvelope = {
    data: AnnotationQueueItemCreateManyQueueInput | AnnotationQueueItemCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutAnnotationQueueInput = {
    update: XOR<ProjectUpdateWithoutAnnotationQueueInput, ProjectUncheckedUpdateWithoutAnnotationQueueInput>
    create: XOR<ProjectCreateWithoutAnnotationQueueInput, ProjectUncheckedCreateWithoutAnnotationQueueInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAnnotationQueueInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAnnotationQueueInput, ProjectUncheckedUpdateWithoutAnnotationQueueInput>
  }

  export type ProjectUpdateWithoutAnnotationQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAnnotationQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AnnotationQueueItemUpsertWithWhereUniqueWithoutQueueInput = {
    where: AnnotationQueueItemWhereUniqueInput
    update: XOR<AnnotationQueueItemUpdateWithoutQueueInput, AnnotationQueueItemUncheckedUpdateWithoutQueueInput>
    create: XOR<AnnotationQueueItemCreateWithoutQueueInput, AnnotationQueueItemUncheckedCreateWithoutQueueInput>
  }

  export type AnnotationQueueItemUpdateWithWhereUniqueWithoutQueueInput = {
    where: AnnotationQueueItemWhereUniqueInput
    data: XOR<AnnotationQueueItemUpdateWithoutQueueInput, AnnotationQueueItemUncheckedUpdateWithoutQueueInput>
  }

  export type AnnotationQueueItemUpdateManyWithWhereWithoutQueueInput = {
    where: AnnotationQueueItemScalarWhereInput
    data: XOR<AnnotationQueueItemUpdateManyMutationInput, AnnotationQueueItemUncheckedUpdateManyWithoutQueueInput>
  }

  export type AnnotationQueueCreateWithoutAnnotationQueueItemInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAnnotationQueueInput
  }

  export type AnnotationQueueUncheckedCreateWithoutAnnotationQueueItemInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueCreateOrConnectWithoutAnnotationQueueItemInput = {
    where: AnnotationQueueWhereUniqueInput
    create: XOR<AnnotationQueueCreateWithoutAnnotationQueueItemInput, AnnotationQueueUncheckedCreateWithoutAnnotationQueueItemInput>
  }

  export type UserCreateWithoutAnnotatedLockedItemInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserUncheckedCreateWithoutAnnotatedLockedItemInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutAnnotatorUserInput
  }

  export type UserCreateOrConnectWithoutAnnotatedLockedItemInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotatedLockedItemInput, UserUncheckedCreateWithoutAnnotatedLockedItemInput>
  }

  export type UserCreateWithoutAnnotatedCompletedItemInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemCreateNestedManyWithoutLockedByUserInput
  }

  export type UserUncheckedCreateWithoutAnnotatedCompletedItemInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    admin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    featureFlags?: UserCreatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMembershipUncheckedCreateNestedManyWithoutUserInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutLockedByUserInput
  }

  export type UserCreateOrConnectWithoutAnnotatedCompletedItemInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotatedCompletedItemInput, UserUncheckedCreateWithoutAnnotatedCompletedItemInput>
  }

  export type ProjectCreateWithoutAnnotationQueueItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAnnotationQueueItemInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAnnotationQueueItemInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAnnotationQueueItemInput, ProjectUncheckedCreateWithoutAnnotationQueueItemInput>
  }

  export type AnnotationQueueUpsertWithoutAnnotationQueueItemInput = {
    update: XOR<AnnotationQueueUpdateWithoutAnnotationQueueItemInput, AnnotationQueueUncheckedUpdateWithoutAnnotationQueueItemInput>
    create: XOR<AnnotationQueueCreateWithoutAnnotationQueueItemInput, AnnotationQueueUncheckedCreateWithoutAnnotationQueueItemInput>
    where?: AnnotationQueueWhereInput
  }

  export type AnnotationQueueUpdateToOneWithWhereWithoutAnnotationQueueItemInput = {
    where?: AnnotationQueueWhereInput
    data: XOR<AnnotationQueueUpdateWithoutAnnotationQueueItemInput, AnnotationQueueUncheckedUpdateWithoutAnnotationQueueItemInput>
  }

  export type AnnotationQueueUpdateWithoutAnnotationQueueItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAnnotationQueueNestedInput
  }

  export type AnnotationQueueUncheckedUpdateWithoutAnnotationQueueItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAnnotatedLockedItemInput = {
    update: XOR<UserUpdateWithoutAnnotatedLockedItemInput, UserUncheckedUpdateWithoutAnnotatedLockedItemInput>
    create: XOR<UserCreateWithoutAnnotatedLockedItemInput, UserUncheckedCreateWithoutAnnotatedLockedItemInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnotatedLockedItemInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnotatedLockedItemInput, UserUncheckedUpdateWithoutAnnotatedLockedItemInput>
  }

  export type UserUpdateWithoutAnnotatedLockedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotatedLockedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedCompletedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserNestedInput
  }

  export type UserUpsertWithoutAnnotatedCompletedItemInput = {
    update: XOR<UserUpdateWithoutAnnotatedCompletedItemInput, UserUncheckedUpdateWithoutAnnotatedCompletedItemInput>
    create: XOR<UserCreateWithoutAnnotatedCompletedItemInput, UserUncheckedCreateWithoutAnnotatedCompletedItemInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnotatedCompletedItemInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnotatedCompletedItemInput, UserUncheckedUpdateWithoutAnnotatedCompletedItemInput>
  }

  export type UserUpdateWithoutAnnotatedCompletedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUpdateManyWithoutLockedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotatedCompletedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlags?: UserUpdatefeatureFlagsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    annotatedLockedItem?: AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserNestedInput
  }

  export type ProjectUpsertWithoutAnnotationQueueItemInput = {
    update: XOR<ProjectUpdateWithoutAnnotationQueueItemInput, ProjectUncheckedUpdateWithoutAnnotationQueueItemInput>
    create: XOR<ProjectCreateWithoutAnnotationQueueItemInput, ProjectUncheckedCreateWithoutAnnotationQueueItemInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAnnotationQueueItemInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAnnotationQueueItemInput, ProjectUncheckedUpdateWithoutAnnotationQueueItemInput>
  }

  export type ProjectUpdateWithoutAnnotationQueueItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAnnotationQueueItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutDatasetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDatasetInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDatasetInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDatasetInput, ProjectUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetItemCreateWithoutDatasetInput = {
    id?: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRunItems?: DatasetRunItemsCreateNestedManyWithoutDatasetItemInput
  }

  export type DatasetItemUncheckedCreateWithoutDatasetInput = {
    id?: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRunItems?: DatasetRunItemsUncheckedCreateNestedManyWithoutDatasetItemInput
  }

  export type DatasetItemCreateOrConnectWithoutDatasetInput = {
    where: DatasetItemWhereUniqueInput
    create: XOR<DatasetItemCreateWithoutDatasetInput, DatasetItemUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetItemCreateManyDatasetInputEnvelope = {
    data: DatasetItemCreateManyDatasetInput | DatasetItemCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type DatasetRunsCreateWithoutDatasetInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRunItems?: DatasetRunItemsCreateNestedManyWithoutDatasetRunInput
  }

  export type DatasetRunsUncheckedCreateWithoutDatasetInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRunItems?: DatasetRunItemsUncheckedCreateNestedManyWithoutDatasetRunInput
  }

  export type DatasetRunsCreateOrConnectWithoutDatasetInput = {
    where: DatasetRunsWhereUniqueInput
    create: XOR<DatasetRunsCreateWithoutDatasetInput, DatasetRunsUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetRunsCreateManyDatasetInputEnvelope = {
    data: DatasetRunsCreateManyDatasetInput | DatasetRunsCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDatasetInput = {
    update: XOR<ProjectUpdateWithoutDatasetInput, ProjectUncheckedUpdateWithoutDatasetInput>
    create: XOR<ProjectCreateWithoutDatasetInput, ProjectUncheckedCreateWithoutDatasetInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDatasetInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDatasetInput, ProjectUncheckedUpdateWithoutDatasetInput>
  }

  export type ProjectUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DatasetItemUpsertWithWhereUniqueWithoutDatasetInput = {
    where: DatasetItemWhereUniqueInput
    update: XOR<DatasetItemUpdateWithoutDatasetInput, DatasetItemUncheckedUpdateWithoutDatasetInput>
    create: XOR<DatasetItemCreateWithoutDatasetInput, DatasetItemUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetItemUpdateWithWhereUniqueWithoutDatasetInput = {
    where: DatasetItemWhereUniqueInput
    data: XOR<DatasetItemUpdateWithoutDatasetInput, DatasetItemUncheckedUpdateWithoutDatasetInput>
  }

  export type DatasetItemUpdateManyWithWhereWithoutDatasetInput = {
    where: DatasetItemScalarWhereInput
    data: XOR<DatasetItemUpdateManyMutationInput, DatasetItemUncheckedUpdateManyWithoutDatasetInput>
  }

  export type DatasetItemScalarWhereInput = {
    AND?: DatasetItemScalarWhereInput | DatasetItemScalarWhereInput[]
    OR?: DatasetItemScalarWhereInput[]
    NOT?: DatasetItemScalarWhereInput | DatasetItemScalarWhereInput[]
    id?: StringFilter<"DatasetItem"> | string
    projectId?: StringFilter<"DatasetItem"> | string
    status?: EnumDatasetStatusFilter<"DatasetItem"> | $Enums.DatasetStatus
    input?: JsonNullableFilter<"DatasetItem">
    expectedOutput?: JsonNullableFilter<"DatasetItem">
    metadata?: JsonNullableFilter<"DatasetItem">
    sourceTraceId?: StringNullableFilter<"DatasetItem"> | string | null
    sourceObservationId?: StringNullableFilter<"DatasetItem"> | string | null
    datasetId?: StringFilter<"DatasetItem"> | string
    createdAt?: DateTimeFilter<"DatasetItem"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetItem"> | Date | string
  }

  export type DatasetRunsUpsertWithWhereUniqueWithoutDatasetInput = {
    where: DatasetRunsWhereUniqueInput
    update: XOR<DatasetRunsUpdateWithoutDatasetInput, DatasetRunsUncheckedUpdateWithoutDatasetInput>
    create: XOR<DatasetRunsCreateWithoutDatasetInput, DatasetRunsUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetRunsUpdateWithWhereUniqueWithoutDatasetInput = {
    where: DatasetRunsWhereUniqueInput
    data: XOR<DatasetRunsUpdateWithoutDatasetInput, DatasetRunsUncheckedUpdateWithoutDatasetInput>
  }

  export type DatasetRunsUpdateManyWithWhereWithoutDatasetInput = {
    where: DatasetRunsScalarWhereInput
    data: XOR<DatasetRunsUpdateManyMutationInput, DatasetRunsUncheckedUpdateManyWithoutDatasetInput>
  }

  export type DatasetRunsScalarWhereInput = {
    AND?: DatasetRunsScalarWhereInput | DatasetRunsScalarWhereInput[]
    OR?: DatasetRunsScalarWhereInput[]
    NOT?: DatasetRunsScalarWhereInput | DatasetRunsScalarWhereInput[]
    id?: StringFilter<"DatasetRuns"> | string
    projectId?: StringFilter<"DatasetRuns"> | string
    name?: StringFilter<"DatasetRuns"> | string
    description?: StringNullableFilter<"DatasetRuns"> | string | null
    metadata?: JsonNullableFilter<"DatasetRuns">
    datasetId?: StringFilter<"DatasetRuns"> | string
    createdAt?: DateTimeFilter<"DatasetRuns"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetRuns"> | Date | string
  }

  export type DatasetCreateWithoutDatasetItemsInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDatasetInput
    datasetRuns?: DatasetRunsCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateWithoutDatasetItemsInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRuns?: DatasetRunsUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetCreateOrConnectWithoutDatasetItemsInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutDatasetItemsInput, DatasetUncheckedCreateWithoutDatasetItemsInput>
  }

  export type DatasetRunItemsCreateWithoutDatasetItemInput = {
    id?: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetRun: DatasetRunsCreateNestedOneWithoutDatasetRunItemsInput
  }

  export type DatasetRunItemsUncheckedCreateWithoutDatasetItemInput = {
    id?: string
    datasetRunId: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunItemsCreateOrConnectWithoutDatasetItemInput = {
    where: DatasetRunItemsWhereUniqueInput
    create: XOR<DatasetRunItemsCreateWithoutDatasetItemInput, DatasetRunItemsUncheckedCreateWithoutDatasetItemInput>
  }

  export type DatasetRunItemsCreateManyDatasetItemInputEnvelope = {
    data: DatasetRunItemsCreateManyDatasetItemInput | DatasetRunItemsCreateManyDatasetItemInput[]
    skipDuplicates?: boolean
  }

  export type DatasetUpsertWithoutDatasetItemsInput = {
    update: XOR<DatasetUpdateWithoutDatasetItemsInput, DatasetUncheckedUpdateWithoutDatasetItemsInput>
    create: XOR<DatasetCreateWithoutDatasetItemsInput, DatasetUncheckedCreateWithoutDatasetItemsInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutDatasetItemsInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutDatasetItemsInput, DatasetUncheckedUpdateWithoutDatasetItemsInput>
  }

  export type DatasetUpdateWithoutDatasetItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDatasetNestedInput
    datasetRuns?: DatasetRunsUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateWithoutDatasetItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRuns?: DatasetRunsUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetItemInput = {
    where: DatasetRunItemsWhereUniqueInput
    update: XOR<DatasetRunItemsUpdateWithoutDatasetItemInput, DatasetRunItemsUncheckedUpdateWithoutDatasetItemInput>
    create: XOR<DatasetRunItemsCreateWithoutDatasetItemInput, DatasetRunItemsUncheckedCreateWithoutDatasetItemInput>
  }

  export type DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetItemInput = {
    where: DatasetRunItemsWhereUniqueInput
    data: XOR<DatasetRunItemsUpdateWithoutDatasetItemInput, DatasetRunItemsUncheckedUpdateWithoutDatasetItemInput>
  }

  export type DatasetRunItemsUpdateManyWithWhereWithoutDatasetItemInput = {
    where: DatasetRunItemsScalarWhereInput
    data: XOR<DatasetRunItemsUpdateManyMutationInput, DatasetRunItemsUncheckedUpdateManyWithoutDatasetItemInput>
  }

  export type DatasetRunItemsScalarWhereInput = {
    AND?: DatasetRunItemsScalarWhereInput | DatasetRunItemsScalarWhereInput[]
    OR?: DatasetRunItemsScalarWhereInput[]
    NOT?: DatasetRunItemsScalarWhereInput | DatasetRunItemsScalarWhereInput[]
    id?: StringFilter<"DatasetRunItems"> | string
    projectId?: StringFilter<"DatasetRunItems"> | string
    datasetRunId?: StringFilter<"DatasetRunItems"> | string
    datasetItemId?: StringFilter<"DatasetRunItems"> | string
    traceId?: StringFilter<"DatasetRunItems"> | string
    observationId?: StringNullableFilter<"DatasetRunItems"> | string | null
    createdAt?: DateTimeFilter<"DatasetRunItems"> | Date | string
    updatedAt?: DateTimeFilter<"DatasetRunItems"> | Date | string
  }

  export type DatasetCreateWithoutDatasetRunsInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDatasetInput
    datasetItems?: DatasetItemCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateWithoutDatasetRunsInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetItems?: DatasetItemUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetCreateOrConnectWithoutDatasetRunsInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutDatasetRunsInput, DatasetUncheckedCreateWithoutDatasetRunsInput>
  }

  export type DatasetRunItemsCreateWithoutDatasetRunInput = {
    id?: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    datasetItem: DatasetItemCreateNestedOneWithoutDatasetRunItemsInput
  }

  export type DatasetRunItemsUncheckedCreateWithoutDatasetRunInput = {
    id?: string
    datasetItemId: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunItemsCreateOrConnectWithoutDatasetRunInput = {
    where: DatasetRunItemsWhereUniqueInput
    create: XOR<DatasetRunItemsCreateWithoutDatasetRunInput, DatasetRunItemsUncheckedCreateWithoutDatasetRunInput>
  }

  export type DatasetRunItemsCreateManyDatasetRunInputEnvelope = {
    data: DatasetRunItemsCreateManyDatasetRunInput | DatasetRunItemsCreateManyDatasetRunInput[]
    skipDuplicates?: boolean
  }

  export type DatasetUpsertWithoutDatasetRunsInput = {
    update: XOR<DatasetUpdateWithoutDatasetRunsInput, DatasetUncheckedUpdateWithoutDatasetRunsInput>
    create: XOR<DatasetCreateWithoutDatasetRunsInput, DatasetUncheckedCreateWithoutDatasetRunsInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutDatasetRunsInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutDatasetRunsInput, DatasetUncheckedUpdateWithoutDatasetRunsInput>
  }

  export type DatasetUpdateWithoutDatasetRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDatasetNestedInput
    datasetItems?: DatasetItemUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateWithoutDatasetRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetItems?: DatasetItemUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetRunItemsUpsertWithWhereUniqueWithoutDatasetRunInput = {
    where: DatasetRunItemsWhereUniqueInput
    update: XOR<DatasetRunItemsUpdateWithoutDatasetRunInput, DatasetRunItemsUncheckedUpdateWithoutDatasetRunInput>
    create: XOR<DatasetRunItemsCreateWithoutDatasetRunInput, DatasetRunItemsUncheckedCreateWithoutDatasetRunInput>
  }

  export type DatasetRunItemsUpdateWithWhereUniqueWithoutDatasetRunInput = {
    where: DatasetRunItemsWhereUniqueInput
    data: XOR<DatasetRunItemsUpdateWithoutDatasetRunInput, DatasetRunItemsUncheckedUpdateWithoutDatasetRunInput>
  }

  export type DatasetRunItemsUpdateManyWithWhereWithoutDatasetRunInput = {
    where: DatasetRunItemsScalarWhereInput
    data: XOR<DatasetRunItemsUpdateManyMutationInput, DatasetRunItemsUncheckedUpdateManyWithoutDatasetRunInput>
  }

  export type DatasetRunsCreateWithoutDatasetRunItemsInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutDatasetRunsInput
  }

  export type DatasetRunsUncheckedCreateWithoutDatasetRunItemsInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    datasetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunsCreateOrConnectWithoutDatasetRunItemsInput = {
    where: DatasetRunsWhereUniqueInput
    create: XOR<DatasetRunsCreateWithoutDatasetRunItemsInput, DatasetRunsUncheckedCreateWithoutDatasetRunItemsInput>
  }

  export type DatasetItemCreateWithoutDatasetRunItemsInput = {
    id?: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutDatasetItemsInput
  }

  export type DatasetItemUncheckedCreateWithoutDatasetRunItemsInput = {
    id?: string
    projectId: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    datasetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetItemCreateOrConnectWithoutDatasetRunItemsInput = {
    where: DatasetItemWhereUniqueInput
    create: XOR<DatasetItemCreateWithoutDatasetRunItemsInput, DatasetItemUncheckedCreateWithoutDatasetRunItemsInput>
  }

  export type DatasetRunsUpsertWithoutDatasetRunItemsInput = {
    update: XOR<DatasetRunsUpdateWithoutDatasetRunItemsInput, DatasetRunsUncheckedUpdateWithoutDatasetRunItemsInput>
    create: XOR<DatasetRunsCreateWithoutDatasetRunItemsInput, DatasetRunsUncheckedCreateWithoutDatasetRunItemsInput>
    where?: DatasetRunsWhereInput
  }

  export type DatasetRunsUpdateToOneWithWhereWithoutDatasetRunItemsInput = {
    where?: DatasetRunsWhereInput
    data: XOR<DatasetRunsUpdateWithoutDatasetRunItemsInput, DatasetRunsUncheckedUpdateWithoutDatasetRunItemsInput>
  }

  export type DatasetRunsUpdateWithoutDatasetRunItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutDatasetRunsNestedInput
  }

  export type DatasetRunsUncheckedUpdateWithoutDatasetRunItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    datasetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetItemUpsertWithoutDatasetRunItemsInput = {
    update: XOR<DatasetItemUpdateWithoutDatasetRunItemsInput, DatasetItemUncheckedUpdateWithoutDatasetRunItemsInput>
    create: XOR<DatasetItemCreateWithoutDatasetRunItemsInput, DatasetItemUncheckedCreateWithoutDatasetRunItemsInput>
    where?: DatasetItemWhereInput
  }

  export type DatasetItemUpdateToOneWithWhereWithoutDatasetRunItemsInput = {
    where?: DatasetItemWhereInput
    data: XOR<DatasetItemUpdateWithoutDatasetRunItemsInput, DatasetItemUncheckedUpdateWithoutDatasetRunItemsInput>
  }

  export type DatasetItemUpdateWithoutDatasetRunItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutDatasetItemsNestedInput
  }

  export type DatasetItemUncheckedUpdateWithoutDatasetRunItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    datasetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutRawEventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRawEventsInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRawEventsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRawEventsInput, ProjectUncheckedCreateWithoutRawEventsInput>
  }

  export type ProjectUpsertWithoutRawEventsInput = {
    update: XOR<ProjectUpdateWithoutRawEventsInput, ProjectUncheckedUpdateWithoutRawEventsInput>
    create: XOR<ProjectCreateWithoutRawEventsInput, ProjectUncheckedCreateWithoutRawEventsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRawEventsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRawEventsInput, ProjectUncheckedUpdateWithoutRawEventsInput>
  }

  export type ProjectUpdateWithoutRawEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRawEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutCommentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCommentInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCommentInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCommentInput, ProjectUncheckedCreateWithoutCommentInput>
  }

  export type ProjectUpsertWithoutCommentInput = {
    update: XOR<ProjectUpdateWithoutCommentInput, ProjectUncheckedUpdateWithoutCommentInput>
    create: XOR<ProjectCreateWithoutCommentInput, ProjectUncheckedCreateWithoutCommentInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCommentInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCommentInput, ProjectUncheckedUpdateWithoutCommentInput>
  }

  export type ProjectUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPromptInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPromptInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPromptInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPromptInput, ProjectUncheckedCreateWithoutPromptInput>
  }

  export type ProjectUpsertWithoutPromptInput = {
    update: XOR<ProjectUpdateWithoutPromptInput, ProjectUncheckedUpdateWithoutPromptInput>
    create: XOR<ProjectCreateWithoutPromptInput, ProjectUncheckedCreateWithoutPromptInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPromptInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPromptInput, ProjectUncheckedUpdateWithoutPromptInput>
  }

  export type ProjectUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutModelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutModelInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutModelInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutModelInput, ProjectUncheckedCreateWithoutModelInput>
  }

  export type PriceCreateWithoutModelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usageType: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type PriceUncheckedCreateWithoutModelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usageType: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type PriceCreateOrConnectWithoutModelInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutModelInput, PriceUncheckedCreateWithoutModelInput>
  }

  export type PriceCreateManyModelInputEnvelope = {
    data: PriceCreateManyModelInput | PriceCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutModelInput = {
    update: XOR<ProjectUpdateWithoutModelInput, ProjectUncheckedUpdateWithoutModelInput>
    create: XOR<ProjectCreateWithoutModelInput, ProjectUncheckedCreateWithoutModelInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutModelInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutModelInput, ProjectUncheckedUpdateWithoutModelInput>
  }

  export type ProjectUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PriceUpsertWithWhereUniqueWithoutModelInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutModelInput, PriceUncheckedUpdateWithoutModelInput>
    create: XOR<PriceCreateWithoutModelInput, PriceUncheckedCreateWithoutModelInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutModelInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutModelInput, PriceUncheckedUpdateWithoutModelInput>
  }

  export type PriceUpdateManyWithWhereWithoutModelInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutModelInput>
  }

  export type PriceScalarWhereInput = {
    AND?: PriceScalarWhereInput | PriceScalarWhereInput[]
    OR?: PriceScalarWhereInput[]
    NOT?: PriceScalarWhereInput | PriceScalarWhereInput[]
    id?: StringFilter<"Price"> | string
    createdAt?: DateTimeFilter<"Price"> | Date | string
    updatedAt?: DateTimeFilter<"Price"> | Date | string
    modelId?: StringFilter<"Price"> | string
    usageType?: StringFilter<"Price"> | string
    price?: DecimalFilter<"Price"> | Decimal | DecimalJsLike | number | string
  }

  export type ModelCreateWithoutPriceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectCreateNestedOneWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutPriceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ModelCreateOrConnectWithoutPriceInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutPriceInput, ModelUncheckedCreateWithoutPriceInput>
  }

  export type ModelUpsertWithoutPriceInput = {
    update: XOR<ModelUpdateWithoutPriceInput, ModelUncheckedUpdateWithoutPriceInput>
    create: XOR<ModelCreateWithoutPriceInput, ModelUncheckedCreateWithoutPriceInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutPriceInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutPriceInput, ModelUncheckedUpdateWithoutPriceInput>
  }

  export type ModelUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateWithoutEvalTemplateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEvalTemplateInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEvalTemplateInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEvalTemplateInput, ProjectUncheckedCreateWithoutEvalTemplateInput>
  }

  export type JobConfigurationCreateWithoutEvalTemplateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    project: ProjectCreateNestedOneWithoutJobConfigurationInput
    JobExecution?: JobExecutionCreateNestedManyWithoutJobConfigurationInput
  }

  export type JobConfigurationUncheckedCreateWithoutEvalTemplateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutJobConfigurationInput
  }

  export type JobConfigurationCreateOrConnectWithoutEvalTemplateInput = {
    where: JobConfigurationWhereUniqueInput
    create: XOR<JobConfigurationCreateWithoutEvalTemplateInput, JobConfigurationUncheckedCreateWithoutEvalTemplateInput>
  }

  export type JobConfigurationCreateManyEvalTemplateInputEnvelope = {
    data: JobConfigurationCreateManyEvalTemplateInput | JobConfigurationCreateManyEvalTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutEvalTemplateInput = {
    update: XOR<ProjectUpdateWithoutEvalTemplateInput, ProjectUncheckedUpdateWithoutEvalTemplateInput>
    create: XOR<ProjectCreateWithoutEvalTemplateInput, ProjectUncheckedCreateWithoutEvalTemplateInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEvalTemplateInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEvalTemplateInput, ProjectUncheckedUpdateWithoutEvalTemplateInput>
  }

  export type ProjectUpdateWithoutEvalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEvalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type JobConfigurationUpsertWithWhereUniqueWithoutEvalTemplateInput = {
    where: JobConfigurationWhereUniqueInput
    update: XOR<JobConfigurationUpdateWithoutEvalTemplateInput, JobConfigurationUncheckedUpdateWithoutEvalTemplateInput>
    create: XOR<JobConfigurationCreateWithoutEvalTemplateInput, JobConfigurationUncheckedCreateWithoutEvalTemplateInput>
  }

  export type JobConfigurationUpdateWithWhereUniqueWithoutEvalTemplateInput = {
    where: JobConfigurationWhereUniqueInput
    data: XOR<JobConfigurationUpdateWithoutEvalTemplateInput, JobConfigurationUncheckedUpdateWithoutEvalTemplateInput>
  }

  export type JobConfigurationUpdateManyWithWhereWithoutEvalTemplateInput = {
    where: JobConfigurationScalarWhereInput
    data: XOR<JobConfigurationUpdateManyMutationInput, JobConfigurationUncheckedUpdateManyWithoutEvalTemplateInput>
  }

  export type ProjectCreateWithoutJobConfigurationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutJobConfigurationInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutJobConfigurationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutJobConfigurationInput, ProjectUncheckedCreateWithoutJobConfigurationInput>
  }

  export type EvalTemplateCreateWithoutJobConfigurationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutEvalTemplateInput
  }

  export type EvalTemplateUncheckedCreateWithoutJobConfigurationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
  }

  export type EvalTemplateCreateOrConnectWithoutJobConfigurationInput = {
    where: EvalTemplateWhereUniqueInput
    create: XOR<EvalTemplateCreateWithoutJobConfigurationInput, EvalTemplateUncheckedCreateWithoutJobConfigurationInput>
  }

  export type JobExecutionCreateWithoutJobConfigurationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
    project: ProjectCreateNestedOneWithoutJobExecutionInput
  }

  export type JobExecutionUncheckedCreateWithoutJobConfigurationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
  }

  export type JobExecutionCreateOrConnectWithoutJobConfigurationInput = {
    where: JobExecutionWhereUniqueInput
    create: XOR<JobExecutionCreateWithoutJobConfigurationInput, JobExecutionUncheckedCreateWithoutJobConfigurationInput>
  }

  export type JobExecutionCreateManyJobConfigurationInputEnvelope = {
    data: JobExecutionCreateManyJobConfigurationInput | JobExecutionCreateManyJobConfigurationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutJobConfigurationInput = {
    update: XOR<ProjectUpdateWithoutJobConfigurationInput, ProjectUncheckedUpdateWithoutJobConfigurationInput>
    create: XOR<ProjectCreateWithoutJobConfigurationInput, ProjectUncheckedCreateWithoutJobConfigurationInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutJobConfigurationInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutJobConfigurationInput, ProjectUncheckedUpdateWithoutJobConfigurationInput>
  }

  export type ProjectUpdateWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EvalTemplateUpsertWithoutJobConfigurationInput = {
    update: XOR<EvalTemplateUpdateWithoutJobConfigurationInput, EvalTemplateUncheckedUpdateWithoutJobConfigurationInput>
    create: XOR<EvalTemplateCreateWithoutJobConfigurationInput, EvalTemplateUncheckedCreateWithoutJobConfigurationInput>
    where?: EvalTemplateWhereInput
  }

  export type EvalTemplateUpdateToOneWithWhereWithoutJobConfigurationInput = {
    where?: EvalTemplateWhereInput
    data: XOR<EvalTemplateUpdateWithoutJobConfigurationInput, EvalTemplateUncheckedUpdateWithoutJobConfigurationInput>
  }

  export type EvalTemplateUpdateWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutEvalTemplateNestedInput
  }

  export type EvalTemplateUncheckedUpdateWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
  }

  export type JobExecutionUpsertWithWhereUniqueWithoutJobConfigurationInput = {
    where: JobExecutionWhereUniqueInput
    update: XOR<JobExecutionUpdateWithoutJobConfigurationInput, JobExecutionUncheckedUpdateWithoutJobConfigurationInput>
    create: XOR<JobExecutionCreateWithoutJobConfigurationInput, JobExecutionUncheckedCreateWithoutJobConfigurationInput>
  }

  export type JobExecutionUpdateWithWhereUniqueWithoutJobConfigurationInput = {
    where: JobExecutionWhereUniqueInput
    data: XOR<JobExecutionUpdateWithoutJobConfigurationInput, JobExecutionUncheckedUpdateWithoutJobConfigurationInput>
  }

  export type JobExecutionUpdateManyWithWhereWithoutJobConfigurationInput = {
    where: JobExecutionScalarWhereInput
    data: XOR<JobExecutionUpdateManyMutationInput, JobExecutionUncheckedUpdateManyWithoutJobConfigurationInput>
  }

  export type ProjectCreateWithoutJobExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutJobExecutionInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutJobExecutionInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutJobExecutionInput, ProjectUncheckedCreateWithoutJobExecutionInput>
  }

  export type JobConfigurationCreateWithoutJobExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
    project: ProjectCreateNestedOneWithoutJobConfigurationInput
    evalTemplate?: EvalTemplateCreateNestedOneWithoutJobConfigurationInput
  }

  export type JobConfigurationUncheckedCreateWithoutJobExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    evalTemplateId?: string | null
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
  }

  export type JobConfigurationCreateOrConnectWithoutJobExecutionInput = {
    where: JobConfigurationWhereUniqueInput
    create: XOR<JobConfigurationCreateWithoutJobExecutionInput, JobConfigurationUncheckedCreateWithoutJobExecutionInput>
  }

  export type ProjectUpsertWithoutJobExecutionInput = {
    update: XOR<ProjectUpdateWithoutJobExecutionInput, ProjectUncheckedUpdateWithoutJobExecutionInput>
    create: XOR<ProjectCreateWithoutJobExecutionInput, ProjectUncheckedCreateWithoutJobExecutionInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutJobExecutionInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutJobExecutionInput, ProjectUncheckedUpdateWithoutJobExecutionInput>
  }

  export type ProjectUpdateWithoutJobExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutJobExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type JobConfigurationUpsertWithoutJobExecutionInput = {
    update: XOR<JobConfigurationUpdateWithoutJobExecutionInput, JobConfigurationUncheckedUpdateWithoutJobExecutionInput>
    create: XOR<JobConfigurationCreateWithoutJobExecutionInput, JobConfigurationUncheckedCreateWithoutJobExecutionInput>
    where?: JobConfigurationWhereInput
  }

  export type JobConfigurationUpdateToOneWithWhereWithoutJobExecutionInput = {
    where?: JobConfigurationWhereInput
    data: XOR<JobConfigurationUpdateWithoutJobExecutionInput, JobConfigurationUncheckedUpdateWithoutJobExecutionInput>
  }

  export type JobConfigurationUpdateWithoutJobExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutJobConfigurationNestedInput
    evalTemplate?: EvalTemplateUpdateOneWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationUncheckedUpdateWithoutJobExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    evalTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateWithoutPosthogIntegrationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPosthogIntegrationInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPosthogIntegrationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPosthogIntegrationInput, ProjectUncheckedCreateWithoutPosthogIntegrationInput>
  }

  export type ProjectUpsertWithoutPosthogIntegrationInput = {
    update: XOR<ProjectUpdateWithoutPosthogIntegrationInput, ProjectUncheckedUpdateWithoutPosthogIntegrationInput>
    create: XOR<ProjectCreateWithoutPosthogIntegrationInput, ProjectUncheckedCreateWithoutPosthogIntegrationInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPosthogIntegrationInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPosthogIntegrationInput, ProjectUncheckedUpdateWithoutPosthogIntegrationInput>
  }

  export type ProjectUpdateWithoutPosthogIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPosthogIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutBatchExportInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBatchExportInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBatchExportInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBatchExportInput, ProjectUncheckedCreateWithoutBatchExportInput>
  }

  export type ProjectUpsertWithoutBatchExportInput = {
    update: XOR<ProjectUpdateWithoutBatchExportInput, ProjectUncheckedUpdateWithoutBatchExportInput>
    create: XOR<ProjectCreateWithoutBatchExportInput, ProjectUncheckedCreateWithoutBatchExportInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBatchExportInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBatchExportInput, ProjectUncheckedUpdateWithoutBatchExportInput>
  }

  export type ProjectUpdateWithoutBatchExportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBatchExportInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMediaInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMediaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
  }

  export type TraceMediaCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    field: string
    project: ProjectCreateNestedOneWithoutTraceMediaInput
  }

  export type TraceMediaUncheckedCreateWithoutMediaInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    field: string
  }

  export type TraceMediaCreateOrConnectWithoutMediaInput = {
    where: TraceMediaWhereUniqueInput
    create: XOR<TraceMediaCreateWithoutMediaInput, TraceMediaUncheckedCreateWithoutMediaInput>
  }

  export type TraceMediaCreateManyMediaInputEnvelope = {
    data: TraceMediaCreateManyMediaInput | TraceMediaCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type ObservationMediaCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    observationId: string
    field: string
    project: ProjectCreateNestedOneWithoutObservationMediaInput
  }

  export type ObservationMediaUncheckedCreateWithoutMediaInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    observationId: string
    field: string
  }

  export type ObservationMediaCreateOrConnectWithoutMediaInput = {
    where: ObservationMediaWhereUniqueInput
    create: XOR<ObservationMediaCreateWithoutMediaInput, ObservationMediaUncheckedCreateWithoutMediaInput>
  }

  export type ObservationMediaCreateManyMediaInputEnvelope = {
    data: ObservationMediaCreateManyMediaInput | ObservationMediaCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutMediaInput = {
    update: XOR<ProjectUpdateWithoutMediaInput, ProjectUncheckedUpdateWithoutMediaInput>
    create: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMediaInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMediaInput, ProjectUncheckedUpdateWithoutMediaInput>
  }

  export type ProjectUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TraceMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: TraceMediaWhereUniqueInput
    update: XOR<TraceMediaUpdateWithoutMediaInput, TraceMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<TraceMediaCreateWithoutMediaInput, TraceMediaUncheckedCreateWithoutMediaInput>
  }

  export type TraceMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: TraceMediaWhereUniqueInput
    data: XOR<TraceMediaUpdateWithoutMediaInput, TraceMediaUncheckedUpdateWithoutMediaInput>
  }

  export type TraceMediaUpdateManyWithWhereWithoutMediaInput = {
    where: TraceMediaScalarWhereInput
    data: XOR<TraceMediaUpdateManyMutationInput, TraceMediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type ObservationMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: ObservationMediaWhereUniqueInput
    update: XOR<ObservationMediaUpdateWithoutMediaInput, ObservationMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<ObservationMediaCreateWithoutMediaInput, ObservationMediaUncheckedCreateWithoutMediaInput>
  }

  export type ObservationMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: ObservationMediaWhereUniqueInput
    data: XOR<ObservationMediaUpdateWithoutMediaInput, ObservationMediaUncheckedUpdateWithoutMediaInput>
  }

  export type ObservationMediaUpdateManyWithWhereWithoutMediaInput = {
    where: ObservationMediaScalarWhereInput
    data: XOR<ObservationMediaUpdateManyMutationInput, ObservationMediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type ProjectCreateWithoutTraceMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTraceMediaInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTraceMediaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTraceMediaInput, ProjectUncheckedCreateWithoutTraceMediaInput>
  }

  export type MediaCreateWithoutTraceMediaInput = {
    id?: string
    sha256Hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    project: ProjectCreateNestedOneWithoutMediaInput
    ObservationMedia?: ObservationMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutTraceMediaInput = {
    id?: string
    sha256Hash: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    ObservationMedia?: ObservationMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutTraceMediaInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutTraceMediaInput, MediaUncheckedCreateWithoutTraceMediaInput>
  }

  export type ProjectUpsertWithoutTraceMediaInput = {
    update: XOR<ProjectUpdateWithoutTraceMediaInput, ProjectUncheckedUpdateWithoutTraceMediaInput>
    create: XOR<ProjectCreateWithoutTraceMediaInput, ProjectUncheckedCreateWithoutTraceMediaInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTraceMediaInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTraceMediaInput, ProjectUncheckedUpdateWithoutTraceMediaInput>
  }

  export type ProjectUpdateWithoutTraceMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTraceMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MediaUpsertWithoutTraceMediaInput = {
    update: XOR<MediaUpdateWithoutTraceMediaInput, MediaUncheckedUpdateWithoutTraceMediaInput>
    create: XOR<MediaCreateWithoutTraceMediaInput, MediaUncheckedCreateWithoutTraceMediaInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutTraceMediaInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutTraceMediaInput, MediaUncheckedUpdateWithoutTraceMediaInput>
  }

  export type MediaUpdateWithoutTraceMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutTraceMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type ProjectCreateWithoutObservationMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    traces?: TraceCreateNestedManyWithoutProjectInput
    observations?: ObservationCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    dataset?: DatasetCreateNestedManyWithoutProjectInput
    RawEvents?: EventsCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionCreateNestedManyWithoutProjectInput
    Prompt?: PromptCreateNestedManyWithoutProjectInput
    Model?: ModelCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationCreateNestedManyWithoutProjectInput
    Score?: ScoreCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportCreateNestedManyWithoutProjectInput
    comment?: CommentCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutProjectInput
    Media?: MediaCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutObservationMediaInput = {
    id?: string
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
    projectMembers?: ProjectMembershipUncheckedCreateNestedManyWithoutProjectInput
    traces?: TraceUncheckedCreateNestedManyWithoutProjectInput
    observations?: ObservationUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    dataset?: DatasetUncheckedCreateNestedManyWithoutProjectInput
    RawEvents?: EventsUncheckedCreateNestedManyWithoutProjectInput
    invitations?: MembershipInvitationUncheckedCreateNestedManyWithoutProjectInput
    sessions?: TraceSessionUncheckedCreateNestedManyWithoutProjectInput
    Prompt?: PromptUncheckedCreateNestedManyWithoutProjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutProjectInput
    EvalTemplate?: EvalTemplateUncheckedCreateNestedManyWithoutProjectInput
    JobConfiguration?: JobConfigurationUncheckedCreateNestedManyWithoutProjectInput
    JobExecution?: JobExecutionUncheckedCreateNestedManyWithoutProjectInput
    LlmApiKeys?: LlmApiKeysUncheckedCreateNestedManyWithoutProjectInput
    PosthogIntegration?: PosthogIntegrationUncheckedCreateNestedManyWithoutProjectInput
    Score?: ScoreUncheckedCreateNestedManyWithoutProjectInput
    scoreConfig?: ScoreConfigUncheckedCreateNestedManyWithoutProjectInput
    BatchExport?: BatchExportUncheckedCreateNestedManyWithoutProjectInput
    comment?: CommentUncheckedCreateNestedManyWithoutProjectInput
    annotationQueue?: AnnotationQueueUncheckedCreateNestedManyWithoutProjectInput
    annotationQueueItem?: AnnotationQueueItemUncheckedCreateNestedManyWithoutProjectInput
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutProjectInput
    Media?: MediaUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutObservationMediaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutObservationMediaInput, ProjectUncheckedCreateWithoutObservationMediaInput>
  }

  export type MediaCreateWithoutObservationMediaInput = {
    id?: string
    sha256Hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    project: ProjectCreateNestedOneWithoutMediaInput
    TraceMedia?: TraceMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutObservationMediaInput = {
    id?: string
    sha256Hash: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
    TraceMedia?: TraceMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutObservationMediaInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutObservationMediaInput, MediaUncheckedCreateWithoutObservationMediaInput>
  }

  export type ProjectUpsertWithoutObservationMediaInput = {
    update: XOR<ProjectUpdateWithoutObservationMediaInput, ProjectUncheckedUpdateWithoutObservationMediaInput>
    create: XOR<ProjectCreateWithoutObservationMediaInput, ProjectUncheckedCreateWithoutObservationMediaInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutObservationMediaInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutObservationMediaInput, ProjectUncheckedUpdateWithoutObservationMediaInput>
  }

  export type ProjectUpdateWithoutObservationMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutObservationMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MediaUpsertWithoutObservationMediaInput = {
    update: XOR<MediaUpdateWithoutObservationMediaInput, MediaUncheckedUpdateWithoutObservationMediaInput>
    create: XOR<MediaCreateWithoutObservationMediaInput, MediaUncheckedCreateWithoutObservationMediaInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutObservationMediaInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutObservationMediaInput, MediaUncheckedUpdateWithoutObservationMediaInput>
  }

  export type MediaUpdateWithoutObservationMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutObservationMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    expires_in?: number | null
    ext_expires_in?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    created_at?: number | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type OrganizationMembershipCreateManyUserInput = {
    id?: string
    orgId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipCreateManyUserInput = {
    orgMembershipId: string
    projectId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipInvitationCreateManyInvitedByUserInput = {
    id?: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectId?: string | null
    projectRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateManyLockedByUserInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateManyAnnotatorUserInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    ext_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
    ProjectMemberships?: ProjectMembershipUpdateManyWithoutOrganizationMembershipNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutOrganizationMembershipNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationMembership?: OrganizationMembershipUpdateOneRequiredWithoutProjectMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMembershipUncheckedUpdateWithoutUserInput = {
    orgMembershipId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipUncheckedUpdateManyWithoutUserInput = {
    orgMembershipId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationUpdateWithoutInvitedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembershipInvitationNestedInput
    project?: ProjectUpdateOneWithoutInvitationsNestedInput
  }

  export type MembershipInvitationUncheckedUpdateWithoutInvitedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationUncheckedUpdateManyWithoutInvitedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUpdateWithoutLockedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: AnnotationQueueUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
    annotatorUser?: UserUpdateOneWithoutAnnotatedCompletedItemNestedInput
    project?: ProjectUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
  }

  export type AnnotationQueueItemUncheckedUpdateWithoutLockedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutLockedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUpdateWithoutAnnotatorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: AnnotationQueueUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
    lockedByUser?: UserUpdateOneWithoutAnnotatedLockedItemNestedInput
    project?: ProjectUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
  }

  export type AnnotationQueueItemUncheckedUpdateWithoutAnnotatorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutAnnotatorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipCreateManyOrganizationInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyOrganizationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    name: string
  }

  export type MembershipInvitationCreateManyOrganizationInput = {
    id?: string
    email: string
    orgRole: $Enums.Role
    projectId?: string | null
    projectRole?: $Enums.Role | null
    invitedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMembershipUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
    ProjectMemberships?: ProjectMembershipUpdateManyWithoutOrganizationMembershipNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectMemberships?: ProjectMembershipUncheckedUpdateManyWithoutOrganizationMembershipNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUpdateManyWithoutProjectNestedInput
    traces?: TraceUpdateManyWithoutProjectNestedInput
    observations?: ObservationUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUpdateManyWithoutProjectNestedInput
    Model?: ModelUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUpdateManyWithoutProjectNestedInput
    Score?: ScoreUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUpdateManyWithoutProjectNestedInput
    comment?: CommentUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUpdateManyWithoutProjectNestedInput
    Media?: MediaUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    projectMembers?: ProjectMembershipUncheckedUpdateManyWithoutProjectNestedInput
    traces?: TraceUncheckedUpdateManyWithoutProjectNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    dataset?: DatasetUncheckedUpdateManyWithoutProjectNestedInput
    RawEvents?: EventsUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: MembershipInvitationUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: TraceSessionUncheckedUpdateManyWithoutProjectNestedInput
    Prompt?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutProjectNestedInput
    EvalTemplate?: EvalTemplateUncheckedUpdateManyWithoutProjectNestedInput
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutProjectNestedInput
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutProjectNestedInput
    LlmApiKeys?: LlmApiKeysUncheckedUpdateManyWithoutProjectNestedInput
    PosthogIntegration?: PosthogIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutProjectNestedInput
    scoreConfig?: ScoreConfigUncheckedUpdateManyWithoutProjectNestedInput
    BatchExport?: BatchExportUncheckedUpdateManyWithoutProjectNestedInput
    comment?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueue?: AnnotationQueueUncheckedUpdateManyWithoutProjectNestedInput
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutProjectNestedInput
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutProjectNestedInput
    Media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MembershipInvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutInvitationsNestedInput
    invitedByUser?: UserUpdateOneWithoutInvitationsNestedInput
  }

  export type MembershipInvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    invitedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    invitedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipCreateManyProjectInput = {
    orgMembershipId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceCreateManyProjectInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObservationCreateManyProjectInput = {
    id?: string
    traceId?: string | null
    type: $Enums.ObservationType
    startTime?: Date | string
    endTime?: Date | string | null
    name?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: string | null
    level?: $Enums.ObservationLevel
    statusMessage?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model?: string | null
    internalModel?: string | null
    internalModelId?: string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    unit?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: Decimal | DecimalJsLike | number | string | null
    completionStartTime?: Date | string | null
    promptId?: string | null
  }

  export type ApiKeyCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    note?: string | null
    publicKey: string
    hashedSecretKey: string
    fastHashedSecretKey?: string | null
    displaySecretKey: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type DatasetCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
  }

  export type MembershipInvitationCreateManyProjectInput = {
    id?: string
    email: string
    orgId: string
    orgRole: $Enums.Role
    projectRole?: $Enums.Role | null
    invitedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceSessionCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarked?: boolean
    public?: boolean
  }

  export type PromptCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    prompt: JsonNullValueInput | InputJsonValue
    name: string
    version: number
    type?: string
    isActive?: boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptCreatetagsInput | string[]
    labels?: PromptCreatelabelsInput | string[]
  }

  export type ModelCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    modelName: string
    matchPattern: string
    startDate?: Date | string | null
    inputPrice?: Decimal | DecimalJsLike | number | string | null
    outputPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    tokenizerId?: string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EvalTemplateCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version: number
    prompt: string
    model: string
    provider: string
    modelParams: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateCreatevarsInput | string[]
    outputSchema: JsonNullValueInput | InputJsonValue
  }

  export type JobConfigurationCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    evalTemplateId?: string | null
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
  }

  export type JobExecutionCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobConfigurationId: string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
  }

  export type LlmApiKeysCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: string
    adapter: string
    displaySecretKey: string
    secretKey: string
    baseURL?: string | null
    customModels?: LlmApiKeysCreatecustomModelsInput | string[]
    withDefaultModels?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PosthogIntegrationCreateManyProjectInput = {
    encryptedPosthogApiKey: string
    posthogHostName: string
    lastSyncAt?: Date | string | null
    enabled: boolean
    createdAt?: Date | string
  }

  export type ScoreCreateManyProjectInput = {
    id?: string
    timestamp?: Date | string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    configId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
  }

  export type ScoreConfigCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dataType: $Enums.ScoreDataType
    isArchived?: boolean
    minValue?: number | null
    maxValue?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
  }

  export type BatchExportCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    finishedAt?: Date | string | null
    expiresAt?: Date | string | null
    name: string
    status: string
    query: JsonNullValueInput | InputJsonValue
    format: string
    url?: string | null
    log?: string | null
  }

  export type CommentCreateManyProjectInput = {
    id?: string
    objectType: $Enums.CommentObjectType
    objectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    authorUserId?: string | null
  }

  export type AnnotationQueueCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    scoreConfigIds?: AnnotationQueueCreatescoreConfigIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemCreateManyProjectInput = {
    id?: string
    queueId: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceMediaCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    field: string
  }

  export type MediaCreateManyProjectInput = {
    id?: string
    sha256Hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedAt?: Date | string | null
    uploadHttpStatus?: number | null
    uploadHttpError?: string | null
    bucketPath: string
    bucketName: string
    contentType: string
    contentLength: bigint | number
  }

  export type ObservationMediaCreateManyProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaId: string
    traceId: string
    observationId: string
    field: string
  }

  export type ProjectMembershipUpdateWithoutProjectInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationMembership?: OrganizationMembershipUpdateOneRequiredWithoutProjectMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMembershipUncheckedUpdateWithoutProjectInput = {
    orgMembershipId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipUncheckedUpdateManyWithoutProjectInput = {
    orgMembershipId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TraceSessionUpdateOneWithoutTracesNestedInput
  }

  export type TraceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumObservationTypeFieldUpdateOperationsInput | $Enums.ObservationType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    parentObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumObservationLevelFieldUpdateOperationsInput | $Enums.ObservationLevel
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    internalModel?: NullableStringFieldUpdateOperationsInput | string | null
    internalModelId?: NullableStringFieldUpdateOperationsInput | string | null
    modelParameters?: NullableJsonNullValueInput | InputJsonValue
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedInputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedOutputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedTotalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    hashedSecretKey?: StringFieldUpdateOperationsInput | string
    fastHashedSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DatasetUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetItems?: DatasetItemUpdateManyWithoutDatasetNestedInput
    datasetRuns?: DatasetRunsUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetItems?: DatasetItemUncheckedUpdateManyWithoutDatasetNestedInput
    datasetRuns?: DatasetRunsUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipInvitationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembershipInvitationNestedInput
    invitedByUser?: UserUpdateOneWithoutInvitationsNestedInput
  }

  export type MembershipInvitationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    invitedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipInvitationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    orgRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    projectRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    invitedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceSessionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    traces?: TraceUpdateManyWithoutSessionNestedInput
  }

  export type TraceSessionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    traces?: TraceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TraceSessionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
  }

  export type PromptUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
  }

  export type PromptUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prompt?: JsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    config?: JsonNullValueInput | InputJsonValue
    tags?: PromptUpdatetagsInput | string[]
    labels?: PromptUpdatelabelsInput | string[]
  }

  export type ModelUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    Price?: PriceUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
    Price?: PriceUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    matchPattern?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenizerConfig?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EvalTemplateUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
    JobConfiguration?: JobConfigurationUpdateManyWithoutEvalTemplateNestedInput
  }

  export type EvalTemplateUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
    JobConfiguration?: JobConfigurationUncheckedUpdateManyWithoutEvalTemplateNestedInput
  }

  export type EvalTemplateUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    modelParams?: JsonNullValueInput | InputJsonValue
    vars?: EvalTemplateUpdatevarsInput | string[]
    outputSchema?: JsonNullValueInput | InputJsonValue
  }

  export type JobConfigurationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    evalTemplate?: EvalTemplateUpdateOneWithoutJobConfigurationNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    evalTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    evalTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type JobExecutionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
    jobConfiguration?: JobConfigurationUpdateOneRequiredWithoutJobExecutionNestedInput
  }

  export type JobExecutionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobConfigurationId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobExecutionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobConfigurationId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LlmApiKeysUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LlmApiKeysUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LlmApiKeysUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    adapter?: StringFieldUpdateOperationsInput | string
    displaySecretKey?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    customModels?: LlmApiKeysUpdatecustomModelsInput | string[]
    withDefaultModels?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PosthogIntegrationUpdateWithoutProjectInput = {
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosthogIntegrationUncheckedUpdateWithoutProjectInput = {
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosthogIntegrationUncheckedUpdateManyWithoutProjectInput = {
    encryptedPosthogApiKey?: StringFieldUpdateOperationsInput | string
    posthogHostName?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoreUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    scoreConfig?: ScoreConfigUpdateOneWithoutScoreNestedInput
  }

  export type ScoreUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type ScoreUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type ScoreConfigUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: ScoreUpdateManyWithoutScoreConfigNestedInput
  }

  export type ScoreConfigUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: ScoreUncheckedUpdateManyWithoutScoreConfigNestedInput
  }

  export type ScoreConfigUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchExportUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchExportUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchExportUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    query?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectType?: EnumCommentObjectTypeFieldUpdateOperationsInput | $Enums.CommentObjectType
    objectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnotationQueueUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotationQueueItem?: AnnotationQueueItemUpdateManyWithoutQueueNestedInput
  }

  export type AnnotationQueueUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotationQueueItem?: AnnotationQueueItemUncheckedUpdateManyWithoutQueueNestedInput
  }

  export type AnnotationQueueUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scoreConfigIds?: AnnotationQueueUpdatescoreConfigIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: AnnotationQueueUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
    lockedByUser?: UserUpdateOneWithoutAnnotatedLockedItemNestedInput
    annotatorUser?: UserUpdateOneWithoutAnnotatedCompletedItemNestedInput
  }

  export type AnnotationQueueItemUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueId?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceMediaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    media?: MediaUpdateOneRequiredWithoutTraceMediaNestedInput
  }

  export type TraceMediaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type TraceMediaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    TraceMedia?: TraceMediaUpdateManyWithoutMediaNestedInput
    ObservationMedia?: ObservationMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
    TraceMedia?: TraceMediaUncheckedUpdateManyWithoutMediaNestedInput
    ObservationMedia?: ObservationMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sha256Hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadHttpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    uploadHttpError?: NullableStringFieldUpdateOperationsInput | string | null
    bucketPath?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentLength?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ObservationMediaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    media?: MediaUpdateOneRequiredWithoutObservationMediaNestedInput
  }

  export type ObservationMediaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationMediaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMembershipCreateManyOrganizationMembershipInput = {
    projectId: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMembershipUpdateWithoutOrganizationMembershipInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMembershipUncheckedUpdateWithoutOrganizationMembershipInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMembershipUncheckedUpdateManyWithoutOrganizationMembershipInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceCreateManySessionInput = {
    id?: string
    externalId?: string | null
    timestamp?: Date | string
    name?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: string | null
    version?: string | null
    public?: boolean
    bookmarked?: boolean
    tags?: TraceCreatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TraceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTracesNestedInput
  }

  export type TraceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    release?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    tags?: TraceUpdatetagsInput | string[]
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoreCreateManyScoreConfigInput = {
    id?: string
    timestamp?: Date | string
    projectId: string
    name: string
    value?: number | null
    source: $Enums.ScoreSource
    authorUserId?: string | null
    comment?: string | null
    traceId: string
    observationId?: string | null
    stringValue?: string | null
    queueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataType?: $Enums.ScoreDataType
  }

  export type ScoreUpdateWithoutScoreConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
    project?: ProjectUpdateOneRequiredWithoutScoreNestedInput
  }

  export type ScoreUncheckedUpdateWithoutScoreConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type ScoreUncheckedUpdateManyWithoutScoreConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumScoreSourceFieldUpdateOperationsInput | $Enums.ScoreSource
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataType?: EnumScoreDataTypeFieldUpdateOperationsInput | $Enums.ScoreDataType
  }

  export type AnnotationQueueItemCreateManyQueueInput = {
    id?: string
    objectId: string
    objectType: $Enums.AnnotationQueueObjectType
    status?: $Enums.AnnotationQueueStatus
    lockedAt?: Date | string | null
    lockedByUserId?: string | null
    annotatorUserId?: string | null
    completedAt?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationQueueItemUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedByUser?: UserUpdateOneWithoutAnnotatedLockedItemNestedInput
    annotatorUser?: UserUpdateOneWithoutAnnotatedCompletedItemNestedInput
    project?: ProjectUpdateOneRequiredWithoutAnnotationQueueItemNestedInput
  }

  export type AnnotationQueueItemUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationQueueItemUncheckedUpdateManyWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectId?: StringFieldUpdateOperationsInput | string
    objectType?: EnumAnnotationQueueObjectTypeFieldUpdateOperationsInput | $Enums.AnnotationQueueObjectType
    status?: EnumAnnotationQueueStatusFieldUpdateOperationsInput | $Enums.AnnotationQueueStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    annotatorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetItemCreateManyDatasetInput = {
    id?: string
    status?: $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: string | null
    sourceObservationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunsCreateManyDatasetInput = {
    id?: string
    name: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetItemUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRunItems?: DatasetRunItemsUpdateManyWithoutDatasetItemNestedInput
  }

  export type DatasetItemUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRunItems?: DatasetRunItemsUncheckedUpdateManyWithoutDatasetItemNestedInput
  }

  export type DatasetItemUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sourceTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunsUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRunItems?: DatasetRunItemsUpdateManyWithoutDatasetRunNestedInput
  }

  export type DatasetRunsUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRunItems?: DatasetRunItemsUncheckedUpdateManyWithoutDatasetRunNestedInput
  }

  export type DatasetRunsUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsCreateManyDatasetItemInput = {
    id?: string
    datasetRunId: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunItemsUpdateWithoutDatasetItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetRun?: DatasetRunsUpdateOneRequiredWithoutDatasetRunItemsNestedInput
  }

  export type DatasetRunItemsUncheckedUpdateWithoutDatasetItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetRunId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsUncheckedUpdateManyWithoutDatasetItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetRunId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsCreateManyDatasetRunInput = {
    id?: string
    datasetItemId: string
    traceId: string
    observationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetRunItemsUpdateWithoutDatasetRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    datasetItem?: DatasetItemUpdateOneRequiredWithoutDatasetRunItemsNestedInput
  }

  export type DatasetRunItemsUncheckedUpdateWithoutDatasetRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetItemId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetRunItemsUncheckedUpdateManyWithoutDatasetRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetItemId?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceCreateManyModelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usageType: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type PriceUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PriceUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PriceUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JobConfigurationCreateManyEvalTemplateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    jobType: $Enums.JobType
    status?: $Enums.JobConfigState
    scoreName: string
    filter: JsonNullValueInput | InputJsonValue
    targetObject: string
    variableMapping: JsonNullValueInput | InputJsonValue
    sampling: Decimal | DecimalJsLike | number | string
    delay: number
  }

  export type JobConfigurationUpdateWithoutEvalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutJobConfigurationNestedInput
    JobExecution?: JobExecutionUpdateManyWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationUncheckedUpdateWithoutEvalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
    JobExecution?: JobExecutionUncheckedUpdateManyWithoutJobConfigurationNestedInput
  }

  export type JobConfigurationUncheckedUpdateManyWithoutEvalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobConfigStateFieldUpdateOperationsInput | $Enums.JobConfigState
    scoreName?: StringFieldUpdateOperationsInput | string
    filter?: JsonNullValueInput | InputJsonValue
    targetObject?: StringFieldUpdateOperationsInput | string
    variableMapping?: JsonNullValueInput | InputJsonValue
    sampling?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type JobExecutionCreateManyJobConfigurationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    status: $Enums.JobExecutionStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    error?: string | null
    jobInputTraceId?: string | null
    jobInputObservationId?: string | null
    jobInputDatasetItemId?: string | null
    jobOutputScoreId?: string | null
  }

  export type JobExecutionUpdateWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutJobExecutionNestedInput
  }

  export type JobExecutionUncheckedUpdateWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobExecutionUncheckedUpdateManyWithoutJobConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobExecutionStatusFieldUpdateOperationsInput | $Enums.JobExecutionStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputObservationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobInputDatasetItemId?: NullableStringFieldUpdateOperationsInput | string | null
    jobOutputScoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceMediaCreateManyMediaInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    field: string
  }

  export type ObservationMediaCreateManyMediaInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traceId: string
    observationId: string
    field: string
  }

  export type TraceMediaUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTraceMediaNestedInput
  }

  export type TraceMediaUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type TraceMediaUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationMediaUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutObservationMediaNestedInput
  }

  export type ObservationMediaUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationMediaUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traceId?: StringFieldUpdateOperationsInput | string
    observationId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationMembershipCountOutputTypeDefaultArgs instead
     */
    export type OrganizationMembershipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationMembershipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TraceSessionCountOutputTypeDefaultArgs instead
     */
    export type TraceSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TraceSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScoreConfigCountOutputTypeDefaultArgs instead
     */
    export type ScoreConfigCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScoreConfigCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnotationQueueCountOutputTypeDefaultArgs instead
     */
    export type AnnotationQueueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnotationQueueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetCountOutputTypeDefaultArgs instead
     */
    export type DatasetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetItemCountOutputTypeDefaultArgs instead
     */
    export type DatasetItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetRunsCountOutputTypeDefaultArgs instead
     */
    export type DatasetRunsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetRunsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelCountOutputTypeDefaultArgs instead
     */
    export type ModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvalTemplateCountOutputTypeDefaultArgs instead
     */
    export type EvalTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvalTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobConfigurationCountOutputTypeDefaultArgs instead
     */
    export type JobConfigurationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobConfigurationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaCountOutputTypeDefaultArgs instead
     */
    export type MediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BackgroundMigrationDefaultArgs instead
     */
    export type BackgroundMigrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BackgroundMigrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LlmApiKeysDefaultArgs instead
     */
    export type LlmApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LlmApiKeysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationMembershipDefaultArgs instead
     */
    export type OrganizationMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMembershipDefaultArgs instead
     */
    export type ProjectMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembershipInvitationDefaultArgs instead
     */
    export type MembershipInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembershipInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TraceSessionDefaultArgs instead
     */
    export type TraceSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TraceSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TraceDefaultArgs instead
     */
    export type TraceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TraceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObservationDefaultArgs instead
     */
    export type ObservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScoreDefaultArgs instead
     */
    export type ScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScoreConfigDefaultArgs instead
     */
    export type ScoreConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScoreConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnotationQueueDefaultArgs instead
     */
    export type AnnotationQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnotationQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnotationQueueItemDefaultArgs instead
     */
    export type AnnotationQueueItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnotationQueueItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CronJobsDefaultArgs instead
     */
    export type CronJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CronJobsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetDefaultArgs instead
     */
    export type DatasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetItemDefaultArgs instead
     */
    export type DatasetItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetRunsDefaultArgs instead
     */
    export type DatasetRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetRunsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetRunItemsDefaultArgs instead
     */
    export type DatasetRunItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetRunItemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventsDefaultArgs instead
     */
    export type EventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptDefaultArgs instead
     */
    export type PromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelDefaultArgs instead
     */
    export type ModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceDefaultArgs instead
     */
    export type PriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvalTemplateDefaultArgs instead
     */
    export type EvalTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvalTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobConfigurationDefaultArgs instead
     */
    export type JobConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobConfigurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobExecutionDefaultArgs instead
     */
    export type JobExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SsoConfigDefaultArgs instead
     */
    export type SsoConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SsoConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PosthogIntegrationDefaultArgs instead
     */
    export type PosthogIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PosthogIntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatchExportDefaultArgs instead
     */
    export type BatchExportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatchExportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TraceMediaDefaultArgs instead
     */
    export type TraceMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TraceMediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObservationMediaDefaultArgs instead
     */
    export type ObservationMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObservationMediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TraceViewDefaultArgs instead
     */
    export type TraceViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TraceViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObservationViewDefaultArgs instead
     */
    export type ObservationViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObservationViewDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}